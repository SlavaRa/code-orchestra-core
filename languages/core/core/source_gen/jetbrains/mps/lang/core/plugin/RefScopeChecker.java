package jetbrains.mps.lang.core.plugin;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.IScope;
import jetbrains.mps.lang.core.behavior.BaseConcept_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.project.IModule;
import java.util.Set;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.smodel.constraints.INodeReferentSearchScopeProvider;
import jetbrains.mps.smodel.constraints.ModelConstraintsUtil;
import jetbrains.mps.smodel.constraints.SearchScopeStatus;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.errors.messageTargets.ReferenceMessageTarget;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.project.GlobalScope;

public class RefScopeChecker extends AbstractConstraintsChecker {
  public RefScopeChecker() {
  }

  public void checkNode(final SNode node, LanguageErrorsComponent component, final IOperationContext operationContext, IScope scope) {
    if (operationContext == null) {
      return;
    }
    if (BaseConcept_Behavior.call_getMetaLevel_3981318653438234726(SNodeOperations.cast(node, "jetbrains.mps.lang.core.structure.BaseConcept")) != 0) {
      return;
    }
    SNode concept = SNodeOperations.getConceptDeclaration(node);
    for (SReference ref : SNodeOperations.getReferences(node)) {
      SNode target = SLinkOperations.getTargetNode(ref);
      SNode ld = SLinkOperations.findLinkDeclaration(ref);
      // don't check unresolved and broken references, they should already have an error message 
      if ((target == null) || ld == null) {
        continue;
      }
      component.addDependency(target);
      component.addDependency(ld);
      String linkRole = SModelUtil.getGenuineLinkRole(ld);
      final SNode linkTarget = SLinkOperations.getTarget(ld, "target", false);
      final INodeReferentSearchScopeProvider scopeProvider = ModelConstraintsUtil.getSearchScopeProvider(concept, linkRole);
      SearchScopeStatus searchScopeStatus = component.runCheckingAction(new _FunctionTypes._return_P0_E0<SearchScopeStatus>() {
        public SearchScopeStatus invoke() {
          return ModelConstraintsUtil.createSearchScope(scopeProvider, SNodeOperations.getModel(node), SNodeOperations.getParent(node), node, linkTarget, operationContext);
        }
      });
      if (searchScopeStatus.isError()) {
        // RE-2611
        if (searchScopeStatus.getMessage() != null) {
          component.addError(node, searchScopeStatus.getMessage(), (SNode) null, new ReferenceMessageTarget(SLinkOperations.getRole(ref)));
        }
      } else if (!(searchScopeStatus.isDefault() || searchScopeStatus.getSearchScope().isInScope(target))) {
        String name = target.getName();

        // RE-2300
        /*
        component.addError(node, "reference" + ((name == null ?
          "" :
          " " + name
        )) + " (" + SLinkOperations.getRole(ref) + ") is out of search scope", searchScopeStatus.getReferenceValidatorNode(), new ReferenceMessageTarget(SLinkOperations.getRole(ref)));
        */
      }

      /*
      SModelReference uid = ref.getTargetSModelReference();
      if (uid == null) {
        continue;
      }
      SModelDescriptor descriptor = GlobalScope.getInstance().getModelDescriptor(uid);
      if (scope.getModelDescriptor(uid) == null && descriptor != null) {
        component.addError(node, "Target module " + descriptor.getModule() + " should be imported", null);
      }
      */
    }
  }
}
