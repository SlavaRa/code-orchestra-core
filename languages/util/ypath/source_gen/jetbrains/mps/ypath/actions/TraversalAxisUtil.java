package jetbrains.mps.ypath.actions;

/*Generated by MPS */

import jetbrains.mps.ypath.runtime.TraversalAxis;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public class TraversalAxisUtil {
  public static String getOperationSign(TraversalAxis axis) {
    switch (axis) {
      case ANCESTORS:
        return "\\\\ancestors";
      case CHILDREN:
        return "\\";
      case DESCENDANTS:
        return "\\\\descendants";
      case SELF_DESCENDANTS:
        return "\\\\descendants+";
      case PRECEDING_SIBLINGS:
        return "\\\\preceding";
      case PRECEDING_SIBLINGS_SELF:
        return "\\\\preceding+";
      case FOLLOWING_SIBLINGS:
        return "\\\\following";
      case SELF_FOLLOWING_SIBLINGS:
        return "\\\\following+";
      case SELF_ANCESTORS:
        return "\\\\ancestors+";
      default:
        return "???";
    }
  }

  public static boolean isAbbreviated(TraversalAxis axis) {
    switch (axis) {
      case CHILDREN:
        return true;
      case DESCENDANTS:
        // fall through 
      case ANCESTORS:
        // fall through 
      case PRECEDING_SIBLINGS:
        // fall through 
      case FOLLOWING_SIBLINGS:
        // fall through 
      case SELF_DESCENDANTS:
        // fall through 
      case SELF_ANCESTORS:
        // fall through 
      case PRECEDING_SIBLINGS_SELF:
        // fall through 
      case SELF_FOLLOWING_SIBLINGS:
        return false;
      default:
        return false;
    }
  }

  public static boolean isAcceptableFeatureForAxis(SNode feature, TraversalAxis axis) {
    switch (axis) {
      case CHILDREN:
        return !(SPropertyOperations.getBoolean(feature, "ascending"));
      case DESCENDANTS:
        // fall through 
      case SELF_DESCENDANTS:
        return !(SNodeOperations.isInstanceOf(feature, "jetbrains.mps.ypath.structure.IParamFeature")) && !(SPropertyOperations.getBoolean(feature, "ascending"));
      case ANCESTORS:
        // fall through 
      case SELF_ANCESTORS:
        return !(SNodeOperations.isInstanceOf(feature, "jetbrains.mps.ypath.structure.IParamFeature")) && !(SPropertyOperations.getBoolean(feature, "ascending")) && (SLinkOperations.getTarget(feature, "opposite", false) != null);
      case PRECEDING_SIBLINGS:
        // fall through 
      case PRECEDING_SIBLINGS_SELF:
        // fall through 
      case FOLLOWING_SIBLINGS:
        // fall through 
      case SELF_FOLLOWING_SIBLINGS:
        return !(SNodeOperations.isInstanceOf(feature, "jetbrains.mps.ypath.structure.IParamFeature")) && !(SPropertyOperations.getBoolean(feature, "ascending")) && (SLinkOperations.getTarget(feature, "opposite", false) != null);
      default:
        return false;
    }
  }

  public static boolean isUsingOpposite(TraversalAxis axis) {
    switch (axis) {
      case CHILDREN:
        // fall through 
      case DESCENDANTS:
        // fall through 
      case SELF_DESCENDANTS:
        return false;
      case ANCESTORS:
        // fall through 
      case SELF_ANCESTORS:
        return true;
      case PRECEDING_SIBLINGS:
        // fall through 
      case FOLLOWING_SIBLINGS:
        // fall through 
      case PRECEDING_SIBLINGS_SELF:
        // fall through 
      case SELF_FOLLOWING_SIBLINGS:
        return false;
      default:
        return false;
    }
  }

  public static TraversalAxis getOpposite(TraversalAxis axis) {
    switch (axis) {
      case CHILDREN:
        return TraversalAxis.ANCESTORS;
      case DESCENDANTS:
        return TraversalAxis.ANCESTORS;
      case SELF_DESCENDANTS:
        return TraversalAxis.SELF_ANCESTORS;
      case ANCESTORS:
        return TraversalAxis.DESCENDANTS;
      case SELF_ANCESTORS:
        return TraversalAxis.SELF_DESCENDANTS;
      case PRECEDING_SIBLINGS:
        // fall through 
      case FOLLOWING_SIBLINGS:
        // fall through 
      case PRECEDING_SIBLINGS_SELF:
        // fall through 
      case SELF_FOLLOWING_SIBLINGS:
        // fall through 
      default:
        return null;
    }
  }

  public static boolean isIncludingSelf(TraversalAxis axis) {
    switch (axis) {
      case CHILDREN:
        // fall through 
      case DESCENDANTS:
        // fall through 
      case ANCESTORS:
        // fall through 
      case PRECEDING_SIBLINGS:
        // fall through 
      case FOLLOWING_SIBLINGS:
        return false;
      case SELF_DESCENDANTS:
        // fall through 
      case SELF_ANCESTORS:
        // fall through 
      case PRECEDING_SIBLINGS_SELF:
        // fall through 
      case SELF_FOLLOWING_SIBLINGS:
        return true;
      default:
        return false;
    }
  }

  public static boolean isSelfFirst(TraversalAxis axis) {
    switch (axis) {
      case CHILDREN:
        // fall through 
      case DESCENDANTS:
        // fall through 
      case ANCESTORS:
        // fall through 
      case FOLLOWING_SIBLINGS:
        // fall through 
      case SELF_DESCENDANTS:
        // fall through 
      case SELF_ANCESTORS:
        // fall through 
      case SELF_FOLLOWING_SIBLINGS:
        return true;
      case PRECEDING_SIBLINGS:
        // fall through 
      case PRECEDING_SIBLINGS_SELF:
        return false;
      default:
        return false;
    }
  }
}
