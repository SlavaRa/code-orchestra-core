package jetbrains.mps.ypath.runtime.internal;

/*Generated by MPS */

import jetbrains.mps.ypath.runtime.ITreeTraversal;
import jetbrains.mps.ypath.runtime.IFeatureDescriptor;
import jetbrains.mps.ypath.runtime.ITreePath;
import jetbrains.mps.ypath.runtime.TreePath;
import java.util.Collections;

public abstract class AbstractChainTreeTraversal<T> extends AbstractTreeTraversal<T> {
  private final ITreeTraversal<T> sourceTraversal;
  private final IFeatureDescriptor<T> featureDesc;

  public AbstractChainTreeTraversal(ITreeTraversal<T> sourceTraversal) {
    this.sourceTraversal = sourceTraversal;
    this.featureDesc = null;
  }

  public AbstractChainTreeTraversal(ITreeTraversal<T> sourceTraversal, IFeatureDescriptor<T> feature) {
    this.sourceTraversal = sourceTraversal;
    this.featureDesc = feature;
  }

  public ITreePath<T> getTreePath() {
    return sourceTraversal.getTreePath();
  }

  public IFeatureDescriptor<T> getFeatureDescriptor() {
    return featureDesc;
  }

  protected Iterable<T> getDirectContents(T node) {
    return ((TreePath<T>) getTreePath()).getContents(node, featureDesc, false);
  }

  protected Iterable<T> getOppositeContents(T node) {
    if (featureDesc == null || featureDesc.getOpposite() == null) {
      if (((TreePath<T>) getTreePath()).hasParent(node)) {
        return Collections.singletonList(((TreePath<T>) getTreePath()).getParent(node));
      }
      return Collections.emptyList();
    }
    return ((TreePath<T>) getTreePath()).getContents(node, getTreePath().getFeatureDescriptor(featureDesc.getOpposite()), true);
  }

  protected ITreeTraversal<T> getSourceTraversal() {
    return sourceTraversal;
  }
}
