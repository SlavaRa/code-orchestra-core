package jetbrains.mps.graphLayout.graph;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class ClusteredGraph extends Graph implements IClusteredGraph {
  private Tree myInclusionTree;
  private Map<Node, Node> myLeafClusters;
  private Node myRoot;

  public ClusteredGraph() {
    super();
    myInclusionTree = new Tree();
    myLeafClusters = MapSequence.fromMap(new HashMap<Node, Node>());
  }

  public Set<Node> getNodesInCluster(INode cluster) {
    Set<Node> nodes = SetSequence.fromSet(new LinkedHashSet<Node>());
    getNodesInCluster(((Node) cluster), nodes);
    return nodes;
  }

  public List<Node> getSubclusters(final Node cluster) {
    return ListSequence.fromList(cluster.getOutEdges()).select(new ISelector<Edge, Node>() {
      public Node select(Edge edge) {
        return edge.getOpposite(cluster);
      }
    }).toListSequence();
  }

  public void setNodeInCluster(Node cluster, Node node) {
    MapSequence.fromMap(myLeafClusters).put(cluster, node);
  }

  private void getNodesInCluster(Node cluster, Set<Node> nodes) {
    List<Node> subclusters = ListSequence.fromList(cluster.getOutEdges()).select(new ISelector<Edge, Node>() {
      public Node select(Edge it) {
        return it.getTarget();
      }
    }).toListSequence();
    for (Node subcluster : ListSequence.fromList(subclusters)) {
      getNodesInCluster(subcluster, nodes);
    }
    Node node = MapSequence.fromMap(myLeafClusters).get(cluster);
    if (node != null) {
      SetSequence.fromSet(nodes).addElement(node);
    }
  }

  public void setRoot(Node root) {
    myRoot = root;
  }

  public Node getRoot() {
    return myRoot;
  }

  public Graph getUnderlyingGraph() {
    return this;
  }

  @Override
  public Graph createNew() {
    return new ClusteredGraph();
  }

  public Tree getInclusionTree() {
    return myInclusionTree;
  }

  public List<Node> getClusters() {
    return getInclusionTree().getNodes();
  }

  /*package*/ void setInclusionTree(Tree tree, Node root) {
    myInclusionTree = tree;
    setRoot(root);
  }

  public boolean isLeafCluster(Node cluster) {
    return ListSequence.fromList(cluster.getOutEdges()).count() == 0;
  }
}
