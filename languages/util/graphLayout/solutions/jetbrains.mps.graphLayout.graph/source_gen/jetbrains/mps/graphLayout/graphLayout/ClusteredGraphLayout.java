package jetbrains.mps.graphLayout.graphLayout;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import java.util.List;
import jetbrains.mps.graphLayout.intGeom2D.Point;
import jetbrains.mps.graphLayout.graph.ClusteredGraph;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.graphLayout.intGeom2D.GeomUtil;
import jetbrains.mps.graphLayout.intGeom2D.Rectangle;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class ClusteredGraphLayout extends GraphLayout {
  private Map<Node, List<Point>> myClusterLayout;

  public ClusteredGraphLayout(ClusteredGraph graph) {
    super(graph);
    myClusterLayout = MapSequence.fromMap(new HashMap<Node, List<Point>>());
  }

  public void setClusterLayout(Node cluster, List<Point> borderLayout) {
    MapSequence.fromMap(myClusterLayout).put(cluster, borderLayout);
  }

  public List<Point> getClusterLayout(Node cluster) {
    return MapSequence.fromMap(myClusterLayout).get(cluster);
  }

  public Set<Node> getLayoutedClusters() {
    return MapSequence.fromMap(myClusterLayout).keySet();
  }

  @Override
  public ClusteredGraphLayout shift(int xShift, int yShift) {
    ClusteredGraphLayout graphLayout = ((ClusteredGraphLayout) super.shift(xShift, yShift));
    for (Node cluster : SetSequence.fromSet(getLayoutedClusters())) {
      List<Point> clusterLayout = getClusterLayout(cluster);
      graphLayout.setClusterLayout(cluster, GeomUtil.shiftPolyline(clusterLayout, xShift, yShift));
    }
    return graphLayout;
  }

  @Override
  public Rectangle getContainingRectangle() {
    Rectangle rect = super.getContainingRectangle();
    int minX = rect.x;
    int minY = rect.y;
    int maxX = rect.maxX();
    int maxY = rect.maxY();
    for (Node cluster : SetSequence.fromSet(getLayoutedClusters())) {
      for (Point p : ListSequence.fromList(getClusterLayout(cluster))) {
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
      }
    }
    return new Rectangle(minX, minY, maxX - minX, maxY - minY);
  }
}
