package jetbrains.mps.graphLayout.algorithms;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.LinkedListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;

public class ConnectivityComponents {
  public static Map<Node, Integer> getComponents(Graph graph) {
    return getComponents(graph, new _FunctionTypes._return_P1_E0<Boolean, Edge>() {
      public Boolean invoke(Edge edge) {
        return true;
      }
    });
  }

  public static Map<Node, Integer> getComponents(Graph graph, _FunctionTypes._return_P1_E0<? extends Boolean, ? super Edge> filter) {
    ConnectivityComponents.MyDfs dfs = new ConnectivityComponents.MyDfs();
    dfs.doDfs(graph, Edge.Direction.BOTH, filter);
    return dfs.getComponents();
  }

  public static boolean isConnected(Graph graph) {
    Map<Node, Integer> component = getComponents(graph);
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      if (MapSequence.fromMap(component).get(node) > 0) {
        return false;
      }
    }
    return true;
  }

  public static List<List<Node>> getComponentsList(Map<Node, Integer> components) {
    int componentsNum = ConnectivityComponents.getComponentsNum(components);
    List<List<Node>> componentsList = ListSequence.fromList(new ArrayList<List<Node>>(componentsNum));
    for (int i = 0; i < componentsNum; i++) {
      ListSequence.fromList(componentsList).addElement(LinkedListSequence.fromLinkedList(new LinkedList<Node>()));
    }
    for (Node node : SetSequence.fromSet(MapSequence.fromMap(components).keySet())) {
      ListSequence.fromList(ListSequence.fromList(componentsList).getElement(MapSequence.fromMap(components).get(node))).addElement(node);
    }
    return componentsList;
  }

  private static int getComponentsNum(Map<Node, Integer> components) {
    int componentsNum = 0;
    for (Node node : SetSequence.fromSet(MapSequence.fromMap(components).keySet())) {
      componentsNum = Math.max(componentsNum, MapSequence.fromMap(components).get(node) + 1);
    }
    return componentsNum;
  }

  public static Set<Edge> makeConnected(Graph graph) {
    Set<Edge> addedEdges = SetSequence.fromSet(new HashSet<Edge>());
    Map<Node, Integer> components = getComponents(graph);
    int num = getComponentsNum(components);
    Node[] nodes = new Node[num];
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      nodes[MapSequence.fromMap(components).get(node)] = node;
    }
    Node prev = null;
    for (Node node : nodes) {
      if (prev != null) {
        Edge edge = graph.connect(prev, node);
        SetSequence.fromSet(addedEdges).addElement(edge);
      }
      prev = node;
    }
    return addedEdges;
  }

  private static class MyDfs extends Dfs {
    private Map<Node, Integer> myComponents;
    private int myCurrentComponent;

    public MyDfs() {
    }

    @Override
    public void doDfs(Graph graph, Edge.Direction direction, _FunctionTypes._return_P1_E0<? extends Boolean, ? super Edge> filter) {
      myComponents = MapSequence.fromMap(new HashMap<Node, Integer>());
      myCurrentComponent = -1;
      super.doDfs(graph, Edge.Direction.BOTH, filter);
    }

    @Override
    protected void preprocessRoot(Node root) {
      myCurrentComponent++;
    }

    @Override
    protected void preprocess(Node node, Edge from) {
      MapSequence.fromMap(myComponents).put(node, myCurrentComponent);
    }

    public Map<Node, Integer> getComponents() {
      return this.myComponents;
    }
  }
}
