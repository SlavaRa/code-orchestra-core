package jetbrains.mps.graphLayout.algorithms;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.graphLayout.util.NodeMap;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.List;
import java.util.ArrayList;

public class STNumbering {
  public static Map<Node, Integer> number(Graph graph, Node source, Node target) {
    Edge stEdge = null;
    boolean deleteAfter = false;
    for (Edge edge : ListSequence.fromList(source.getEdges())) {
      if (edge.getOpposite(source) == target) {
        stEdge = edge;
      }
    }
    if (stEdge == null) {
      stEdge = graph.connect(source, target);
      deleteAfter = true;
    }
    BiconnectedComponents biconnectedComponents = new BiconnectedComponents();
    biconnectedComponents.doDfs(graph, source, stEdge);
    Map<Node, Node> low = biconnectedComponents.getLow();
    STNumbering.Numbering numbering = new STNumbering.Numbering();
    numbering.doDfs(graph, source, stEdge, low);
    Map<Node, Integer> res = new NodeMap<Integer>(graph);
    int curNum = 0;
    for (Node node : ListSequence.fromList(numbering.getList())) {
      MapSequence.fromMap(res).put(node, curNum++);
    }
    if (deleteAfter) {
      graph.removeEdge(stEdge);
    }
    return res;
  }

  public static class Numbering extends Dfs {
    private Map<Node, Integer> mySign;
    private Map<Node, Node> myLow;
    private List<Node> myList;
    private Node myTarget;

    public Numbering() {
    }

    public void doDfs(Graph graph, Node source, Edge stEdge, Map<Node, Node> low) {
      init(graph, Edge.Direction.BOTH);
      myLow = low;
      mySign = new NodeMap<Integer>(graph);
      MapSequence.fromMap(getDfsState()).put(source, DURING);
      Node target = stEdge.getOpposite(source);
      myTarget = target;
      MapSequence.fromMap(mySign).put(source, -1);
      myList = ListSequence.fromListAndArray(new ArrayList<Node>(), source, target);
      dfs(target, stEdge);
    }

    @Override
    protected void preprocess(Node node, Edge from) {
      if (node != myTarget) {
        Node prev = from.getOpposite(node);
        int prevIndex = ListSequence.fromList(myList).indexOf(prev);
        int nodeIndex = prevIndex;
        if (MapSequence.fromMap(mySign).get(MapSequence.fromMap(myLow).get(node)) > 0) {
          nodeIndex = prevIndex + 1;
        }
        ListSequence.fromList(myList).insertElement(nodeIndex, node);
        MapSequence.fromMap(mySign).put(prev, -MapSequence.fromMap(mySign).get(MapSequence.fromMap(myLow).get(node)));
      }
    }

    public List<Node> getList() {
      return myList;
    }
  }
}
