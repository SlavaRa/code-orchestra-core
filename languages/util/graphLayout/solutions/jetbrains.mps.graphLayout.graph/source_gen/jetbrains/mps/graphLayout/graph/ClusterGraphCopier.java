package jetbrains.mps.graphLayout.graph;

/*Generated by MPS */

import java.util.Map;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.graphLayout.util.Filter;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.graphLayout.graphLayout.ClusteredGraphLayout;
import jetbrains.mps.graphLayout.graphLayout.GraphLayout;
import jetbrains.mps.graphLayout.intGeom2D.Point;

public class ClusterGraphCopier extends GraphCopier {
  private Map<Node, Node> myClusterMap;
  private ClusteredGraph myClusteredGraph;
  private Set<Node> myGoodClusters;

  public ClusterGraphCopier(ClusteredGraph graph) {
    super(graph);
    myClusteredGraph = graph;
    myClusterMap = MapSequence.fromMap(new HashMap<Node, Node>());
    myGoodClusters = SetSequence.fromSet(new HashSet<Node>());
  }

  @Override
  public Graph copySubgraph(Filter<INode> nodeFilter) {
    super.copySubgraph(nodeFilter);
    Tree tree = myClusteredGraph.getInclusionTree();
    List<Node> clusters = tree.getNodes();
    for (Node leafCluster : ListSequence.fromList(clusters).where(new IWhereFilter<Node>() {
      public boolean accept(Node it) {
        return ListSequence.fromList(it.getOutEdges()).count() == 0;
      }
    })) {
      Node node = this.getLeafNode(leafCluster);
      if (nodeFilter.accept(node)) {
        findGoodClusters(leafCluster);
      }
    }
    Tree copyTree = getCopy().getInclusionTree();
    Node copyRoot = copyTree.createNode();
    getCopy().setRoot(copyRoot);
    copyCluster(myClusteredGraph.getRoot(), copyRoot);
    return getCopy();
  }

  private Node getLeafNode(Node leafCluster) {
    return SetSequence.fromSet(myClusteredGraph.getNodesInCluster(leafCluster)).first();
  }

  private void findGoodClusters(Node cluster) {
    Node curCluster = cluster;
    while (curCluster != myClusteredGraph.getRoot() && !(SetSequence.fromSet(myGoodClusters).contains(curCluster))) {
      SetSequence.fromSet(myGoodClusters).addElement(curCluster);
      curCluster = myClusteredGraph.getInclusionTree().getParent(curCluster);
    }
    SetSequence.fromSet(myGoodClusters).addElement(curCluster);
  }

  private void copyCluster(Node cluster, Node copy) {
    MapSequence.fromMap(myClusterMap).put(cluster, copy);
    List<Node> children = myClusteredGraph.getInclusionTree().getChildren(cluster);
    if (ListSequence.fromList(children).count() == 0) {
      getCopy().setNodeInCluster(copy, getNodeCopy(this.getLeafNode(cluster)));
    } else {
      for (Node child : ListSequence.fromList(children).where(new IWhereFilter<Node>() {
        public boolean accept(Node it) {
          return SetSequence.fromSet(myGoodClusters).contains(it);
        }
      })) {
        Tree tree = getCopy().getInclusionTree();
        Node copyChild = tree.createNode();
        tree.connect(copy, copyChild);
        copyCluster(child, copyChild);
      }
    }
  }

  @Override
  public ClusteredGraphLayout restoreLayout(GraphLayout copyLayout) {
    ClusteredGraphLayout graphLayout = ((ClusteredGraphLayout) super.restoreLayout(copyLayout));
    if (copyLayout instanceof ClusteredGraphLayout) {
      ClusteredGraphLayout clusteredCopyLayout = ((ClusteredGraphLayout) copyLayout);
      for (Node cluster : ListSequence.fromList(myClusteredGraph.getClusters())) {
        List<Point> route = clusteredCopyLayout.getClusterLayout(getCluserCopy(cluster));
        if (route != null) {
          graphLayout.setClusterLayout(cluster, route);
        }
      }
    }
    return graphLayout;
  }

  public Node getCluserCopy(Node cluster) {
    return MapSequence.fromMap(myClusterMap).get(cluster);
  }

  public Set<Node> getCopiedClusters() {
    return MapSequence.fromMap(myClusterMap).keySet();
  }

  @Override
  public ClusteredGraph getCopy() {
    return ((ClusteredGraph) super.getCopy());
  }
}
