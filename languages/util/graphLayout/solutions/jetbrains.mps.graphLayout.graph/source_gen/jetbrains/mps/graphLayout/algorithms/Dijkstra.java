package jetbrains.mps.graphLayout.algorithms;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.graph.Node;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Edge;
import java.util.TreeSet;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.util.Comparator;

public class Dijkstra {
  private Graph myGraph;
  private Node mySource;
  private Map<Edge, Integer> myWeights;
  private Map<Node, Integer> myDist;
  private Map<Node, Edge> myPrev;
  private TreeSet<Node> mySet;

  public Dijkstra(Graph graph, Node source, Map<Edge, Integer> weights) {
    myGraph = graph;
    mySource = source;
    myWeights = weights;
  }

  public void doAlgorithm() {
    doAlgorithm(new _FunctionTypes._return_P1_E0<Boolean, Edge>() {
      public Boolean invoke(Edge edge) {
        return true;
      }
    }, Edge.Direction.FRONT);
  }

  public void doAlgorithm(final _FunctionTypes._return_P1_E0<? extends Boolean, ? super Edge> filter, Edge.Direction direction) {
    init();
    while (mySet.size() > 0) {
      Node first = mySet.first();
      if (MapSequence.fromMap(myDist).get(first) == ShortestPath.INF) {
        break;
      }
      mySet.remove(first);
      for (Edge edge : ListSequence.fromList(first.getEdges(direction)).where(new IWhereFilter<Edge>() {
        public boolean accept(Edge it) {
          return filter.invoke(it);
        }
      })) {
        if (MapSequence.fromMap(myWeights).get(edge) < 0) {

          throw new RuntimeException("dijkstra with negative weights");
        }
        Node opposite = edge.getOpposite(first);
        if (MapSequence.fromMap(myDist).get(opposite) > MapSequence.fromMap(myDist).get(first) + MapSequence.fromMap(myWeights).get(edge)) {
          mySet.remove(opposite);
          MapSequence.fromMap(myDist).put(opposite, MapSequence.fromMap(myDist).get(first) + MapSequence.fromMap(myWeights).get(edge));
          MapSequence.fromMap(myPrev).put(opposite, edge);
          mySet.add(opposite);
        }
      }
    }
  }

  private void init() {
    myDist = MapSequence.fromMap(new HashMap<Node, Integer>());
    myPrev = MapSequence.fromMap(new HashMap<Node, Edge>());
    mySet = new TreeSet<Node>(new Dijkstra.NodeComparator());
    for (Node node : ListSequence.fromList(myGraph.getNodes())) {
      MapSequence.fromMap(myDist).put(node, ShortestPath.INF);
    }
    MapSequence.fromMap(myDist).put(mySource, 0);
    for (Node node : ListSequence.fromList(myGraph.getNodes())) {
      mySet.add(node);
    }
  }

  public List<Edge> getShortestPath(Node target) {
    List<Edge> path = ListSequence.fromList(new LinkedList<Edge>());
    if (MapSequence.fromMap(myDist).get(target) == ShortestPath.INF) {
      return null;
    }
    Node cur = target;
    while (cur != mySource) {
      Edge prev = MapSequence.fromMap(myPrev).get(cur);
      ListSequence.fromList(path).insertElement(0, prev);
      cur = prev.getOpposite(cur);
    }
    return path;
  }

  public Map<Node, Integer> getDistance() {
    return myDist;
  }

  private class NodeComparator implements Comparator<Node> {
    public NodeComparator() {
    }

    public int compare(Node first, Node second) {
      int distCompare = MapSequence.fromMap(myDist).get(first).compareTo(MapSequence.fromMap(myDist).get(second));
      if (distCompare != 0) {
        return distCompare;
      } else {
        return first.getIndex() - second.getIndex();
      }
    }
  }
}
