package jetbrains.mps.graphLayout.algorithms;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.MapSequence;

public class TopologicalSorting extends Dfs {
  private List<Node> myOrder;
  private boolean myHasCycles;

  private TopologicalSorting() {
  }

  @Override
  public void doDfs(Graph graph) {
    myOrder = ListSequence.fromList(new LinkedList<Node>());
    myHasCycles = false;
    super.doDfs(graph);
  }

  @Override
  protected void postprocess(Node node, Edge from) {
    ListSequence.fromList(myOrder).insertElement(0, node);
  }

  private List<Node> getOrder() {
    return myOrder;
  }

  private boolean getHasCycles() {
    return myHasCycles;
  }

  @Override
  protected void processEdge(Edge edge, Node source) {
    if (MapSequence.fromMap(getDfsState()).get(edge.getTarget()) == Dfs.DURING) {
      myHasCycles = true;
    }
  }

  public static List<Node> sort(Graph graph) {
    TopologicalSorting sorter = new TopologicalSorting();
    sorter.doDfs(graph);
    if (sorter.getHasCycles()) {
      return null;
    }
    return sorter.getOrder();
  }

  public static boolean hasCycles(Graph graph) {
    TopologicalSorting sorter = new TopologicalSorting();
    sorter.doDfs(graph);
    return sorter.getHasCycles();
  }
}
