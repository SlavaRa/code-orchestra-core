package jetbrains.mps.graphLayout.algorithms;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Map;
import jetbrains.mps.graphLayout.util.NodeMap;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class ShortestPath {
  public static final int INF = Integer.MAX_VALUE / 2;

  public static List<Edge> getPath(Graph graph, Node source, Node target, Edge.Direction direction) {
    return getPath(graph, source, target, direction, new _FunctionTypes._return_P1_E0<Boolean, Edge>() {
      public Boolean invoke(Edge edge) {
        return true;
      }
    });
  }

  public static List<Edge> getPath(Graph graph, Node source, Node target, Edge.Direction direction, _FunctionTypes._return_P1_E0<? extends Boolean, ? super Edge> filter) {
    Map<Node, Integer> dist = new NodeMap<Integer>(graph);
    Map<Node, Edge> prev = new NodeMap<Edge>(graph);
    Queue<Node> queue = QueueSequence.fromQueue(new LinkedList<Node>());
    MapSequence.fromMap(dist).put(source, 0);
    MapSequence.fromMap(prev).put(source, null);
    QueueSequence.fromQueue(queue).addLastElement(source);
    boolean found = false;
    while (QueueSequence.fromQueue(queue).count() > 0) {
      Node cur = QueueSequence.fromQueue(queue).removeFirstElement();
      if (cur == target) {
        found = true;
        break;
      }
      for (Edge edge : ListSequence.fromList(cur.getEdges(direction))) {
        if (filter.invoke(edge)) {
          Node next = edge.getOpposite(cur);
          if (MapSequence.fromMap(dist).get(next) == null) {
            QueueSequence.fromQueue(queue).addLastElement(next);
            MapSequence.fromMap(dist).put(next, MapSequence.fromMap(dist).get(cur) + 1);
            MapSequence.fromMap(prev).put(next, edge);
          }
        }
      }
    }
    if (!(found)) {
      return null;
    }
    List<Edge> path = ListSequence.fromList(new LinkedList<Edge>());
    Node cur = target;
    while (MapSequence.fromMap(prev).get(cur) != null) {
      ListSequence.fromList(path).insertElement(0, MapSequence.fromMap(prev).get(cur));
      cur = MapSequence.fromMap(prev).get(cur).getOpposite(cur);
    }
    return path;
  }
}
