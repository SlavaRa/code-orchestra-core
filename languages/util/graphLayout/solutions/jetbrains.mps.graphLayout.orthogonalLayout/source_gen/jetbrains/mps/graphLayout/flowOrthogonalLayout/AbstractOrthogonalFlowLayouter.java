package jetbrains.mps.graphLayout.flowOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graphLayout.BasicLayouter;
import java.util.Set;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.graphLayout.GraphLayout;
import jetbrains.mps.graphLayout.graphLayout.LayoutInfo;
import jetbrains.mps.graphLayout.graphLayout.LayoutInfoCopier;
import jetbrains.mps.graphLayout.intGeom2D.Rectangle;
import jetbrains.mps.graphLayout.graph.IEdge;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.graphLayout.intGeom2D.OrthogonalUtil;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.graph.CreationStageManager;
import jetbrains.mps.graphLayout.graph.EdgesHistoryManager;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.HashSet;
import jetbrains.mps.graphLayout.algorithms.BiconnectAugmentation;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.planarization.ShortestPathEmbeddingFinder;
import java.util.Map;
import java.util.List;
import java.util.HashMap;
import jetbrains.mps.graphLayout.intGeom2D.Dimension;
import jetbrains.mps.graphLayout.graphLayout.GraphLayoutFactory;
import jetbrains.mps.graphLayout.intGeom2D.Point;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.planarGraph.Face;
import jetbrains.mps.graphLayout.planarization.IEmbeddingFinder;
import jetbrains.mps.graphLayout.planarization.EmbeddingFinderFactory;
import jetbrains.mps.graphLayout.intGeom2D.Direction2D;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import java.util.Iterator;

public abstract class AbstractOrthogonalFlowLayouter extends BasicLayouter {
  protected static int SHOW_INFO = 0;

  private boolean myAvoidLabelCrossings;
  private boolean myUseRepresentationOptimizations;
  protected Set<Edge> myRealEdges;
  protected Set<Node> myRealNodes;
  protected Set<Edge> myStraightEdges;

  public AbstractOrthogonalFlowLayouter() {
    myAvoidLabelCrossings = true;
    myUseRepresentationOptimizations = true;
  }

  public GraphLayout doLayoutConnectedGraph(LayoutInfo layoutInfo) {
    LayoutInfo copyInfo;
    LayoutInfoCopier copier = new LayoutInfoCopier(layoutInfo);
    copier.copy();
    copyInfo = copier.getLayoutInfoCopy();
    GraphLayout copyLayout = getLayoutCorruptGraph(copyInfo);
    GraphLayout layout = copier.restoreLayout(copyLayout);
    Rectangle rect = layout.getContainingRectangle();
    layout = layout.shift(-rect.x, -rect.y);
    refineLayout(layout);
    return layout;
  }

  private void refineLayout(GraphLayout layout) {
    for (IEdge edge : SetSequence.fromSet(MapSequence.fromMap(layout.getEdgeLayout()).keySet())) {
      layout.setLayoutFor(edge, OrthogonalUtil.refinePolyline(layout.getEdgeLayout(edge)));
    }
  }

  private GraphLayout getLayoutCorruptGraph(LayoutInfo layoutInfo) {
    myStraightEdges = null;
    Graph graph = layoutInfo.getGraph();
    if (graph.getNumNodes() == 1) {
      GraphLayout layout = this.getSingleNodeLayout(graph, layoutInfo);
      return layout;
    }
    CreationStageManager stageManager = new CreationStageManager(graph);
    EdgesHistoryManager historyManager = new EdgesHistoryManager(graph);
    Set<Node> initialNodes = SetSequence.fromSet(new LinkedHashSet<Node>());
    SetSequence.fromSet(initialNodes).addSequence(ListSequence.fromList(graph.getNodes()));
    myRealNodes = SetSequence.fromSet(new HashSet<Node>());
    SetSequence.fromSet(myRealNodes).addSequence(ListSequence.fromList(graph.getNodes()));
    Set<Edge> initialEdges = SetSequence.fromSet(new LinkedHashSet<Edge>());
    SetSequence.fromSet(initialEdges).addSequence(ListSequence.fromList(graph.getEdges()));
    Set<Edge> loops = SetSequence.fromSet(new LinkedHashSet<Edge>());
    this.removeLoops(graph, loops);
    // embedded graph must be biconnected to be properly processed by quasi-ortogonal representation creator 
    BiconnectAugmentation.smartMakeBiconnected(graph);
    stageManager.nextStage();
    EmbeddedGraph embeddedGraph = getEmbedding(graph);
    addLoops(loops, embeddedGraph);
    // this causes an error: biconnect augmentation can add edges to edge crossing points, so this point 
    // will have >4 edges and will be wrongly processed by quasi-orthogonal representation creator 
    /*
      Set<Edge> newEdges = BiconnectAugmentation.smartMakeBiconnected(graph);
      for (Edge edge : SetSequence.fromSet(newEdges)) {
        graph.removeEdge(edge);
      }
      for (Edge edge : SetSequence.fromSet(newEdges)) {
        ShortestPathEmbeddingFinder.restoreEdge(embeddedGraph, edge, false);
      }
    */
    myRealEdges = SetSequence.fromSet(new HashSet<Edge>());
    Map<Edge, List<Edge>> history = MapSequence.fromMap(new HashMap<Edge, List<Edge>>());
    for (Edge edge : SetSequence.fromSet(initialEdges)) {
      List<Edge> historyEdges = historyManager.getHistory(edge);
      MapSequence.fromMap(history).put(edge, historyEdges);
      SetSequence.fromSet(myRealEdges).addSequence(ListSequence.fromList(historyEdges));
    }
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      MapSequence.fromMap(history).put(edge, historyManager.getHistory(edge));
    }
    Map<Edge, Edge> labeledEdges = MapSequence.fromMap(new HashMap<Edge, Edge>());
    LayoutInfo newInfo = new LayoutInfo(graph);
    for (Node node : SetSequence.fromSet(layoutInfo.getNodesWithSize())) {
      Dimension size = layoutInfo.getNodeSize(node);
      if (size != null) {
        newInfo.setNodeSize(node, size);
      }
    }
    for (Edge edge : SetSequence.fromSet(layoutInfo.getLabeledEdges())) {
      Edge labeledEdge = getLabeledEdge(MapSequence.fromMap(history).get(edge));
      MapSequence.fromMap(labeledEdges).put(edge, labeledEdge);
      newInfo.setLabelSize(labeledEdge, layoutInfo.getLabelSize(edge));
    }
    GraphLayout layout = getLayoutFromEmbeddedGraph(embeddedGraph, newInfo);
    GraphLayout initialLayout = this.refineLayout(graph, initialNodes, layout, initialEdges, history, labeledEdges);
    return initialLayout;
  }

  protected GraphLayout getSingleNodeLayout(Graph graph, LayoutInfo layoutInfo) {
    GraphLayout layout = new GraphLayout(graph);
    Node node = ListSequence.fromList(graph.getNodes()).first();
    Dimension size = layoutInfo.getNodeSize(node);
    Rectangle rect = new Rectangle(0, 0, size.width, size.height);
    layout.setLayoutFor(node, rect);
    return layout;
  }

  private void removeLoops(Graph graph, Set<Edge> loops) {
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      if (edge.getSource() == edge.getTarget()) {
        SetSequence.fromSet(loops).addElement(edge);
        graph.removeEdge(edge);
      }
    }
  }

  protected GraphLayout refineLayout(Graph graph, Set<Node> initialNodes, GraphLayout layout, Set<Edge> initialEdges, Map<Edge, List<Edge>> history, Map<Edge, Edge> labeledEdges) {
    GraphLayout initialLayout = GraphLayoutFactory.createGraphLayout(graph);
    for (Node node : SetSequence.fromSet(initialNodes)) {
      initialLayout.setLayoutFor(node, layout.getNodeLayout(node));
    }
    for (Edge edge : SetSequence.fromSet(initialEdges)) {
      List<Point> edgeLayout = ListSequence.fromList(new ArrayList<Point>());
      Node cur = edge.getSource();
      for (Edge historyEdge : ListSequence.fromList(MapSequence.fromMap(history).get(edge))) {
        List<Point> historyLayout = layout.getEdgeLayout(historyEdge);
        if (historyEdge.getSource() != cur) {
          historyLayout = ListSequence.fromList(historyLayout).reversedList();
        }
        ListSequence.fromList(edgeLayout).addSequence(ListSequence.fromList(historyLayout));
        cur = historyEdge.getOpposite(cur);
      }
      initialLayout.setLayoutFor(edge, edgeLayout);
    }
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(labeledEdges).keySet())) {
      initialLayout.setLabelLayout(edge, layout.getLabelLayout(MapSequence.fromMap(labeledEdges).get(edge)));
    }
    return initialLayout;
  }

  private void addLoops(Set<Edge> loops, EmbeddedGraph embeddedGraph) {
    Map<Node, Face> facesMap = MapSequence.fromMap(new HashMap<Node, Face>());
    for (Edge edge : SetSequence.fromSet(loops)) {
      Node node = edge.getSource();
      Face face = MapSequence.fromMap(facesMap).get(node);
      if (face == null) {
        Face outerFace = embeddedGraph.getOuterFace();
        if (outerFace.contains(ListSequence.fromListAndArray(new ArrayList<Node>(), node))) {
          face = outerFace;
        } else {
          Edge nodeEdge = ListSequence.fromList(node.getEdges()).first();
          face = ListSequence.fromList(embeddedGraph.getAdjacentFaces(nodeEdge)).first();
        }
      }
      List<Edge> newEdges = embeddedGraph.getGraph().splitEdge(edge);
      Face newFace = embeddedGraph.makeLoop(face, newEdges, node);
      MapSequence.fromMap(facesMap).put(node, newFace);
    }
  }

  protected EmbeddedGraph getEmbedding(Graph graph) {
    IEmbeddingFinder embeddingFinder = EmbeddingFinderFactory.getFinderForGraph(graph);
    return embeddingFinder.find(graph);
  }

  public abstract Edge getLabeledEdge(List<Edge> edges);

  public abstract GraphLayout getLayoutFromEmbeddedGraph(EmbeddedGraph embeddedGraph, LayoutInfo layoutInfo);

  protected Map<Node, Map<Direction2D, Integer>> getNodeDirectionSizes(List<Node> oldNodes, Map<Node, Dimension> nodeSizes) {
    Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes = MapSequence.fromMap(new HashMap<Node, Map<Direction2D, Integer>>());
    for (Node node : ListSequence.fromList(oldNodes)) {
      Map<Direction2D, Integer> directionSizes = MapSequence.fromMap(new HashMap<Direction2D, Integer>());
      Dimension size = MapSequence.fromMap(nodeSizes).get(node);
      int horSize = size.height;
      MapSequence.fromMap(directionSizes).put(Direction2D.UP, horSize / 2);
      MapSequence.fromMap(directionSizes).put(Direction2D.DOWN, horSize - MapSequence.fromMap(directionSizes).get(Direction2D.UP));
      int verSize = size.width;
      MapSequence.fromMap(directionSizes).put(Direction2D.LEFT, verSize / 2);
      MapSequence.fromMap(directionSizes).put(Direction2D.RIGHT, verSize - MapSequence.fromMap(directionSizes).get(Direction2D.LEFT));
      MapSequence.fromMap(nodeDirectionSizes).put(node, directionSizes);
    }
    return nodeDirectionSizes;
  }

  protected Map<Edge, Integer> getEdgesShifts(List<QuasiRepresentationModifier.Modification> modifications, Map<Dart, Direction2D> directions, Map<Node, Dimension> nodeSizes) {
    Map<Edge, Integer> edgeShifts = MapSequence.fromMap(new HashMap<Edge, Integer>());
    for (QuasiRepresentationModifier.Modification modification : ListSequence.fromList(modifications)) {
      List<Edge> edges = modification.getNewEdges();
      Node node = modification.getSource();
      Direction2D dir = MapSequence.fromMap(directions).get(modification.getSourceDart());
      int nodeLength;
      if (dir.isVertical()) {
        nodeLength = MapSequence.fromMap(nodeSizes).get(node).width / 2;
      } else {
        nodeLength = MapSequence.fromMap(nodeSizes).get(node).height / 2;
      }
      /*
        nodeLength = Math.min(nodeLength, getUnitLength());
      */
      int unitShift = nodeLength / ListSequence.fromList(edges).count();
      int curShift = 0;
      for (Edge edge : ListSequence.fromList(edges)) {
        MapSequence.fromMap(edgeShifts).put(edge, curShift);
        curShift += unitShift;
      }
    }
    return edgeShifts;
  }

  protected void splitEdges(GraphLayout layout, QuasiRepresentationModifier.Modification modification, Map<Edge, Integer> edgeShifts) {
    List<Edge> edges = modification.getModifiedEdges();
    Edge firstEdge = ListSequence.fromList(edges).first();
    List<Point> path = layout.getEdgeLayout(firstEdge);
    Node node = modification.getSource();
    Direction2D dartsDir;
    if (firstEdge.getSource() == node) {
      dartsDir = OrthogonalUtil.getDirection(ListSequence.fromList(path).getElement(0), ListSequence.fromList(path).getElement(1));
    } else {
      int last = ListSequence.fromList(path).count() - 1;
      dartsDir = OrthogonalUtil.getDirection(ListSequence.fromList(path).getElement(last), ListSequence.fromList(path).getElement(last - 1));
    }
    Direction2D shiftDir = dartsDir.turnClockwise(3);
    int dx = shiftDir.dx();
    int dy = shiftDir.dy();
    Iterator<Edge> newEdgeItr = ListSequence.fromList(modification.getNewEdges()).iterator();
    for (Edge edge : ListSequence.fromList(edges)) {
      layout.removeStraightBends(edge);
      List<Point> edgeLayout = layout.getEdgeLayout(edge);
      List<Point> pointsToShift;
      if (edge.getSource() == node) {
        pointsToShift = ListSequence.fromListAndArray(new ArrayList<Point>(), ListSequence.fromList(edgeLayout).getElement(0), ListSequence.fromList(edgeLayout).getElement(1));
      } else {
        int last = ListSequence.fromList(edgeLayout).count() - 1;
        pointsToShift = ListSequence.fromListAndArray(new ArrayList<Point>(), ListSequence.fromList(edgeLayout).getElement(last), ListSequence.fromList(edgeLayout).getElement(last - 1));
      }
      Edge newEdge = newEdgeItr.next();
      for (Point point : ListSequence.fromList(pointsToShift)) {
        point.translate(dx * MapSequence.fromMap(edgeShifts).get(newEdge), dy * MapSequence.fromMap(edgeShifts).get(newEdge));
      }
    }
  }

  public boolean getAvoidLabelCrossings() {
    return myAvoidLabelCrossings;
  }

  public void setAvoidLabelCrossings(boolean avoidLabelCrossings) {
    myAvoidLabelCrossings = avoidLabelCrossings;
  }

  public boolean getUseRepresentationOptimizations() {
    return myUseRepresentationOptimizations;
  }

  public void setUseRepresentationOptimizations(boolean useRepresentationOptimizations) {
    myUseRepresentationOptimizations = useRepresentationOptimizations;
  }
}
