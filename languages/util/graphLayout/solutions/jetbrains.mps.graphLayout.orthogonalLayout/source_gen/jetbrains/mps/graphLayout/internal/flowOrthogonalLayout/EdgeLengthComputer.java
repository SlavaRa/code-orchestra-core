package jetbrains.mps.graphLayout.internal.flowOrthogonalLayout;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.graphLayout.intGeom2D.Direction2D;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.planarGraph.Face;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.graphLayout.algorithms.MinCostCirculation;

public class EdgeLengthComputer {
  private static int SHOW_INFO = 0;
  private static int UNIT_LENGTH = 3;

  private int myUnitLength;

  public EdgeLengthComputer() {
    myUnitLength = EdgeLengthComputer.UNIT_LENGTH;
  }

  public void setUnitLength(int length) {
    myUnitLength = length;
  }

  public Map<Edge, Integer> compute(EmbeddedGraph embeddedGraph, Map<Dart, Direction2D> directions) {
    return compute(embeddedGraph, directions, MapSequence.fromMap(new HashMap<Edge, Integer>()));
  }

  public Map<Edge, Integer> compute(EmbeddedGraph embeddedGraph, Map<Dart, Direction2D> directions, Map<Edge, Integer> predefinedLengths) {
    Map<Edge, Integer> horEdgeLengths = computeEdgeLengths(embeddedGraph, directions, Direction2D.RIGHT, predefinedLengths);
    Map<Edge, Integer> verEdgeLenghts = computeEdgeLengths(embeddedGraph, directions, Direction2D.DOWN, predefinedLengths);
    Map<Edge, Integer> lengths = MapSequence.fromMap(new HashMap<Edge, Integer>());
    for (Edge edge : ListSequence.fromList(embeddedGraph.getGraph().getEdges())) {
      int length;
      if (MapSequence.fromMap(horEdgeLengths).containsKey(edge)) {
        length = MapSequence.fromMap(horEdgeLengths).get(edge);
      } else {
        length = MapSequence.fromMap(verEdgeLenghts).get(edge);
      }
      MapSequence.fromMap(lengths).put(edge, length);
    }
    if (EdgeLengthComputer.SHOW_INFO > 0) {
      for (Edge edge : ListSequence.fromList(embeddedGraph.getGraph().getEdges())) {
        System.out.println("edge: " + edge + " length = " + MapSequence.fromMap(lengths).get(edge));
      }
    }
    return lengths;
  }

  private Map<Edge, Integer> computeEdgeLengths(EmbeddedGraph embeddedGraph, final Map<Dart, Direction2D> directions, final Direction2D direction, Map<Edge, Integer> predefinedLengths) {
    Graph graph = embeddedGraph.getGraph();
    Graph network = new Graph();
    Map<Edge, Edge> edgeMap = MapSequence.fromMap(new HashMap<Edge, Edge>());
    Map<Face, Node> faceMap = MapSequence.fromMap(new HashMap<Face, Node>());
    Node source = network.createNode();
    Node target = network.createNode();
    for (Face face : ListSequence.fromList(embeddedGraph.getFaces())) {
      if (!(embeddedGraph.isOuterFace(face))) {
        MapSequence.fromMap(faceMap).put(face, network.createDummyNode());
      }
    }
    Map<Edge, Integer> low = MapSequence.fromMap(new HashMap<Edge, Integer>());
    Map<Edge, Integer> capacity = MapSequence.fromMap(new HashMap<Edge, Integer>());
    Map<Edge, Integer> cost = MapSequence.fromMap(new HashMap<Edge, Integer>());
    Edge backEdge = network.connect(target, source);
    MapSequence.fromMap(low).put(backEdge, 0);
    MapSequence.fromMap(capacity).put(backEdge, Integer.MAX_VALUE / 2);
    MapSequence.fromMap(cost).put(backEdge, 0);
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      Dart dart = ListSequence.fromList(embeddedGraph.getDarts(edge)).findFirst(new IWhereFilter<Dart>() {
        public boolean accept(Dart dart) {
          return MapSequence.fromMap(directions).get(dart) == direction;
        }
      });
      if (dart != null) {
        Face targetFace = embeddedGraph.getFace(dart);
        Face sourceFace = embeddedGraph.getFace(embeddedGraph.getOpposite(dart));
        Node sourceNode;
        Node targetNode;
        if (embeddedGraph.isOuterFace(sourceFace)) {
          sourceNode = source;
        } else {
          sourceNode = MapSequence.fromMap(faceMap).get(sourceFace);
        }
        if (embeddedGraph.isOuterFace(targetFace)) {
          targetNode = target;
        } else {
          targetNode = MapSequence.fromMap(faceMap).get(targetFace);
        }
        Edge newEdge = network.connect(sourceNode, targetNode);
        MapSequence.fromMap(edgeMap).put(edge, newEdge);
        if (MapSequence.fromMap(predefinedLengths).containsKey(edge)) {
          MapSequence.fromMap(low).put(newEdge, MapSequence.fromMap(predefinedLengths).get(edge));
        } else {
          MapSequence.fromMap(low).put(newEdge, myUnitLength);
        }
        MapSequence.fromMap(capacity).put(newEdge, Integer.MAX_VALUE / 2);
        MapSequence.fromMap(cost).put(newEdge, 1);
      }
    }
    Map<Edge, Integer> circulation = MinCostCirculation.getCirculation(network, low, capacity, cost);
    Map<Edge, Integer> edgeLength = MapSequence.fromMap(new HashMap<Edge, Integer>());
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      if (MapSequence.fromMap(edgeMap).containsKey(edge)) {
        MapSequence.fromMap(edgeLength).put(edge, MapSequence.fromMap(circulation).get(MapSequence.fromMap(edgeMap).get(edge)));
      }
    }
    return edgeLength;
  }
}
