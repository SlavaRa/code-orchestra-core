package jetbrains.mps.graphLayout.flowOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graphLayout.GraphLayout;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.graphLayout.LayoutInfo;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.intGeom2D.Dimension;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.graph.EdgesHistoryManager;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.graphLayout.planarGraph.Face;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.graphLayout.intGeom2D.Direction2D;
import jetbrains.mps.graphLayout.intGeom2D.Point;
import jetbrains.mps.graphLayout.intGeom2D.Rectangle;
import jetbrains.mps.graphLayout.intGeom2D.Util1D;
import jetbrains.mps.graphLayout.graphLayout.GraphLayoutFactory;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;

public class OrthogonalFlowLayouter extends AbstractOrthogonalFlowLayouter {
  private static int LABEL_DIST = 10;

  public OrthogonalFlowLayouter() {
  }

  public GraphLayout getLayoutFromEmbeddedGraph(EmbeddedGraph embeddedGraph, LayoutInfo layoutInfo) {
    if (SHOW_INFO > 0) {
      System.out.println("initial graph: " + embeddedGraph);
    }
    Map<Node, Dimension> nodeSizes = MapSequence.fromMap(new LinkedHashMap<Node, Dimension>(16, (float) 0.75, false));
    for (Node node : SetSequence.fromSet(layoutInfo.getNodesWithSize())) {
      MapSequence.fromMap(nodeSizes).put(node, layoutInfo.getNodeSize(node));
    }
    Map<Edge, Dimension> edgeSizes = MapSequence.fromMap(new LinkedHashMap<Edge, Dimension>(16, (float) 0.75, false));
    for (Edge edge : SetSequence.fromSet(layoutInfo.getLabeledEdges())) {
      MapSequence.fromMap(edgeSizes).put(edge, layoutInfo.getLabelSize(edge));
    }
    Graph graph = embeddedGraph.getGraph();
    EdgesHistoryManager historyManager = new EdgesHistoryManager(graph);
    List<Edge> initialEdges = ListSequence.fromList(new ArrayList<Edge>());
    ListSequence.fromList(initialEdges).addSequence(ListSequence.fromList(graph.getEdges()));
    List<Node> initialNodes = ListSequence.fromList(new ArrayList<Node>());
    ListSequence.fromList(initialNodes).addSequence(SetSequence.fromSet(MapSequence.fromMap(nodeSizes).keySet()));
    Map<Dart, Integer> bends = MapSequence.fromMap(new HashMap<Dart, Integer>());
    Map<Dart, Integer> angles = MapSequence.fromMap(new HashMap<Dart, Integer>());
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      if (ListSequence.fromList(embeddedGraph.getDarts(edge)).count() != 2) {

        throw new RuntimeException("botva!!!");
      }
    }
    QuasiOrthogonalRepresentation orthogonalRepresentation = new QuasiOrthogonalRepresentation();
    if (getUseRepresentationOptimizations()) {
      orthogonalRepresentation.setRealEdges(myRealEdges);
      orthogonalRepresentation.setRealNodes(myRealNodes);
      orthogonalRepresentation.setStraightEdges(myStraightEdges);
    }
    Tuples._2<Map<Dart, Integer>, Map<Dart, Integer>> pair = orthogonalRepresentation.getRepresentation(embeddedGraph);
    bends = pair._0();
    angles = pair._1();
    /*
      for (Face face : ListSequence.fromList(embeddedGraph.getFaces())) {
        System.out.println("face:");
        for (Dart dart : ListSequence.fromList(face.getDarts())) {
          System.out.println(dart + " b = " + MapSequence.fromMap(bends).get(dart));
        }
        for (Node node : ListSequence.fromList(graph.getNodes())) {
          for (Dart dart : ListSequence.fromList(embeddedGraph.getDartWithSource(node))) {
            System.out.println(dart + " = " + MapSequence.fromMap(angles).get(dart));
          }
        }
      }
    */
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      for (Dart dart : ListSequence.fromList(embeddedGraph.getDarts(edge))) {
        /*
          if (MapSequence.fromMap(bends).get(dart) < 0 || MapSequence.fromMap(bends).get(dart) > 4) {
            throw new RuntimeException("botva!!!");
          }
        */
        if (MapSequence.fromMap(angles).get(dart) < 0 || MapSequence.fromMap(angles).get(dart) > 3) {
          throw new RuntimeException("botva!!!");
        }
      }
    }

    QuasiRepresentationModifier quasiModifier = new QuasiRepresentationModifier(embeddedGraph, bends, angles);
    quasiModifier.reduceToOrthogonalRepresentation();
    List<QuasiRepresentationModifier.Modification> modifications = quasiModifier.getModifications();
    Set<Edge> modifiedEdges = SetSequence.fromSet(new HashSet<Edge>());
    Set<Edge> newEdges = SetSequence.fromSet(new HashSet<Edge>());
    for (QuasiRepresentationModifier.Modification modification : ListSequence.fromList(modifications)) {
      SetSequence.fromSet(modifiedEdges).addSequence(ListSequence.fromList(modification.getModifiedEdges()));
      SetSequence.fromSet(newEdges).addSequence(ListSequence.fromList(modification.getNewEdges()));
    }
    Map<Edge, Edge> labeledEdges = MapSequence.fromMap(new HashMap<Edge, Edge>());
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeSizes).keySet())) {
      List<Edge> history = historyManager.getHistory(edge);
      if (SetSequence.fromSet(modifiedEdges).contains(edge)) {
        for (Edge historyEdge : ListSequence.fromList(history)) {
          if (SetSequence.fromSet(newEdges).contains(historyEdge)) {
            MapSequence.fromMap(labeledEdges).put(edge, historyEdge);
          }
        }
      } else {
        MapSequence.fromMap(labeledEdges).put(edge, edge);
      }
    }
    if (SHOW_INFO > 0) {
      System.out.println("modifications: ");
      for (QuasiRepresentationModifier.Modification modification : ListSequence.fromList(modifications)) {
        System.out.println(modification);
      }
    }
    OrthogonalRepresentation.replaceBendsByNodes(embeddedGraph, bends, angles);
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeSizes).keySet())) {
      Edge labeledEdge = getLabeledEdge(historyManager.getHistory(MapSequence.fromMap(labeledEdges).get(edge)));
      MapSequence.fromMap(labeledEdges).put(edge, labeledEdge);
    }
    Map<Dart, Direction2D> directions = OrthogonalRepresentation.getDirections(embeddedGraph, angles);
    if (SHOW_INFO > 0) {
      System.out.println("modified graph: " + embeddedGraph);
    }

    Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes = this.getNodeDirectionSizes(initialNodes, nodeSizes);
    Map<Edge, Integer> edgeShifts = getEdgesShifts(modifications, directions, nodeSizes);

    NodeBoxesMaker boxesMaker = new NodeBoxesMaker(embeddedGraph, directions);
    boxesMaker.makeBoxes(nodeSizes);
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeSizes).keySet())) {
      Edge labeledEdge = MapSequence.fromMap(labeledEdges).get(edge);
      List<Edge> history = historyManager.getHistory(labeledEdge);
      int pos = 0;
      if (ListSequence.fromList(initialNodes).contains(labeledEdge.getSource())) {
        pos = 1;
      }
      MapSequence.fromMap(labeledEdges).put(edge, ListSequence.fromList(history).getElement(pos));
    }
    Map<Edge, Direction2D> labelDir = MapSequence.fromMap(new HashMap<Edge, Direction2D>());
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeSizes).keySet())) {
      Edge labeledEdge = MapSequence.fromMap(labeledEdges).get(edge);
      if (MapSequence.fromMap(directions).get(ListSequence.fromList(embeddedGraph.getDarts(labeledEdge)).first()).isHorizontal()) {
        MapSequence.fromMap(labelDir).put(edge, Direction2D.UP);
      } else {
        MapSequence.fromMap(labelDir).put(edge, Direction2D.RIGHT);
      }
    }
    Map<Edge, Node> labelCenters = MapSequence.fromMap(new HashMap<Edge, Node>());
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeSizes).keySet())) {
      MapSequence.fromMap(labelCenters).put(edge, splitEdge(MapSequence.fromMap(labeledEdges).get(edge), embeddedGraph, directions));
    }
    Set<Face> boxFaces = boxesMaker.getBoxFaces();
    Map<Edge, Integer> edgeLengths = boxesMaker.getBoxEdgeLengths();
    for (Node node : ListSequence.fromList(initialNodes)) {
      for (Edge edge : ListSequence.fromList(node.getEdges())) {
        Dart dart = embeddedGraph.getSourceDart(edge, node);
        MapSequence.fromMap(edgeLengths).put(edge, MapSequence.fromMap(MapSequence.fromMap(nodeDirectionSizes).get(node)).get(MapSequence.fromMap(directions).get(dart)));
      }
    }
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeSizes).keySet())) {
      Dimension size = MapSequence.fromMap(edgeSizes).get(edge);
      int length;
      if (MapSequence.fromMap(labelDir).get(edge).isHorizontal()) {
        length = size.height;
      } else {
        length = size.width;
      }
      for (Edge nodeEdge : ListSequence.fromList(MapSequence.fromMap(labelCenters).get(edge).getEdges())) {
        MapSequence.fromMap(edgeLengths).put(nodeEdge, length / 2 + getUnitLength());
      }
    }
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeShifts).keySet())) {
      Edge firstEdge = ListSequence.fromList(historyManager.getHistory(edge)).first();
      if (MapSequence.fromMap(edgeLengths).containsKey(firstEdge)) {
        MapSequence.fromMap(edgeLengths).put(firstEdge, MapSequence.fromMap(edgeLengths).get(firstEdge) + MapSequence.fromMap(edgeShifts).get(edge));
      } else {
        MapSequence.fromMap(edgeLengths).put(firstEdge, MapSequence.fromMap(edgeShifts).get(edge) + 2 * getUnitLength());
      }
    }
    ConstraintsGraph constraintsGraph = new ConstraintsGraph(embeddedGraph, directions);
    constraintsGraph.constructGraph(boxFaces);
    constraintsGraph.setUnitLength(getUnitLength());
    Map<Node, Point> coordinates = constraintsGraph.getCoordinates(edgeLengths, null);

    Map<Edge, Rectangle> labelRects = MapSequence.fromMap(new HashMap<Edge, Rectangle>());
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeSizes).keySet())) {
      MapSequence.fromMap(labelRects).put(edge, getLabelLayout(labelCenters, edge, coordinates, embeddedGraph, edgeSizes, directions));
    }
    Map<Edge, Integer> constraintEdgeLengths = MapSequence.fromMap(new HashMap<Edge, Integer>());
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(labelRects).keySet())) {
      Node center = MapSequence.fromMap(labelCenters).get(edge);
      boolean isHorizontal = MapSequence.fromMap(labelDir).get(edge).isVertical();
      Rectangle labelRect = MapSequence.fromMap(labelRects).get(edge);
      Rectangle rect;
      int width = labelRect.width + getUnitLength();
      int height = labelRect.height + getUnitLength();
      if (isHorizontal) {
        rect = new Rectangle(labelRect.x - getUnitLength() / 2, labelRect.y, width, height);
      } else {
        rect = new Rectangle(labelRect.x, labelRect.y - getUnitLength() / 2, width, height);
      }
      for (Node node : ListSequence.fromList(graph.getNodes())) {
        if (node == center) {
          continue;
        }
        Point point = MapSequence.fromMap(coordinates).get(node);
        if (rect.contains(point)) {
          if (isHorizontal) {
            Edge constraintEdge = constraintsGraph.addConstraintEdge(center, node, Direction2D.UP);
            MapSequence.fromMap(constraintEdgeLengths).put(constraintEdge, rect.height);

          } else {
            Edge constraintEdge = constraintsGraph.addConstraintEdge(center, node, Direction2D.RIGHT);
            MapSequence.fromMap(constraintEdgeLengths).put(constraintEdge, rect.width);

          }
        }
      }
      if (getAvoidLabelCrossings()) {
        for (Edge graphEdge : ListSequence.fromList(graph.getEdges())) {
          if (ListSequence.fromList(center.getEdges()).contains(graphEdge)) {
            continue;
          }
          if (MapSequence.fromMap(directions).get(ListSequence.fromList(embeddedGraph.getDarts(graphEdge)).first()).isHorizontal() != isHorizontal) {
            continue;
          }
          Point sourcePoint = MapSequence.fromMap(coordinates).get(graphEdge.getSource());
          Point targetPoint = MapSequence.fromMap(coordinates).get(graphEdge.getTarget());
          if (isHorizontal) {
            boolean isIntersecting = Util1D.insideClosedSegment(sourcePoint.x, targetPoint.x, rect.x) && Util1D.insideClosedSegment(sourcePoint.x, targetPoint.x, rect.x + rect.width);
            int dist = rect.y + rect.height - sourcePoint.y;
            if (isIntersecting && dist < rect.height) {
              Edge constraintEdge = constraintsGraph.addConstraintEdge(center, graphEdge.getSource(), Direction2D.UP);
              MapSequence.fromMap(constraintEdgeLengths).put(constraintEdge, rect.height);

            }
          } else {
            boolean isIntersecting = Util1D.insideClosedSegment(sourcePoint.y, targetPoint.y, rect.y) && Util1D.insideClosedSegment(sourcePoint.y, targetPoint.y, rect.y + rect.height);
            int dist = rect.x + rect.width - sourcePoint.x;
            if (isIntersecting && dist < rect.width) {
              Edge constraintEdge = constraintsGraph.addConstraintEdge(center, graphEdge.getSource(), Direction2D.RIGHT);
              MapSequence.fromMap(constraintEdgeLengths).put(constraintEdge, rect.width);
            }
          }
        }
      }
    }

    coordinates = constraintsGraph.getCoordinates(edgeLengths, constraintEdgeLengths);
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeSizes).keySet())) {
      MapSequence.fromMap(labelRects).put(edge, getLabelLayout(labelCenters, edge, coordinates, embeddedGraph, edgeSizes, directions));
    }
    List<Edge> edgeList = ListSequence.fromList(new ArrayList<Edge>());
    ListSequence.fromList(edgeList).addSequence(SetSequence.fromSet(MapSequence.fromMap(labelRects).keySet()));
    for (int i = 0; i < ListSequence.fromList(edgeList).count(); i++) {
      Edge edgeI = ListSequence.fromList(edgeList).getElement(i);
      Direction2D dirI = MapSequence.fromMap(labelDir).get(edgeI);
      Rectangle rectI = MapSequence.fromMap(labelRects).get(edgeI);
      for (int j = i + 1; j < ListSequence.fromList(edgeList).count(); j++) {
        Edge edgeJ = ListSequence.fromList(edgeList).getElement(j);
        Direction2D dirJ = MapSequence.fromMap(labelDir).get(edgeJ);
        Rectangle rectJ = MapSequence.fromMap(labelRects).get(edgeJ);
        if (rectI.intersects(rectJ)) {
          int shiftByDirI = rectJ.size(dirI) + rectI.size(dirI);
          int shiftByDirJ = rectJ.size(dirJ) + rectI.size(dirJ);
          if (shiftByDirJ < shiftByDirI) {
            Edge constraintEdge = constraintsGraph.addConstraintEdge(MapSequence.fromMap(labelCenters).get(edgeJ), MapSequence.fromMap(labelCenters).get(edgeI), dirJ);
            MapSequence.fromMap(constraintEdgeLengths).put(constraintEdge, shiftByDirJ - rectI.size(dirJ) / 2 + LABEL_DIST);
          } else {
            Edge constraintEdge = constraintsGraph.addConstraintEdge(MapSequence.fromMap(labelCenters).get(edgeI), MapSequence.fromMap(labelCenters).get(edgeJ), dirI);
            MapSequence.fromMap(constraintEdgeLengths).put(constraintEdge, shiftByDirI - rectJ.size(dirI) / 2 + LABEL_DIST);
          }
        }
      }
    }
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      Point sourcePoint = MapSequence.fromMap(coordinates).get(edge.getSource());
      Point targetPoint = MapSequence.fromMap(coordinates).get(edge.getTarget());
      MapSequence.fromMap(edgeLengths).put(edge, Math.abs(sourcePoint.x - targetPoint.x) + Math.abs(sourcePoint.y - targetPoint.y));
    }
    coordinates = constraintsGraph.getCoordinates(edgeLengths, constraintEdgeLengths);

    GraphLayout graphLayout = GraphLayoutFactory.createGraphLayout(graph);
    for (Node node : ListSequence.fromList(initialNodes)) {
      Rectangle rect = this.getNodeLayout(coordinates, node, nodeDirectionSizes, nodeSizes);
      graphLayout.setLayoutFor(node, rect);
    }
    for (Edge edge : ListSequence.fromList(initialEdges)) {
      List<Point> edgeLayout = this.getEdgeLayout(edge, embeddedGraph, historyManager, coordinates, initialNodes, directions, nodeDirectionSizes);
      graphLayout.setLayoutFor(edge, edgeLayout);
    }
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeSizes).keySet())) {
      Rectangle rect = this.getLabelLayout(labelCenters, edge, coordinates, embeddedGraph, edgeSizes, directions);
      graphLayout.setLabelLayout(edge, rect);
    }
    for (QuasiRepresentationModifier.Modification modification : ListSequence.fromList(modifications)) {
      splitEdges(graphLayout, modification, edgeShifts);
    }
    return graphLayout;
  }

  private Rectangle getLabelLayout(Map<Edge, Node> labelCenters, Edge edge, Map<Node, Point> coordinates, EmbeddedGraph embeddedGraph, Map<Edge, Dimension> edgeSizes, Map<Dart, Direction2D> directions) {
    Node node = MapSequence.fromMap(labelCenters).get(edge);
    Point center = MapSequence.fromMap(coordinates).get(node);
    Dart dart = ListSequence.fromList(embeddedGraph.getDarts(ListSequence.fromList(node.getEdges()).first())).first();
    Rectangle rect;
    Dimension size = MapSequence.fromMap(edgeSizes).get(edge);
    if (MapSequence.fromMap(directions).get(dart).isHorizontal()) {
      rect = new Rectangle(center.x - size.width / 2, center.y, size.width, size.height);
    } else {
      rect = new Rectangle(center.x, center.y - size.height / 2, size.width, size.height);
    }
    return rect;
  }

  private List<Point> getEdgeLayout(Edge edge, EmbeddedGraph embeddedGraph, EdgesHistoryManager manager, Map<Node, Point> coordinates, List<Node> initialNodes, Map<Dart, Direction2D> directions, Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes) {
    Node source = edge.getSource();
    Node target = edge.getTarget();
    List<Edge> history = manager.getHistory(edge);
    List<Point> edgeLayout = ListSequence.fromList(new LinkedList<Point>());
    Node cur = source;
    ListSequence.fromList(edgeLayout).addElement(new Point(MapSequence.fromMap(coordinates).get(cur)));
    for (Edge historyEdge : ListSequence.fromList(history)) {
      Node next = historyEdge.getOpposite(cur);
      ListSequence.fromList(edgeLayout).addElement(new Point(MapSequence.fromMap(coordinates).get(next)));
      cur = next;
    }
    if (ListSequence.fromList(initialNodes).contains(source)) {
      Direction2D dir = MapSequence.fromMap(directions).get(embeddedGraph.getSourceDart(ListSequence.fromList(history).first(), source));
      int size = MapSequence.fromMap(MapSequence.fromMap(nodeDirectionSizes).get(source)).get(dir);
      Point first = ListSequence.fromList(edgeLayout).removeElementAt(0);
      first.translate(size * dir.dx(), size * dir.dy());
      ListSequence.fromList(edgeLayout).removeElementAt(0);
      ListSequence.fromList(edgeLayout).insertElement(0, first);
    }
    if (ListSequence.fromList(initialNodes).contains(edge.getTarget())) {
      Direction2D dir = MapSequence.fromMap(directions).get(embeddedGraph.getSourceDart(ListSequence.fromList(history).last(), target));
      int size = MapSequence.fromMap(MapSequence.fromMap(nodeDirectionSizes).get(target)).get(dir);
      Point last = ListSequence.fromList(edgeLayout).removeLastElement();
      last.translate(size * dir.dx(), size * dir.dy());
      ListSequence.fromList(edgeLayout).removeLastElement();
      ListSequence.fromList(edgeLayout).addElement(last);
    }
    return edgeLayout;
  }

  private Rectangle getNodeLayout(Map<Node, Point> coordinates, Node node, Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes, Map<Node, Dimension> nodeSizes) {
    Point center = MapSequence.fromMap(coordinates).get(node);
    Map<Direction2D, Integer> sizes = MapSequence.fromMap(nodeDirectionSizes).get(node);
    Dimension nodeSize = MapSequence.fromMap(nodeSizes).get(node);
    return new Rectangle(center.x - MapSequence.fromMap(sizes).get(Direction2D.LEFT), center.y - MapSequence.fromMap(sizes).get(Direction2D.DOWN), nodeSize.width, nodeSize.height);
  }

  public Edge getLabeledEdge(List<Edge> edges) {
    return ListSequence.fromList(edges).first();
  }

  private Node splitEdge(Edge oldEdge, EmbeddedGraph embeddedGraph, Map<Dart, Direction2D> directions) {
    Node source = oldEdge.getSource();
    Node target = oldEdge.getTarget();
    Dart sourceDart = embeddedGraph.getSourceDart(oldEdge, source);
    Dart targetDart = embeddedGraph.getSourceDart(oldEdge, target);
    List<Edge> edges = ListSequence.fromList(new ArrayList<Edge>());
    Node node = embeddedGraph.splitEdge(oldEdge, edges);
    for (Edge edge : ListSequence.fromList(edges)) {
      for (Dart dart : ListSequence.fromList(embeddedGraph.getDarts(edge))) {
        if (dart.getSource() == source || dart.getTarget() == target) {
          MapSequence.fromMap(directions).put(dart, MapSequence.fromMap(directions).get(sourceDart));
        } else {
          MapSequence.fromMap(directions).put(dart, MapSequence.fromMap(directions).get(targetDart));
        }
      }
    }
    MapSequence.fromMap(directions).removeKey(sourceDart);
    MapSequence.fromMap(directions).removeKey(targetDart);
    return node;
  }
}
