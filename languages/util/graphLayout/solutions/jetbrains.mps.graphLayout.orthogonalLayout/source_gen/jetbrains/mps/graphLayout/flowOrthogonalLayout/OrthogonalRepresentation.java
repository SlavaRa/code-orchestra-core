package jetbrains.mps.graphLayout.flowOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import java.util.Set;
import jetbrains.mps.graphLayout.graph.Edge;
import java.util.Map;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.graphLayout.planarGraph.Face;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.graphLayout.algorithms.MinCostCirculation;
import java.util.HashSet;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.graphLayout.intGeom2D.Direction2D;
import jetbrains.mps.graphLayout.algorithms.Dfs;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class OrthogonalRepresentation {
  private static int SHOW_INFO = 0;

  public static void getRepresentation(EmbeddedGraph embeddedGraph, Set<Edge> edgesToBeStraight, Map<Dart, Integer> bends, Map<Dart, Integer> angles) {
    Graph graph = embeddedGraph.getGraph();
    Graph network = new Graph();
    Node center = network.createNode();
    Map<Edge, Integer> low = MapSequence.fromMap(new HashMap<Edge, Integer>());
    Map<Edge, Integer> capacity = MapSequence.fromMap(new HashMap<Edge, Integer>());
    Map<Edge, Integer> cost = MapSequence.fromMap(new HashMap<Edge, Integer>());
    Map<Node, Node> nodeMap = MapSequence.fromMap(new HashMap<Node, Node>());
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      Node networkNode = network.createNode();
      MapSequence.fromMap(nodeMap).put(node, networkNode);
      Edge edge = network.connect(center, networkNode);
      MapSequence.fromMap(low).put(edge, 4);
      MapSequence.fromMap(capacity).put(edge, MapSequence.fromMap(low).get(edge));
      MapSequence.fromMap(cost).put(edge, 0);
    }
    Map<Face, Node> faceMap = MapSequence.fromMap(new HashMap<Face, Node>());
    for (Face face : ListSequence.fromList(embeddedGraph.getFaces())) {
      Node node = network.createNode();
      MapSequence.fromMap(faceMap).put(face, node);
      Edge edge = network.connect(node, center);
      if (embeddedGraph.isOuterFace(face)) {
        MapSequence.fromMap(low).put(edge, 2 * ListSequence.fromList(face.getDarts()).count() + 4);
      } else {
        MapSequence.fromMap(low).put(edge, 2 * ListSequence.fromList(face.getDarts()).count() - 4);
      }
      MapSequence.fromMap(capacity).put(edge, MapSequence.fromMap(low).get(edge));
      MapSequence.fromMap(cost).put(edge, 0);
    }
    Map<Dart, Edge> dartBendMap = MapSequence.fromMap(new HashMap<Dart, Edge>());
    Map<Dart, Edge> dartAngleMap = MapSequence.fromMap(new HashMap<Dart, Edge>());
    for (Face face : ListSequence.fromList(embeddedGraph.getFaces())) {
      Node faceNode = MapSequence.fromMap(faceMap).get(face);
      for (Dart dart : ListSequence.fromList(face.getDarts())) {
        Edge edge = network.connect(MapSequence.fromMap(nodeMap).get(dart.getSource()), faceNode);
        MapSequence.fromMap(dartAngleMap).put(dart, edge);
        MapSequence.fromMap(low).put(edge, 1);
        MapSequence.fromMap(capacity).put(edge, 4);
        MapSequence.fromMap(cost).put(edge, 0);
        List<Face> faces = embeddedGraph.getAdjacentFaces(dart.getEdge());
        Node oppositeFaceNode;
        if (ListSequence.fromList(faces).getElement(0) == face) {
          oppositeFaceNode = MapSequence.fromMap(faceMap).get(ListSequence.fromList(faces).getElement(1));
        } else {
          oppositeFaceNode = MapSequence.fromMap(faceMap).get(ListSequence.fromList(faces).getElement(0));
        }
        edge = network.connect(faceNode, oppositeFaceNode);
        MapSequence.fromMap(dartBendMap).put(dart, edge);
        MapSequence.fromMap(low).put(edge, 0);
        if (SetSequence.fromSet(edgesToBeStraight).contains(dart.getEdge())) {
          MapSequence.fromMap(capacity).put(edge, 0);
        } else {
          MapSequence.fromMap(capacity).put(edge, Integer.MAX_VALUE / 2);
        }
        MapSequence.fromMap(cost).put(edge, 1);
      }
    }
    if (SHOW_INFO > 0) {
      System.out.println("Constructed network:");
      for (Node node : ListSequence.fromList(graph.getNodes())) {
        System.out.println("for node " + node + ": " + MapSequence.fromMap(nodeMap).get(node));
      }
      for (Face face : ListSequence.fromList(embeddedGraph.getFaces())) {
        System.out.println("for face " + face + ": " + MapSequence.fromMap(faceMap).get(face));
      }
      for (Edge edge : ListSequence.fromList(network.getEdges())) {
        System.out.println("edge " + edge + ": low = " + MapSequence.fromMap(low).get(edge) + ", cap = " + MapSequence.fromMap(capacity).get(edge) + ", cost = " + MapSequence.fromMap(cost).get(edge));
      }
    }
    Map<Edge, Integer> circulation = MinCostCirculation.getCirculation(network, low, capacity, cost);
    for (Dart dart : SetSequence.fromSet(MapSequence.fromMap(dartBendMap).keySet())) {
      MapSequence.fromMap(bends).put(dart, MapSequence.fromMap(circulation).get(MapSequence.fromMap(dartBendMap).get(dart)));
      MapSequence.fromMap(angles).put(dart, MapSequence.fromMap(circulation).get(MapSequence.fromMap(dartAngleMap).get(dart)));
    }
    if (SHOW_INFO > 0) {
      System.out.println("bends: " + bends);
      System.out.println("angles: " + angles);
    }
  }

  public static void getRepresentation(EmbeddedGraph embeddedGraph, Map<Dart, Integer> bends, Map<Dart, Integer> angles) {
    getRepresentation(embeddedGraph, SetSequence.fromSet(new HashSet<Edge>()), bends, angles);
  }

  public static void replaceBendsByNodes(EmbeddedGraph embeddedGraph, Map<Dart, Integer> bends, Map<Dart, Integer> angles) {
    for (Edge edge : ListSequence.fromList(embeddedGraph.getGraph().getEdges())) {
      List<Dart> darts = embeddedGraph.getDarts(edge);
      final Wrappers._T<Dart> dartToSplit = new Wrappers._T<Dart>(null);
      Dart opposite = null;
      if (MapSequence.fromMap(bends).get(ListSequence.fromList(darts).getElement(0)) > 0) {
        dartToSplit.value = ListSequence.fromList(darts).getElement(0);
        opposite = ListSequence.fromList(darts).getElement(1);
      }
      if (MapSequence.fromMap(bends).get(ListSequence.fromList(darts).getElement(1)) > 0) {
        dartToSplit.value = ListSequence.fromList(darts).getElement(1);
        opposite = ListSequence.fromList(darts).getElement(0);
      }
      if (dartToSplit.value != null) {
        while (MapSequence.fromMap(bends).get(dartToSplit.value) > 0) {
          List<Edge> newEdges = ListSequence.fromList(new ArrayList<Edge>());
          final Node addedNode = embeddedGraph.splitEdge(dartToSplit.value.getEdge(), newEdges);
          Edge first = ListSequence.fromList(newEdges).findFirst(new IWhereFilter<Edge>() {
            public boolean accept(Edge it) {
              return it.getOpposite(addedNode) == dartToSplit.value.getSource();
            }
          });
          Edge second = ListSequence.fromList(newEdges).findFirst(new IWhereFilter<Edge>() {
            public boolean accept(Edge it) {
              return it.getOpposite(addedNode) == dartToSplit.value.getTarget();
            }
          });
          for (Dart firstDart : ListSequence.fromList(embeddedGraph.getDarts(first))) {
            MapSequence.fromMap(bends).put(firstDart, 0);
            if (firstDart.getSource() == addedNode) {
              MapSequence.fromMap(angles).put(firstDart, 3);
            } else {
              MapSequence.fromMap(angles).put(firstDart, MapSequence.fromMap(angles).get(dartToSplit.value));
            }
          }
          Dart nextToSplit = null;
          Dart nextOpposite = null;
          for (Dart secondDart : ListSequence.fromList(embeddedGraph.getDarts(second))) {
            if (secondDart.getSource() == addedNode) {
              nextToSplit = secondDart;
              MapSequence.fromMap(bends).put(secondDart, MapSequence.fromMap(bends).get(dartToSplit.value) - 1);
              MapSequence.fromMap(angles).put(secondDart, 1);
            } else {
              nextOpposite = secondDart;
              MapSequence.fromMap(bends).put(secondDart, 0);
              MapSequence.fromMap(angles).put(secondDart, MapSequence.fromMap(angles).get(opposite));
            }
          }
          MapSequence.fromMap(bends).removeKey(dartToSplit.value);
          MapSequence.fromMap(angles).removeKey(dartToSplit.value);
          MapSequence.fromMap(bends).removeKey(opposite);
          MapSequence.fromMap(angles).removeKey(opposite);
          dartToSplit.value = nextToSplit;
          opposite = nextOpposite;
        }
      }
    }
  }

  public static Map<Dart, Direction2D> getDirections(EmbeddedGraph embeddedGraph, Map<Dart, Integer> angles) {
    OrthogonalRepresentation.GetDirectionsDfs dfs = new OrthogonalRepresentation.GetDirectionsDfs(embeddedGraph, angles);
    dfs.doDfs(embeddedGraph.getGraph(), Edge.Direction.BOTH);
    return dfs.getDirections();
  }

  private static class GetDirectionsDfs extends Dfs {
    private Map<Dart, Direction2D> myDirections;
    private EmbeddedGraph myEmbeddedGraph;
    private Map<Dart, Integer> myAngles;

    public GetDirectionsDfs(EmbeddedGraph embeddedGraph, Map<Dart, Integer> angles) {
      super();
      myEmbeddedGraph = embeddedGraph;
      myAngles = angles;
      myDirections = MapSequence.fromMap(new HashMap<Dart, Direction2D>());
    }

    @Override
    protected void preprocessRoot(final Node root) {
      Edge edge = ListSequence.fromList(root.getEdges()).first();
      Dart dart = ListSequence.fromList(myEmbeddedGraph.getDarts(edge)).findFirst(new IWhereFilter<Dart>() {
        public boolean accept(Dart it) {
          return it.getSource() == root;
        }
      });
      MapSequence.fromMap(myDirections).put(dart, Direction2D.RIGHT);
      MapSequence.fromMap(myDirections).put(myEmbeddedGraph.getOpposite(dart), MapSequence.fromMap(myDirections).get(dart).opposite());
    }

    @Override
    protected void preprocess(final Node node, Edge from) {
      List<Dart> darts = ListSequence.fromList(node.getEdges()).select(new ISelector<Edge, Dart>() {
        public Dart select(Edge edge) {
          return ListSequence.fromList(myEmbeddedGraph.getDarts(edge)).findFirst(new IWhereFilter<Dart>() {
            public boolean accept(Dart dart) {
              return dart.getSource() == node;
            }
          });
        }
      }).toListSequence();
      Dart first = ListSequence.fromList(darts).findFirst(new IWhereFilter<Dart>() {
        public boolean accept(Dart dart) {
          return MapSequence.fromMap(myDirections).containsKey(dart);
        }
      });
      List<Dart> orderedDarts = ListSequence.fromList(new ArrayList<Dart>());
      ListSequence.fromList(orderedDarts).addElement(first);
      Dart cur = first;
      do {
        Dart next = myEmbeddedGraph.getNextSourceDart(cur);
        MapSequence.fromMap(myDirections).put(next, MapSequence.fromMap(myDirections).get(cur).turnClockwise(MapSequence.fromMap(myAngles).get(cur)));
        MapSequence.fromMap(myDirections).put(myEmbeddedGraph.getOpposite(next), MapSequence.fromMap(myDirections).get(next).opposite());
        cur = next;
      } while (cur != first);
    }

    public Map<Dart, Direction2D> getDirections() {
      return myDirections;
    }
  }
}
