package jetbrains.mps.graphLayout.internal.flowOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import java.util.Map;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.graphLayout.intGeom2D.Direction2D;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.graph.Edge;
import java.util.Set;
import jetbrains.mps.graphLayout.planarGraph.Face;
import jetbrains.mps.graphLayout.intGeom2D.Dimension;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.graphLayout.algorithms.TopologicalSorting;
import jetbrains.mps.graphLayout.intGeom2D.Point;
import jetbrains.mps.graphLayout.algorithms.TopologicalNumbering;
import jetbrains.mps.graphLayout.graph.EdgesHistoryManager;
import jetbrains.mps.graphLayout.algorithms.WeightedTopologicalNumbering;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.graphLayout.algorithms.ConnectivityComponents;
import java.util.Arrays;
import jetbrains.mps.graphLayout.algorithms.ShortestPath;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;

public class ConstraintsGraphProcessor {
  private static int SHOW_INFO = 0;
  private static int DEBUG = 0;
  private static int DEFAULT_UNIT_LENGTH = 20;

  private Graph myGraph;
  private EmbeddedGraph myEmbeddedGraph;
  private Map<Dart, Direction2D> myDirections;
  private Graph myHorConstraintsGraph;
  private Graph myVerConstraintsGraph;
  private Map<Node, Node> myHorNodeMap;
  private Map<Node, Node> myVerNodeMap;
  private Map<Edge, Edge> myEdgeMap;
  private Map<Edge, Integer> myEdgeLengths;
  private Iterable<Node> myNodesWithSize;
  private Set<Face> myFacesToSkip;
  private int myUnitLength;

  public ConstraintsGraphProcessor(EmbeddedGraph embeddedGraph, Map<Dart, Direction2D> directions) {
    myEmbeddedGraph = embeddedGraph;
    myGraph = embeddedGraph.getGraph();
    myDirections = directions;
    myUnitLength = ConstraintsGraphProcessor.DEFAULT_UNIT_LENGTH;
    if (ConstraintsGraphProcessor.SHOW_INFO > 0) {
      System.out.println("initial graph: ");
      print();
    }
  }

  public void modifyEmbeddedGraph(Iterable<Node> nodesWithSize, Map<Node, Dimension> nodeSizes) {
    myNodesWithSize = nodesWithSize;
    myEdgeLengths = MapSequence.fromMap(new HashMap<Edge, Integer>());
    for (Node node : Sequence.fromIterable(nodesWithSize)) {
      List<Edge> oldEdges = ListSequence.fromList(new ArrayList<Edge>());
      ListSequence.fromList(oldEdges).addSequence(ListSequence.fromList(node.getEdges()));
      for (Edge oldEdge : ListSequence.fromList(oldEdges)) {
        this.splitEdge(oldEdge);
      }
      Map<Direction2D, List<Edge>> rectEdges = makeRectangleForNode(node);
      for (Direction2D dir : Direction2D.values()) {
        int length = MapSequence.fromMap(nodeSizes).get(node).width;
        if (dir.isVertical()) {
          length = MapSequence.fromMap(nodeSizes).get(node).height;
        }
        List<Edge> edges = MapSequence.fromMap(rectEdges).get(dir);
        int edgeLength = length / ListSequence.fromList(edges).count();
        for (Edge edge : ListSequence.fromList(edges)) {
          if (edge == ListSequence.fromList(edges).last()) {
            MapSequence.fromMap(myEdgeLengths).put(edge, length - (edgeLength * (ListSequence.fromList(edges).count() - 1)));
          } else {
            MapSequence.fromMap(myEdgeLengths).put(edge, edgeLength);
          }
        }
      }
    }
    if (ConstraintsGraphProcessor.SHOW_INFO > 0) {
      System.out.println("after modification: ");
      this.print();
    }
  }

  private void print() {
    for (Face face : ListSequence.fromList(myEmbeddedGraph.getFaces())) {
      System.out.println("face: ");
      if (myEmbeddedGraph.isOuterFace(face)) {
        System.out.println("this is outer face");
      }
      for (Dart dart : ListSequence.fromList(face.getDarts())) {
        String size = " ";
        if (MapSequence.fromMap(myEdgeLengths).containsKey(dart.getEdge())) {
          size += MapSequence.fromMap(myEdgeLengths).get(dart.getEdge());
        }
        System.out.println("  " + dart + " dir = " + MapSequence.fromMap(myDirections).get(dart) + size);
      }
    }
  }

  public Map<Direction2D, List<Edge>> makeRectangleForNode(Node node) {
    myFacesToSkip = SetSequence.fromSet(new HashSet<Face>());
    List<Dart> darts = myEmbeddedGraph.getDartWithSource(node);
    Map<Direction2D, List<Edge>> edgesInDirection = MapSequence.fromMap(new HashMap<Direction2D, List<Edge>>());
    for (Direction2D dir : Direction2D.values()) {
      MapSequence.fromMap(edgesInDirection).put(dir, ListSequence.fromList(new ArrayList<Edge>()));
    }
    Dart cur = ListSequence.fromList(darts).first();
    for (int step = 0; step < ListSequence.fromList(darts).count(); step++) {
      final Face face = myEmbeddedGraph.getFace(cur);
      Dart next = ListSequence.fromList(darts).findFirst(new IWhereFilter<Dart>() {
        public boolean accept(Dart dart) {
          return myEmbeddedGraph.getFace(myEmbeddedGraph.getOpposite(dart)) == face;
        }
      });
      int turn = MapSequence.fromMap(myDirections).get(cur).getClockwiseTurn(MapSequence.fromMap(myDirections).get(next));
      // if next==cur 
      if (turn == 0) {
        turn = 4;
      }
      List<Edge> newEdges = ListSequence.fromList(new LinkedList<Edge>());
      Node pathSource = cur.getTarget();
      Node pathTarget = next.getTarget();
      Node curNode = pathSource;
      for (int i = 0; i <= turn; i++) {
        Node nextNode;
        if (i == turn) {
          nextNode = pathTarget;
        } else {
          nextNode = myGraph.createNode();
        }
        ListSequence.fromList(newEdges).addElement(myGraph.connect(curNode, nextNode));
        curNode = nextNode;
      }
      boolean isOuter = myEmbeddedGraph.isOuterFace(face);
      List<Face> newFaces = myEmbeddedGraph.splitFace(face, newEdges, pathSource, pathTarget);
      Face newFaceWithNode = null;
      for (Face newFace : ListSequence.fromList(newFaces)) {
        Iterable<Node> faceNodes = ListSequence.fromList(newFace.getDarts()).select(new ISelector<Dart, Node>() {
          public Node select(Dart dart) {
            return dart.getSource();
          }
        });
        if (Sequence.fromIterable(faceNodes).contains(node)) {
          newFaceWithNode = newFace;
        }
      }
      SetSequence.fromSet(myFacesToSkip).addElement(newFaceWithNode);
      if (isOuter) {
        Face newOuterFace = ListSequence.fromList(newFaces).getElement(0);
        if (newOuterFace == newFaceWithNode) {
          newOuterFace = ListSequence.fromList(newFaces).getElement(1);
        }
        myEmbeddedGraph.setOuterFace(newOuterFace);
      }
      Direction2D curDir = MapSequence.fromMap(myDirections).get(cur).turnClockwise(1);
      curNode = pathSource;
      for (Edge edge : ListSequence.fromList(newEdges)) {
        for (Dart dart : ListSequence.fromList(myEmbeddedGraph.getDarts(edge))) {
          if (dart.getSource() == curNode) {
            MapSequence.fromMap(myDirections).put(dart, curDir);
            ListSequence.fromList(MapSequence.fromMap(edgesInDirection).get(curDir)).addElement(edge);
          } else {
            MapSequence.fromMap(myDirections).put(dart, curDir.opposite());
          }
        }
        curNode = edge.getOpposite(curNode);
        curDir = curDir.turnClockwise(1);
      }
      cur = next;
    }
    return edgesInDirection;
  }

  private Node splitEdge(Edge oldEdge) {
    Node source = oldEdge.getSource();
    Node target = oldEdge.getTarget();
    Dart sourceDart = myEmbeddedGraph.getSourceDart(oldEdge, source);
    Dart targetDart = myEmbeddedGraph.getSourceDart(oldEdge, target);
    List<Edge> edges = ListSequence.fromList(new ArrayList<Edge>());
    Node node = myEmbeddedGraph.splitEdge(oldEdge, edges);
    for (Edge edge : ListSequence.fromList(edges)) {
      for (Dart dart : ListSequence.fromList(myEmbeddedGraph.getDarts(edge))) {
        if (dart.getSource() == source || dart.getTarget() == target) {
          MapSequence.fromMap(myDirections).put(dart, MapSequence.fromMap(myDirections).get(sourceDart));
        } else {
          MapSequence.fromMap(myDirections).put(dart, MapSequence.fromMap(myDirections).get(targetDart));
        }
      }
    }
    MapSequence.fromMap(myDirections).removeKey(sourceDart);
    MapSequence.fromMap(myDirections).removeKey(targetDart);
    return node;
  }

  public void constructGraph() {
    getShape();
    for (Face face : ListSequence.fromList(myEmbeddedGraph.getFaces())) {
      if (myEmbeddedGraph.isOuterFace(face) || SetSequence.fromSet(myFacesToSkip).contains(face)) {
        continue;
      }
      makeShapeComplete(face);
    }
    if (ConstraintsGraphProcessor.DEBUG > 0) {
      if (TopologicalSorting.sort(myHorConstraintsGraph) == null) {
        throw new RuntimeException("horizontal constraints graph has cycles");
      }
      if (TopologicalSorting.sort(myVerConstraintsGraph) == null) {
        throw new RuntimeException("vertical constraints graph has cycles");
      }
      checkCompleteness();
    }
  }

  public Map<Node, Point> getCoordinates() {
    Map<Node, Integer> horNumbering = TopologicalNumbering.number(myHorConstraintsGraph);
    Map<Node, Integer> verNumbering = TopologicalNumbering.number(myVerConstraintsGraph);
    Map<Node, Point> coordinates = MapSequence.fromMap(new HashMap<Node, Point>());
    for (Node node : ListSequence.fromList(myGraph.getNodes())) {
      Node horSeg = MapSequence.fromMap(myHorNodeMap).get(node);
      Node verSeg = MapSequence.fromMap(myVerNodeMap).get(node);
      MapSequence.fromMap(coordinates).put(node, new Point(MapSequence.fromMap(horNumbering).get(horSeg), MapSequence.fromMap(verNumbering).get(verSeg)));
    }
    return coordinates;
  }

  public Map<Node, Point> getCoordinatesInModifiedGraph(EdgesHistoryManager historyManager) {
    return getCoordinatesInModifiedGraph(null, null, historyManager);
  }

  public Map<Node, Point> getCoordinatesInModifiedGraph(Map<Edge, Integer> edgeExtentions, Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes, EdgesHistoryManager historyManager) {
    Map<Edge, Integer> edgeLengths = MapSequence.fromMap(new HashMap<Edge, Integer>());
    for (Edge edge : ListSequence.fromList(myHorConstraintsGraph.getEdges())) {
      MapSequence.fromMap(edgeLengths).put(edge, myUnitLength);
    }
    for (Edge edge : ListSequence.fromList(myVerConstraintsGraph.getEdges())) {
      MapSequence.fromMap(edgeLengths).put(edge, myUnitLength);
    }
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(myEdgeLengths).keySet())) {
      MapSequence.fromMap(edgeLengths).put(MapSequence.fromMap(myEdgeMap).get(edge), MapSequence.fromMap(myEdgeLengths).get(edge));
    }
    for (Node node : SetSequence.fromSet(MapSequence.fromMap(nodeDirectionSizes).keySet())) {
      for (Edge edge : ListSequence.fromList(node.getEdges())) {
        Dart sourceDart = myEmbeddedGraph.getSourceDart(edge, node);
        MapSequence.fromMap(edgeLengths).put(MapSequence.fromMap(myEdgeMap).get(edge), MapSequence.fromMap(MapSequence.fromMap(nodeDirectionSizes).get(node)).get(MapSequence.fromMap(myDirections).get(sourceDart)));
      }
    }
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeExtentions).keySet())) {
      Edge curEdge = ListSequence.fromList(historyManager.getHistory(edge)).first();
      Edge constraintEdge = MapSequence.fromMap(myEdgeMap).get(curEdge);
      MapSequence.fromMap(edgeLengths).put(constraintEdge, MapSequence.fromMap(edgeLengths).get(constraintEdge) + MapSequence.fromMap(edgeExtentions).get(edge));
    }
    Map<Node, Integer> horNumbering = WeightedTopologicalNumbering.number(myHorConstraintsGraph, edgeLengths);
    Map<Node, Integer> verNjumbering = WeightedTopologicalNumbering.number(myVerConstraintsGraph, edgeLengths);
    Map<Node, Point> coordinates = MapSequence.fromMap(new HashMap<Node, Point>());
    for (Node node : ListSequence.fromList(myGraph.getNodes())) {
      Node horSeg = MapSequence.fromMap(myHorNodeMap).get(node);
      Node verSeg = MapSequence.fromMap(myVerNodeMap).get(node);
      MapSequence.fromMap(coordinates).put(node, new Point(MapSequence.fromMap(verNjumbering).get(verSeg), MapSequence.fromMap(horNumbering).get(horSeg)));
    }
    return coordinates;
  }

  public void makeShapeComplete(Face face) {
    List<Node> segments = ListSequence.fromList(new LinkedList<Node>());
    List<Direction2D> directions = ListSequence.fromList(new LinkedList<Direction2D>());
    List<Integer> rotations = ListSequence.fromList(new LinkedList<Integer>());
    Node prevSeg = null;
    for (Dart dart : ListSequence.fromList(face.getDarts())) {
      Direction2D dir = MapSequence.fromMap(myDirections).get(dart);
      Node source = dart.getSource();
      Node seg;
      if (dir.isHorizontal()) {
        seg = MapSequence.fromMap(myHorNodeMap).get(source);
      } else {
        seg = MapSequence.fromMap(myVerNodeMap).get(source);
      }
      if (seg != prevSeg) {
        if (prevSeg != null) {
          ListSequence.fromList(rotations).addElement(ListSequence.fromList(directions).last().getTurn(dir));
        }
        ListSequence.fromList(segments).addElement(seg);
        ListSequence.fromList(directions).addElement(dir);
      }
      prevSeg = seg;
    }
    if (prevSeg != ListSequence.fromList(segments).first()) {
      ListSequence.fromList(rotations).addElement(ListSequence.fromList(directions).last().getTurn(ListSequence.fromList(directions).first()));
    } else {
      ListSequence.fromList(directions).removeLastElement();
      ListSequence.fromList(segments).removeLastElement();
    }
    if (ConstraintsGraphProcessor.SHOW_INFO > 0) {
      System.out.println(face);
      for (int i = 0; i < ListSequence.fromList(segments).count(); i++) {
        System.out.println(ListSequence.fromList(segments).getElement(i) + " dir = " + ListSequence.fromList(directions).getElement(i) + " rot = " + ListSequence.fromList(rotations).getElement(i));
      }
    }
    int numShifts = 0;
    while (ListSequence.fromList(segments).count() > 4) {
      if (ListSequence.fromList(rotations).getElement(0) == -1 && ListSequence.fromList(rotations).getElement(1) == 1 && ListSequence.fromList(rotations).getElement(2) == 1) {
        connectPattern(segments, directions);
        for (int i = 0; i < 2; i++) {
          ListSequence.fromList(segments).removeElementAt(1);
          ListSequence.fromList(rotations).removeElementAt(1);
          ListSequence.fromList(directions).removeElementAt(1);
        }
        ListSequence.fromList(rotations).setElement(0, 1);
        numShifts = 0;
      } else {
        ListSequence.fromList(segments).insertElement(0, ListSequence.fromList(segments).removeLastElement());
        ListSequence.fromList(rotations).insertElement(0, ListSequence.fromList(rotations).removeLastElement());
        ListSequence.fromList(directions).insertElement(0, ListSequence.fromList(directions).removeLastElement());
        numShifts++;
        if (numShifts > ListSequence.fromList(segments).count()) {
          throw new RuntimeException("error in segments");
        }
      }
    }
    if (ConstraintsGraphProcessor.DEBUG > 0) {
      for (int rotation : ListSequence.fromList(rotations)) {
        if (rotation != 1) {
          throw new RuntimeException("bad face completion result!");
        }
      }
    }
    connectPattern(segments, directions);
  }

  private void connectConstraintsNodes(final Node node1, final Node node2, Direction2D direction) {
    Graph graph = node1.getGraph();
    Edge connectingEdge = ListSequence.fromList(node1.getEdges()).findFirst(new IWhereFilter<Edge>() {
      public boolean accept(Edge edge) {
        return edge.getOpposite(node1) == node2;
      }
    });
    if (connectingEdge != null) {
      return;
    }
    Edge edge;
    if (direction == Direction2D.UP || direction == Direction2D.RIGHT) {
      edge = graph.connect(node1, node2);
    } else {
      edge = graph.connect(node2, node1);
    }
    if (ConstraintsGraphProcessor.SHOW_INFO > 0) {
      if (direction.isHorizontal()) {
        System.out.println("added " + edge + " to ver");
      } else {
        System.out.println("added " + edge + " to hor");
      }
    }
  }

  private void connectPattern(List<Node> nodes, List<Direction2D> directions) {
    connectConstraintsNodes(ListSequence.fromList(nodes).getElement(0), ListSequence.fromList(nodes).getElement(2), ListSequence.fromList(directions).getElement(1));
    connectConstraintsNodes(ListSequence.fromList(nodes).getElement(1), ListSequence.fromList(nodes).getElement(3), ListSequence.fromList(directions).getElement(2));
  }

  public void getShape() {
    Map<Node, Node> horNodeMap = MapSequence.fromMap(new HashMap<Node, Node>());
    Graph horConstraintsGraph = getDirectionConstraintsGraph(new _FunctionTypes._return_P1_E0<Boolean, Direction2D>() {
      public Boolean invoke(Direction2D dir) {
        return dir.isHorizontal();
      }
    }, horNodeMap);
    Map<Node, Node> verNodeMap = MapSequence.fromMap(new HashMap<Node, Node>());
    Graph verConstraintsGraph = getDirectionConstraintsGraph(new _FunctionTypes._return_P1_E0<Boolean, Direction2D>() {
      public Boolean invoke(Direction2D dir) {
        return dir.isVertical();
      }
    }, verNodeMap);
    Map<Edge, Edge> edgeMap = MapSequence.fromMap(new HashMap<Edge, Edge>());
    for (Edge edge : ListSequence.fromList(myGraph.getEdges())) {
      Edge newEdge = connect(edge, Direction2D.RIGHT, verNodeMap);
      if (newEdge != null) {
        MapSequence.fromMap(edgeMap).put(edge, newEdge);
      } else {
        MapSequence.fromMap(edgeMap).put(edge, connect(edge, Direction2D.UP, horNodeMap));
      }
    }
    myHorConstraintsGraph = horConstraintsGraph;
    myVerConstraintsGraph = verConstraintsGraph;
    myHorNodeMap = horNodeMap;
    myVerNodeMap = verNodeMap;
    myEdgeMap = edgeMap;
    if (ConstraintsGraphProcessor.SHOW_INFO > 0) {
      System.out.println("constaints graph:");
      for (Node node : ListSequence.fromList(myGraph.getNodes())) {
        System.out.println("node " + node);
        System.out.println("hor = " + MapSequence.fromMap(horNodeMap).get(node) + ", ver = " + MapSequence.fromMap(verNodeMap).get(node));
      }
      System.out.println("horizontal constraints graph: " + horConstraintsGraph);
      System.out.println("vertical constraints graph: " + verConstraintsGraph);
    }
  }

  private Edge connect(Edge realEdge, final Direction2D direction, Map<Node, Node> nodeMap) {
    Dart dart = ListSequence.fromList(myEmbeddedGraph.getDarts(realEdge)).findFirst(new IWhereFilter<Dart>() {
      public boolean accept(Dart it) {
        return MapSequence.fromMap(myDirections).get(it) == direction;
      }
    });
    if (dart != null) {
      Node sourceNode = MapSequence.fromMap(nodeMap).get(dart.getSource());
      Node targetNode = MapSequence.fromMap(nodeMap).get(dart.getTarget());
      Graph graph = sourceNode.getGraph();
      return graph.connect(sourceNode, targetNode);
    }
    return null;
  }

  private Graph getDirectionConstraintsGraph(final _FunctionTypes._return_P1_E0<? extends Boolean, ? super Direction2D> directionFilter, Map<Node, Node> nodeMap) {
    Map<Node, Integer> components = ConnectivityComponents.getComponents(myGraph, new _FunctionTypes._return_P1_E0<Boolean, Edge>() {
      public Boolean invoke(Edge edge) {
        Dart dart = ListSequence.fromList(myEmbeddedGraph.getDarts(edge)).getElement(0);
        return directionFilter.invoke(MapSequence.fromMap(myDirections).get(dart));
      }
    });
    List<List<Node>> componentsList = ConnectivityComponents.getComponentsList(components);
    Graph constraintsCraph = new Graph();
    for (List<Node> nodeList : ListSequence.fromList(componentsList)) {
      Node componentNode = constraintsCraph.createNode();
      for (Node node : ListSequence.fromList(nodeList)) {
        MapSequence.fromMap(nodeMap).put(node, componentNode);
      }
    }
    return constraintsCraph;
  }

  private void checkCompleteness() {
    for (Node horSeg : ListSequence.fromList(myHorConstraintsGraph.getNodes())) {
      for (Node verSeg : ListSequence.fromList(myVerConstraintsGraph.getNodes())) {
        if (isSegmentsIntersect(horSeg, verSeg)) {
          continue;
        }
        if (ConstraintsGraphProcessor.SHOW_INFO > 0) {
          System.out.println("found separated pair: hor = " + horSeg + ", ver = " + verSeg);
        }
        Node[] horEnds = getSegmentEndSegments(horSeg, Direction2D.RIGHT);
        Node[] verEnds = getSegmentEndSegments(verSeg, Direction2D.UP);
        if (ConstraintsGraphProcessor.SHOW_INFO > 0) {
          System.out.println("hor ends: " + Arrays.toString(horEnds));
          System.out.println("ver ends: " + Arrays.toString(verEnds));
        }
        boolean isSeparated = false;
        isSeparated |= hasPath(myHorConstraintsGraph, horSeg, verEnds);
        isSeparated |= hasPath(myVerConstraintsGraph, verSeg, horEnds);
        if (!(isSeparated)) {
          throw new RuntimeException("pair is not separated in constraints graph!!!");
        }
      }
    }
  }

  private boolean hasPath(Graph graph, Node node, Node[] ends) {
    if (ShortestPath.getPath(graph, node, ends[0], Edge.Direction.FRONT) != null) {
      return true;
    }
    if (ShortestPath.getPath(graph, ends[1], node, Edge.Direction.FRONT) != null) {
      return true;
    }
    return false;
  }

  private boolean isSegmentsIntersect(final Node horSegment, final Node verSegment) {
    Iterable<Node> horNodes = SetSequence.fromSet(MapSequence.fromMap(myHorNodeMap).keySet()).where(new IWhereFilter<Node>() {
      public boolean accept(Node key) {
        return MapSequence.fromMap(myHorNodeMap).get(key) == horSegment;
      }
    });
    Iterable<Node> verNodes = SetSequence.fromSet(MapSequence.fromMap(myVerNodeMap).keySet()).where(new IWhereFilter<Node>() {
      public boolean accept(Node key) {
        return MapSequence.fromMap(myVerNodeMap).get(key) == verSegment;
      }
    });
    boolean intersects = false;
    for (Node node : Sequence.fromIterable(horNodes)) {
      intersects |= Sequence.fromIterable(verNodes).contains(node);
    }
    return intersects;
  }

  private Node[] getSegmentEndSegments(Node segment, Direction2D direction) {
    Node[] ends = getSegmentEnds(segment, direction);
    Map<Node, Node> nodeMap;
    if (direction.isHorizontal()) {
      nodeMap = myVerNodeMap;
    } else {
      nodeMap = myHorNodeMap;
    }
    for (int i = 0; i < ends.length; i++) {
      ends[i] = MapSequence.fromMap(nodeMap).get(ends[i]);
    }
    return ends;
  }

  private Node[] getSegmentEnds(final Node segment, final Direction2D direction) {
    final Wrappers._T<Map<Node, Node>> nodeMap = new Wrappers._T<Map<Node, Node>>();
    if (direction.isHorizontal()) {
      nodeMap.value = myHorNodeMap;
    } else {
      nodeMap.value = myVerNodeMap;
    }
    Iterable<Node> nodes = SetSequence.fromSet(MapSequence.fromMap(nodeMap.value).keySet()).where(new IWhereFilter<Node>() {
      public boolean accept(Node key) {
        return MapSequence.fromMap(nodeMap.value).get(key) == segment;
      }
    });
    Set<Node> firstCandidates = SetSequence.fromSet(new HashSet<Node>());
    SetSequence.fromSet(firstCandidates).addSequence(Sequence.fromIterable(nodes));
    Node[] ends = new Node[2];
    for (Node node : Sequence.fromIterable(nodes)) {
      Dart dart = ListSequence.fromList(myEmbeddedGraph.getDartWithSource(node)).findFirst(new IWhereFilter<Dart>() {
        public boolean accept(Dart it) {
          return MapSequence.fromMap(myDirections).get(it) == direction;
        }
      });
      if (dart == null) {
        if (ConstraintsGraphProcessor.DEBUG > 0 && ends[1] != null) {
          throw new RuntimeException("found two last nodes for seg " + segment + " by dir " + direction);
        }
        ends[1] = node;
      } else {
        SetSequence.fromSet(firstCandidates).removeElement(dart.getTarget());
      }
    }
    if (ConstraintsGraphProcessor.DEBUG > 0) {
      if (SetSequence.fromSet(firstCandidates).count() != 1) {
        throw new RuntimeException("failed to find first node for seg " + segment + " by dir " + direction);
      }
      if (ends[1] == null) {
        throw new RuntimeException("failed to find last node for seg " + segment + " by dir " + direction);
      }
    }
    ends[0] = SetSequence.fromSet(firstCandidates).first();
    return ends;
  }

  public int getUnitLength() {
    return myUnitLength;
  }

  public void setUnitLength(int unitLength) {
    myUnitLength = unitLength;
  }
}
