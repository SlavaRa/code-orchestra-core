package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Graph;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.algorithms.ConnectivityComponents;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.graphLayout.algorithms.BiconnectedComponent;
import jetbrains.mps.graphLayout.algorithms.GraphOrientation;
import java.util.Set;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashMap;
import jetbrains.mps.graphLayout.planarGraph.Face;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import java.util.ArrayList;

public class PQPlanarizationFinder implements IEmbeddingFinder {
  private static int SHOW_LOG = 0;

  private Graph myGraph;
  private Map<Node, Integer> myNumbering;

  public PQPlanarizationFinder() {
  }

  public EmbeddedGraph find(Graph graph) {
    Map<Node, Integer> components = ConnectivityComponents.getComponents(graph);
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      if (MapSequence.fromMap(components).get(node) != 0) {
        throw new RuntimeException("graph isn't connected!!!");
      }
    }
    myGraph = graph;
    BiconnectedComponent componentsTree = BiconnectedComponent.createTree(graph);
    if (SHOW_LOG > 0) {
      System.out.println(componentsTree.toString(""));
    }
    return createEmbedding(componentsTree);
    /*

      myNumbering = GraphOrientation.orientST(graph);
      PQPlanarityTest pqPlanarityTest = new PQPlanarityTest();
      Set<Edge> removed = pqPlanarityTest.removeEdgesToPlanarity(graph, myNumbering);
      if (SHOW_LOG > 0) {
        System.out.println("removed edges:");
        System.out.println(removed);
      }
      if (SetSequence.fromSet(removed).count() == 0) {
        return pqPlanarityTest.getEmbedding(graph, myNumbering);
      } else {
        for (Edge edge : SetSequence.fromSet(removed)) {
          edge.removeFromGraph();
        }
        BiconnectedComponent tree = BiconnectedComponent.createTree(graph);
        if (SHOW_LOG > 0) {
          System.out.println(tree.toString(""));
        }
        EmbeddedGraph embeddedGraph = createEmbedding(tree);
        for (Edge edge : SetSequence.fromSet(removed)) {
          edge.addToGraph();
        }
        return embeddedGraph;
      }
    */
  }

  private EmbeddedGraph createEmbedding(BiconnectedComponent component) {
    Graph componentGraph = new Graph();
    Set<Node> nodes = component.getNodes();
    EmbeddedGraph graphEmbedding = new EmbeddedGraph(myGraph);
    boolean manyNodeComponent = SetSequence.fromSet(nodes).count() > 1;
    if (manyNodeComponent) {
      Map<Node, Node> nodeMap = MapSequence.fromMap(new HashMap<Node, Node>());
      Map<Node, Node> invertedNodeMap = MapSequence.fromMap(new HashMap<Node, Node>());
      Map<Edge, Edge> invertedEdgeMap = MapSequence.fromMap(new HashMap<Edge, Edge>());
      for (Node node : SetSequence.fromSet(nodes)) {
        Node componentNode = componentGraph.createNode();
        MapSequence.fromMap(nodeMap).put(node, componentNode);
        MapSequence.fromMap(invertedNodeMap).put(componentNode, node);
      }
      for (Node node : SetSequence.fromSet(component.getNodes())) {
        for (Edge edge : ListSequence.fromList(node.getEdges(Edge.Direction.FRONT))) {
          Node target = edge.getTarget();
          if (SetSequence.fromSet(nodes).contains(target)) {
            Edge newEdge = componentGraph.connect(MapSequence.fromMap(nodeMap).get(node), MapSequence.fromMap(nodeMap).get(target));
            MapSequence.fromMap(invertedEdgeMap).put(newEdge, edge);
          }
        }
      }
      if (SHOW_LOG > 0) {
        System.out.println("COMPONENT!!! " + componentGraph.getNumNodes() + "  : " + ListSequence.fromList(componentGraph.getEdges()).count());
        System.out.println("map: " + nodeMap);
      }
      PQPlanarityTest pqPlanarityTest = new PQPlanarityTest();
      Set<Edge> removed = pqPlanarityTest.removeEdgesToPlanarity(componentGraph, GraphOrientation.orientST(componentGraph));
      EmbeddedGraph componentEmbedding;
      if (SetSequence.fromSet(removed).count() == 0) {
        componentEmbedding = pqPlanarityTest.getEmbedding(componentGraph, GraphOrientation.orientST(componentGraph));
      } else {
        for (Edge edge : SetSequence.fromSet(removed)) {
          componentGraph.removeEdge(edge);
        }
        BiconnectedComponent tree = BiconnectedComponent.createTree(componentGraph);
        componentEmbedding = createEmbedding(tree);
        for (Edge edge : SetSequence.fromSet(removed)) {
          componentGraph.addEdge(edge);
        }
      }
      for (Face componentFace : ListSequence.fromList(componentEmbedding.getFaces())) {
        Face graphFace = new Face(myGraph);
        for (Dart dart : ListSequence.fromList(componentFace.getDarts())) {
          graphFace.addLast(new Dart(MapSequence.fromMap(invertedEdgeMap).get(dart.getEdge()), MapSequence.fromMap(invertedNodeMap).get(dart.getSource())));
        }
        graphEmbedding.addFace(graphFace);
        if (componentEmbedding.isOuterFace(componentFace)) {
          graphEmbedding.setOuterFace(graphFace);
        }
      }
    } else {
      Face fakeFace = new Face(myGraph);
      graphEmbedding.addFace(fakeFace);
      graphEmbedding.setOuterFace(fakeFace);
    }
    for (BiconnectedComponent child : ListSequence.fromList(component.getChildren())) {
      EmbeddedGraph childEmbedding = createEmbedding(child);
      Object connection = component.getConnection(child);
      Edge bridge = null;
      if (connection instanceof Edge) {
        bridge = ((Edge) connection);
      }
      Node cutpoint = component.getCutpoint(child);
      Node childCutpoint = component.getChildCutpoint(child);
      Face outerChildFace;
      if (ListSequence.fromList(childEmbedding.getFaces()).count() > 1) {
        outerChildFace = childEmbedding.findContainingFace(ListSequence.fromListAndArray(new ArrayList<Node>(), childCutpoint));
      } else {
        outerChildFace = childEmbedding.getOuterFace();
      }
      if (bridge != null) {
        // outerChildFace can be fake 
        if (ListSequence.fromList(outerChildFace.getDarts()).count() > 0) {
          outerChildFace.makeEndsWith(bridge.getOpposite(cutpoint));
        }
        childEmbedding.addLastDart(outerChildFace, new Dart(bridge, bridge.getOpposite(cutpoint)));
        childEmbedding.addLastDart(outerChildFace, new Dart(bridge, cutpoint));
      }
      if (!(manyNodeComponent)) {
        graphEmbedding = childEmbedding;
        manyNodeComponent = true;
      } else {
        Face face = graphEmbedding.findContainingFace(ListSequence.fromListAndArray(new ArrayList<Node>(), cutpoint));
        boolean isOuter = graphEmbedding.isOuterFace(face);
        graphEmbedding.removeFace(face);
        childEmbedding.removeFace(outerChildFace);
        Face newFace = new Face(myGraph);
        for (Dart dart : ListSequence.fromList(face.makeEndsWith(cutpoint))) {
          newFace.addLast(dart);
        }
        for (Dart dart : ListSequence.fromList(outerChildFace.makeEndsWith(cutpoint))) {
          newFace.addLast(dart);
        }
        graphEmbedding.addFace(newFace);
        if (isOuter) {
          graphEmbedding.setOuterFace(newFace);
        }
        for (Face childFace : ListSequence.fromList(childEmbedding.getFaces())) {
          graphEmbedding.addFace(childFace);
        }
      }
    }
    return graphEmbedding;
  }
}
