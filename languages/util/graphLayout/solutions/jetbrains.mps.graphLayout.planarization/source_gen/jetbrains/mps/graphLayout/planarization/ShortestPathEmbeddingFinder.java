package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.graph.Graph;
import java.util.List;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.graphLayout.planarGraph.DualGraph;
import jetbrains.mps.graphLayout.graph.Node;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.graphLayout.planarGraph.Face;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.graphLayout.algorithms.ShortestPath;
import jetbrains.mps.graphLayout.graph.GraphModificationEvent;

public class ShortestPathEmbeddingFinder implements IEmbeddingFinder {
  private static int SHOW_LOG = 0;

  private IEmbeddingFinder myInitialFinder;
  private boolean myForbidOuterEdgeCrossing;

  public ShortestPathEmbeddingFinder(IEmbeddingFinder initialFinder) {
    myInitialFinder = initialFinder;
    myForbidOuterEdgeCrossing = false;
  }

  public void setForbidOuterFaceCrossing(boolean forbidOuterFaceCrossing) {
    myForbidOuterEdgeCrossing = forbidOuterFaceCrossing;
  }

  public EmbeddedGraph find(Graph graph) {
    if (graph.getNumNodes() < 2) {
      return new EmbeddedGraph(graph);
    }
    final EmbeddedGraph embeddedGraph = myInitialFinder.find(graph);
    if (SHOW_LOG > 0) {
      System.out.println("initial embedding: ");
      System.out.println(embeddedGraph);
    }
    List<Edge> toAdd = ListSequence.fromList(graph.getEdges()).where(new IWhereFilter<Edge>() {
      public boolean accept(Edge edge) {
        return embeddedGraph.getAdjacentFaces(edge) == null;
      }
    }).toListSequence();
    if (SHOW_LOG > 0) {
      System.out.println("edges to add: ");
      System.out.println(toAdd);
    }
    for (Edge edge : ListSequence.fromList(toAdd)) {
      graph.removeEdge(edge);
    }
    for (Edge edge : ListSequence.fromList(toAdd)) {
      restoreEdge(embeddedGraph, edge, myForbidOuterEdgeCrossing);
      if (SHOW_LOG > 0) {
        System.out.println("restored " + edge);
        System.out.println(embeddedGraph);
      }
    }
    return embeddedGraph;
  }

  public static List<Edge> restoreEdge(EmbeddedGraph embeddedGraph, Edge removedEdge, boolean forbidOuterEdgeCrossing) {
    DualGraph dualGraph = new DualGraph(embeddedGraph);
    List<Node> newNodes = ListSequence.fromList(new ArrayList<Node>());
    for (Node node : ListSequence.fromList(removedEdge.getAdjacentNodes())) {
      ListSequence.fromList(newNodes).addElement(dualGraph.addRealNode(node));
    }
    if (forbidOuterEdgeCrossing) {
      final Map<Node, Face> facesMap = dualGraph.getFacesMap();
      final Face outerFace = embeddedGraph.getOuterFace();
      Node outerNode = ListSequence.fromList(dualGraph.getNodes()).findFirst(new IWhereFilter<Node>() {
        public boolean accept(Node it) {
          return MapSequence.fromMap(facesMap).get(it) == outerFace;
        }
      });
      dualGraph.deleteNode(outerNode);
    }
    List<Edge> path = ShortestPath.getPath(dualGraph, ListSequence.fromList(newNodes).getElement(0), ListSequence.fromList(newNodes).getElement(1), Edge.Direction.BOTH);
    List<Node> nodePath = ListSequence.fromList(new ArrayList<Node>());
    List<Face> facePath = ListSequence.fromList(new ArrayList<Face>());
    ListSequence.fromList(nodePath).addElement(ListSequence.fromList(removedEdge.getAdjacentNodes()).getElement(0));
    Node cur = ListSequence.fromList(newNodes).getElement(0);
    for (Edge edge : ListSequence.fromList(path)) {
      Edge realEdge = MapSequence.fromMap(dualGraph.getEdgesMap()).get(edge);
      if (embeddedGraph.getAdjacentFaces(realEdge) != null) {
        ListSequence.fromList(nodePath).addElement(embeddedGraph.splitEdge(MapSequence.fromMap(dualGraph.getEdgesMap()).get(edge)));
      }
      cur = edge.getOpposite(cur);
      Face curFace = MapSequence.fromMap(dualGraph.getFacesMap()).get(cur);
      if (curFace != null) {
        ListSequence.fromList(facePath).addElement(curFace);
      }
    }
    List<Edge> newEdges = ListSequence.fromList(new ArrayList<Edge>(ListSequence.fromList(nodePath).count() - 1));
    ListSequence.fromList(nodePath).addElement(ListSequence.fromList(removedEdge.getAdjacentNodes()).getElement(1));
    if (SHOW_LOG > 0) {
      System.out.println("path: ");
      System.out.println(nodePath);
    }
    for (int i = 0; i < ListSequence.fromList(nodePath).count() - 1; i++) {
      Node start = ListSequence.fromList(nodePath).getElement(i);
      Node end = ListSequence.fromList(nodePath).getElement(i + 1);
      Edge newEdge = embeddedGraph.getGraph().connect(start, end);
      ListSequence.fromList(newEdges).addElement(newEdge);
      List<Edge> tempPath = ListSequence.fromListAndArray(new ArrayList<Edge>(), newEdge);
      embeddedGraph.splitFace(ListSequence.fromList(facePath).getElement(i), tempPath, start, end);
    }
    GraphModificationEvent splitEvent = new GraphModificationEvent(GraphModificationEvent.Type.EDGE_SPLITTED, removedEdge, newEdges);
    embeddedGraph.getGraph().getModificationProcessor().fire(splitEvent);
    return newEdges;
  }
}
