package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Node;
import java.util.List;
import java.util.ListIterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public class PQTree {
  private static int SHOW_LOG = 0;

  private PQNode myRoot;
  private Node myNodeToMerge;

  public PQTree() {
    myRoot = null;
  }

  public PQNode getRoot() {
    return this.myRoot;
  }

  public void setRoot(PQNode root) {
    this.myRoot = root;
  }

  public PQNode modifyTree(Node nodeToMerge) {
    myNodeToMerge = nodeToMerge;
    String oldTreeRepresentation = this.toString();
    int oldNumFullLeaves = findPertinentRoot(myRoot).getNumFullLeaves();
    makeReducible();
    PQNode pertinentRoot = findPertinentRoot(myRoot);
    int numFullLeaves = pertinentRoot.getNumFullLeaves();
    if (SHOW_LOG > 0) {
      if (oldNumFullLeaves > numFullLeaves) {
        System.out.println("Graph has been made reductible!");
        System.out.println("before:");
        System.out.println(oldTreeRepresentation);
        System.out.println("after:");
        System.out.println(this);
      }
    }
    if (numFullLeaves == 1) {
      pertinentRoot = pertinentRoot.getParent();
      List<PQNode> children = pertinentRoot.getChildren();
      ListIterator<PQNode> childItr = children.listIterator();
      PNode newNode = null;
      while (childItr.hasNext()) {
        PQNode child = childItr.next();
        if (child.getState() == PQNode.State.FULL) {
          newNode = new PNode(nodeToMerge, ((PNode) child).getEdge());
          newNode.setParent(pertinentRoot);
          childItr.set(newNode);
        }
      }
      return newNode;
    } else {
      List<PQNode> modifiedChildren = ListSequence.fromList(new ArrayList<PQNode>());
      if (pertinentRoot instanceof QNode) {
        PQNode prePertinentRoot = pertinentRoot.getParent();
        for (PQNode child : ListSequence.fromList(prePertinentRoot.getChildren())) {
          if (child == pertinentRoot) {
            ListSequence.fromList(modifiedChildren).addElement(arrange(child, true));
          } else {
            ListSequence.fromList(modifiedChildren).addElement(arrange(child, false));
          }
        }
        for (PQNode child : ListSequence.fromList(modifiedChildren)) {
          child.setParent(prePertinentRoot);
        }
        return prePertinentRoot.processAsPertinentRoot(modifiedChildren, nodeToMerge);
      } else {
        for (PQNode child : ListSequence.fromList(pertinentRoot.getChildren())) {
          ListSequence.fromList(modifiedChildren).addElement(arrange(child, false));
        }
        for (PQNode child : ListSequence.fromList(modifiedChildren)) {
          child.setParent(pertinentRoot);
        }
        return pertinentRoot.processAsPertinentRoot(modifiedChildren, nodeToMerge);
      }
    }
  }

  public PQNode findPertinentRoot(PQNode node) {
    if (node.isLeaf()) {
      if (node.getGraphNode() == myNodeToMerge) {
        node.setState(PQNode.State.FULL);
        node.setNumFullLeaves(1);
      } else {
        node.setState(PQNode.State.EMPTY);
        node.setNumFullLeaves(0);
      }
      return node;
    } else {
      PQNode pertinentRootCandidate = null;
      int numFullChildren = 0;
      int numEmptyChildren = 0;
      int numPartialChildren = 0;
      int numFullLeaves = 0;
      for (PQNode child : ListSequence.fromList(node.getChildren())) {
        PQNode childPertinentRoot = findPertinentRoot(child);
        numFullLeaves += child.getNumFullLeaves();
        if (child.getState() == PQNode.State.EMPTY) {
          numEmptyChildren++;
        } else {
          pertinentRootCandidate = childPertinentRoot;
          if (child.getState() == PQNode.State.FULL) {
            numFullChildren++;
          }
          if (child.getState() == PQNode.State.PARTIAL) {
            numPartialChildren++;
          }
        }
      }
      node.setNumFullLeaves(numFullLeaves);
      if (numPartialChildren > 0) {
        node.setState(PQNode.State.PARTIAL);
      } else {
        int numChildren = ListSequence.fromList(node.getChildren()).count();
        if (numFullChildren == numChildren) {
          node.setState(PQNode.State.FULL);
        } else if (numEmptyChildren == numChildren) {
          node.setState(PQNode.State.EMPTY);
        } else {
          node.setState(PQNode.State.PARTIAL);
        }
      }
      if (numPartialChildren + numFullChildren == 1) {
        return pertinentRootCandidate;
      } else {
        return node;
      }
    }
  }

  private PQNode arrange(PQNode node, boolean isRealPertinentRoot) {
    // this boolean value is for Q3 case only 
    if (node.getNumFullLeaves() == 0) {
      node.setState(PQNode.State.EMPTY);
      return node;
    }
    List<PQNode> children = node.getChildren();
    ListIterator<PQNode> childItr = children.listIterator();
    while (childItr.hasNext()) {
      PQNode child = childItr.next();
      PQNode newChild = arrange(child, false);
      childItr.set(newChild);
    }
    return node.makeReduction(isRealPertinentRoot);
  }

  @Override
  public String toString() {
    return getRoot().toString(0);
  }

  public void makeReducible() {
    PQNode pertinentRoot = findPertinentRoot(myRoot);
    pertinentRoot.computeHValue();
    pertinentRoot.computeAValue();
    if (pertinentRoot.getHValue() < pertinentRoot.getAValue()) {
      pertinentRoot.makeHDeletion();
    } else {
      pertinentRoot.makeADeletion();
    }
  }
}
