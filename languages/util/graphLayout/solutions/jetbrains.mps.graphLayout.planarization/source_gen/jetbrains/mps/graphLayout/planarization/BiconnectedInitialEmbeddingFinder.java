package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.graph.Graph;
import java.util.Set;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.graphLayout.graph.Edge;
import java.util.List;
import jetbrains.mps.graphLayout.algorithms.ShortestPath;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.planarGraph.Face;
import jetbrains.mps.graphLayout.planarGraph.DualGraph;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.graphLayout.graph.GraphModificationEvent;

public class BiconnectedInitialEmbeddingFinder implements IEmbeddingFinder {
  private static int SHOW_LOG = 0;

  public BiconnectedInitialEmbeddingFinder() {
  }

  public EmbeddedGraph find(Graph graph) {
    EmbeddedGraph embeddedGraph = new EmbeddedGraph(graph);
    this.findCycle(embeddedGraph);
    Set<Node> toBeAdded = SetSequence.fromSet(new HashSet<Node>());
    SetSequence.fromSet(toBeAdded).addSequence(ListSequence.fromList(graph.getNodes()));
    for (Dart dart : ListSequence.fromList(embeddedGraph.getOuterFace().getDarts())) {
      SetSequence.fromSet(toBeAdded).removeElement(dart.getSource());
    }
    while (SetSequence.fromSet(toBeAdded).count() > 0) {
      for (Edge edge : ListSequence.fromList(graph.getEdges())) {
        for (Node node : ListSequence.fromList(edge.getAdjacentNodes())) {
          Node opNode = edge.getOpposite(node);
          if (!(SetSequence.fromSet(toBeAdded).contains(node)) && SetSequence.fromSet(toBeAdded).contains(opNode)) {
            addPath(embeddedGraph, node, opNode, toBeAdded);
          }
        }
      }
    }
    return embeddedGraph;
  }

  private void addPath(EmbeddedGraph embeddedGraph, final Node start, final Node toAdd, Set<Node> toBeAdded) {
    if (SHOW_LOG > 0) {
      System.out.println("before: \n" + embeddedGraph);
    }
    Set<Edge> removed = SetSequence.fromSet(new HashSet<Edge>());
    for (Edge edge : ListSequence.fromList(start.getEdges())) {
      if (SetSequence.fromSet(toBeAdded).contains(edge.getOpposite(start))) {
        SetSequence.fromSet(removed).addElement(edge);
      }
    }
    for (Edge edge : SetSequence.fromSet(removed)) {
      embeddedGraph.getGraph().removeEdge(edge);
    }
    List<Edge> path = ShortestPath.getPath(embeddedGraph.getGraph(), toAdd, start, Edge.Direction.BOTH);
    int endIndex = 0;
    Node cur = toAdd;
    while (SetSequence.fromSet(toBeAdded).contains(cur)) {
      cur = ListSequence.fromList(path).getElement(endIndex).getOpposite(cur);
      endIndex++;
    }
    path = ListSequence.fromList(path).subListSequence(0, endIndex);
    for (Edge edge : SetSequence.fromSet(removed)) {
      embeddedGraph.getGraph().addEdge(edge);
    }
    ListSequence.fromList(path).insertElement(0, ListSequence.fromList(SetSequence.fromSet(removed).where(new IWhereFilter<Edge>() {
      public boolean accept(Edge it) {
        return it.getOpposite(start) == toAdd;
      }
    }).toListSequence()).getElement(0));
    for (Edge edge : ListSequence.fromList(path)) {
      for (Node node : ListSequence.fromList(edge.getAdjacentNodes())) {
        SetSequence.fromSet(toBeAdded).removeElement(node);
      }
    }
    if (SHOW_LOG > 0) {
      System.out.println("find path: " + path);
    }
    connect(embeddedGraph, path, start, cur);
  }

  private void findCycle(EmbeddedGraph embeddedGraph) {
    Set<Node> visited = SetSequence.fromSet(new HashSet<Node>());
    List<Dart> darts = ListSequence.fromList(new ArrayList<Dart>());
    Graph graph = embeddedGraph.getGraph();
    Node cur = graph.getNode(0);
    Edge prevEdge = null;
    while (!(SetSequence.fromSet(visited).contains(cur))) {
      SetSequence.fromSet(visited).addElement(cur);
      Edge next = ListSequence.fromList(cur.getEdges()).getElement(0);
      if (next == prevEdge) {
        next = ListSequence.fromList(cur.getEdges()).getElement(1);
      }
      ListSequence.fromList(darts).addElement(new Dart(next, cur));
      cur = next.getOpposite(cur);
      prevEdge = next;
    }
    List<Dart> path = ListSequence.fromList(new ArrayList<Dart>());
    boolean inCycle = false;
    for (Dart dart : ListSequence.fromList(darts)) {
      if (dart.getSource() == cur) {
        inCycle = true;
      }
      if (inCycle) {
        ListSequence.fromList(path).addElement(dart);
      }
    }
    Face innerFace = new Face(graph);
    for (Dart dart : ListSequence.fromList(path)) {
      innerFace.addLast(dart);
    }
    Face outerFace = new Face(graph);
    for (Dart dart : ListSequence.fromList(path).reversedList()) {
      outerFace.addLast(new Dart(dart.getEdge(), dart.getTarget()));
    }
    embeddedGraph.addFace(innerFace);
    embeddedGraph.addFace(outerFace);
    embeddedGraph.setOuterFace(outerFace);
  }

  public void connect(EmbeddedGraph embeddedGraph, List<Edge> path, Node start, Node end) {
    Graph graph = embeddedGraph.getGraph();
    DualGraph dualGraph = new DualGraph(embeddedGraph);
    Node dualStart = dualGraph.addRealNode(start);
    Node dualEnd = dualGraph.addRealNode(end);
    List<Edge> dualPath = ShortestPath.getPath(dualGraph, dualStart, dualEnd, Edge.Direction.BOTH);
    List<Node> nodePath = ListSequence.fromList(new ArrayList<Node>());
    List<Face> facePath = ListSequence.fromList(new ArrayList<Face>());
    ListSequence.fromList(nodePath).addElement(start);
    Node cur = dualStart;
    for (Edge edge : ListSequence.fromList(dualPath)) {
      Edge realEdge = MapSequence.fromMap(dualGraph.getEdgesMap()).get(edge);
      if (embeddedGraph.getAdjacentFaces(realEdge) != null) {
        ListSequence.fromList(nodePath).addElement(embeddedGraph.splitEdge(MapSequence.fromMap(dualGraph.getEdgesMap()).get(edge)));
      }
      cur = edge.getOpposite(cur);
      Face curFace = MapSequence.fromMap(dualGraph.getFacesMap()).get(cur);
      if (curFace != null) {
        ListSequence.fromList(facePath).addElement(curFace);
      }
    }
    ListSequence.fromList(nodePath).addElement(end);
    Edge deletedEdge = null;
    List<Edge> newEdges = ListSequence.fromList(new ArrayList<Edge>());
    for (int i = 0; i < ListSequence.fromList(nodePath).count() - 1; i++) {
      Node curStart = ListSequence.fromList(nodePath).getElement(i);
      Node curEnd = ListSequence.fromList(nodePath).getElement(i + 1);
      List<Edge> tempPath = ListSequence.fromList(new ArrayList<Edge>());
      if (i == 0) {
        if (end == ListSequence.fromList(nodePath).getElement(i + 1)) {
          ListSequence.fromList(tempPath).addSequence(ListSequence.fromList(path));
        } else {
          Edge lastEdge = ListSequence.fromList(path).removeLastElement();
          graph.removeEdge(lastEdge);
          deletedEdge = lastEdge;
          ListSequence.fromList(tempPath).addSequence(ListSequence.fromList(path));
          Edge newEdge;
          newEdge = graph.connect(lastEdge.getOpposite(end), curEnd);
          ListSequence.fromList(newEdges).addElement(newEdge);
          ListSequence.fromList(tempPath).addElement(newEdge);
        }
      } else {
        Edge newEdge;
        newEdge = graph.connect(curStart, curEnd);
        ListSequence.fromList(newEdges).addElement(newEdge);
        ListSequence.fromList(tempPath).addElement(newEdge);
      }
      embeddedGraph.splitFace(ListSequence.fromList(facePath).getElement(i), tempPath, curStart, curEnd);
      if (deletedEdge != null) {
        GraphModificationEvent splitEvent = new GraphModificationEvent(GraphModificationEvent.Type.EDGE_SPLITTED, deletedEdge, newEdges);
        graph.getModificationProcessor().fire(splitEvent);
      }
    }
  }
}
