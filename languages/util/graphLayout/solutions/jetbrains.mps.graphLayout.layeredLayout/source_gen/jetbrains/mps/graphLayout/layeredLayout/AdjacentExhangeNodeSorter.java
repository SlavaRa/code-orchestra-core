package jetbrains.mps.graphLayout.layeredLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Edge;
import java.util.List;
import jetbrains.mps.graphLayout.graph.Node;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;

public class AdjacentExhangeNodeSorter implements IOneLayerSorter {
  public AdjacentExhangeNodeSorter() {
  }

  public void sortLayer(int layerToSort, NodeLayeredOrder order, Edge.Direction direction) {
    List<Node> layerOrder = order.getOrder(layerToSort);
    Map<Node, Integer> posInLayer = order.getPosInLayer();
    for (int i = 0; i < ListSequence.fromList(layerOrder).count() - 1; i++) {
      Node first = ListSequence.fromList(layerOrder).getElement(i);
      Node second = ListSequence.fromList(layerOrder).getElement(i + 1);
      int cur = countNumOfCrossings(first, second, posInLayer, direction);
      int candidate = countNumOfCrossings(second, first, posInLayer, direction);
      if (cur > candidate) {
        order.set(layerToSort, first, i + 1);
        order.set(layerToSort, second, i);
      }
    }
  }

  private int countNumOfCrossings(Node first, Node second, Map<Node, Integer> posInLayer, Edge.Direction dir) {
    int numOfCrossings = 0;
    for (Edge firstEdge : ListSequence.fromList(first.getEdges(dir))) {
      for (Edge secondEdge : ListSequence.fromList(second.getEdges(dir))) {
        if (MapSequence.fromMap(posInLayer).get(firstEdge.getTarget(dir)) > MapSequence.fromMap(posInLayer).get(secondEdge.getTarget(dir))) {
          numOfCrossings++;
        }
      }
    }
    return numOfCrossings;
  }
}
