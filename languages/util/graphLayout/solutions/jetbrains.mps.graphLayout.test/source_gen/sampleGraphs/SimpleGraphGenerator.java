package sampleGraphs;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class SimpleGraphGenerator extends BasicGraphGenerator {
  private static int MAX_EDGE_GEN = 100;

  private int[] myComponents;

  public SimpleGraphGenerator(int numNodes, int minEdges, int maxEdges) {
    super(numNodes, minEdges, maxEdges);
  }

  @Override
  protected Edge generateEdge(Graph graph) {
    for (int iter = 0; iter < MAX_EDGE_GEN; iter++) {
      Node source = graph.getNode(random().nextInt(getNumNodes()));
      Node target = graph.getNode(random().nextInt(getNumNodes()));
      if (canConnect(source, target)) {
        return graph.connect(source, target);
      }
    }
    for (Node source : ListSequence.fromList(graph.getNodes())) {
      for (Node target : ListSequence.fromList(graph.getNodes())) {
        if (canConnect(source, target)) {
          return graph.connect(source, target);
        }
      }
    }
    return null;
  }

  private boolean canConnect(final Node source, Node target) {
    List<Node> sourceComp = ListSequence.fromList(source.getEdges()).select(new ISelector<Edge, Node>() {
      public Node select(Edge edge) {
        return edge.getOpposite(source);
      }
    }).toListSequence();
    if (source != target && !(ListSequence.fromList(sourceComp).contains(target))) {
      return true;
    } else {
      return false;
    }
  }

  @Override
  protected Graph generateGraph() {
    int numNodes = getNumNodes();
    if (getNumEdges() > numNodes * (numNodes - 1) / 2) {
      return null;
    }
    myComponents = new int[numNodes];
    for (int i = 0; i < numNodes; i++) {
      myComponents[i] = i;
    }
    return super.generateGraph();
  }
}
