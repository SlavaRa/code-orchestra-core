package graphTest;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Graph;
import sampleGraphs.RandomGraphGenerator;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Random;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.io.PrintWriter;
import visualization.GraphIO;
import jetbrains.mps.graphLayout.algorithms.MinCostMaxFlow;
import jetbrains.mps.graphLayout.algorithms.MinCostMaxFlowCycleCancelling;
import jetbrains.mps.graphLayout.algorithms.MinCostMaxFlowWithPotentials;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class CompareFlowStressTest {
  public CompareFlowStressTest() {
  }

  public static void main(String[] args) throws Exception {
    String fileName = "C:\\work\\compareFlow.txt";
    int numNodes = Integer.parseInt(args[0]);
    int numEdges = Integer.parseInt(args[1]);
    int numIter = Integer.parseInt(args[2]);
    for (int iter = 0; iter < numIter; iter++) {
      System.out.println("ITERATION: " + iter);
      Graph graph = RandomGraphGenerator.generateSimpleConnectedGraph(numNodes, numEdges);
      Node source = graph.createNode();
      Node target = graph.createNode();
      int n = graph.getNumNodes() / 2;
      int i = 0;
      for (Node node : ListSequence.fromList(graph.getNodes())) {
        if (i < n) {
          graph.connect(source, node);
        } else {
          graph.connect(node, target);
        }
        i++;
      }
      Random rand = new Random();
      Map<Edge, Integer> capacity = MapSequence.fromMap(new HashMap<Edge, Integer>());
      Map<Edge, Integer> cost = MapSequence.fromMap(new HashMap<Edge, Integer>());
      for (Edge edge : ListSequence.fromList(graph.getEdges())) {
        MapSequence.fromMap(capacity).put(edge, rand.nextInt(10));
        MapSequence.fromMap(cost).put(edge, rand.nextInt(100));
      }
      PrintWriter out = new PrintWriter(fileName);
      GraphIO.writeGraph(graph, out);
      for (Edge edge : ListSequence.fromList(graph.getEdges())) {
        out.println(edge + " " + MapSequence.fromMap(capacity).get(edge) + " " + MapSequence.fromMap(cost).get(edge));
      }
      out.close();
      Map<Edge, Integer> flow = MinCostMaxFlow.getFlow(graph, source, target, capacity, cost);
      Map<Edge, Integer> cycleFlow = MinCostMaxFlowCycleCancelling.getFlow(graph, source, target, capacity, cost);
      Map<Edge, Integer> potFlow = MinCostMaxFlowWithPotentials.getFlow(graph, source, target, capacity, cost);
      int flowSize = getFlowSize(flow, source);
      int cycleFlowSize = getFlowSize(cycleFlow, source);
      int potFlowSize = getFlowSize(potFlow, source);
      System.out.println("flow: " + flowSize + " cycle: " + cycleFlowSize + " pot: " + potFlowSize);
      /*
        System.out.println("common:");
        printFlow(flow);
        System.out.println("cycle");
        printFlow(cycleFlow);
        System.out.println("pot:");
        printFlow(potFlow);
      */
      if (flowSize != cycleFlowSize || flowSize != potFlowSize) {
        break;
      }
    }
  }

  private static int getFlowSize(Map<Edge, Integer> flow, Node source) {
    int flowSize = 0;
    for (Edge edge : ListSequence.fromList(source.getOutEdges())) {
      flowSize += MapSequence.fromMap(flow).get(edge);
    }
    return flowSize;
  }

  public static void printFlow(Map<Edge, Integer> flow) {
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(flow).keySet())) {
      int edgeFlow = MapSequence.fromMap(flow).get(edge);
      if (edgeFlow != 0) {
        System.out.println(edge + ": " + edgeFlow);
      }
    }
  }
}
