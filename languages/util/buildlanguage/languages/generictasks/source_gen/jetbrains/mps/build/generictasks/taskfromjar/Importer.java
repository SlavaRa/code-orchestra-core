package jetbrains.mps.build.generictasks.taskfromjar;

/*Generated by MPS */

import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.LinkedHashMap;

public class Importer<T> {
  private final List<ClassInfo> myQueue = new LinkedList<ClassInfo>();
  private final Map<Class, T> myMap = new LinkedHashMap<Class, T>();
  private final Importer.IClassInfoProvider myProvider;
  private final Map<String, T> myExisting;

  public Importer(List<ClassInfo> toImport, Map<String, T> existing, Importer.IClassInfoProvider provider) {
    this.myQueue.addAll(toImport);
    this.myProvider = provider;
    this.myExisting = existing;
  }

  public void importAll(Importer.IBuilder<T> builder) {
    for (ClassInfo ci : this.myQueue) {
      Importer.this.createDeclaration(builder, ci);
    }
    Importer.this.importDeclarations(this.myQueue, builder);
  }

  private void importDeclarations(List<ClassInfo> toImport, Importer.IBuilder<T> builder) {
    if (toImport.isEmpty()) {
      return;
    }
    List<ClassInfo> toImportLater = new LinkedList<ClassInfo>();
    for (ClassInfo ci : toImport) {
      T declaration = this.myMap.get(ci.getDeclarationClass());
      Class parentClass = ci.getParentClass();
      if ((parentClass != null) && !(parentClass.getName().equals(Object.class.getName()))) {
        Importer.this.getDeclarationOrCreateItIfMissing(parentClass, builder, toImportLater);
        builder.addParent(declaration, this.myMap.get(parentClass));
      }
      for (Class in : ci.getInterfaces()) {
        Importer.this.getDeclarationOrCreateItIfMissing(in, builder, toImportLater);
        builder.addInterface(declaration, this.myMap.get(in));
      }
      for (Object attr : ci.getAttributes()) {
        builder.addAttribute(declaration, (ClassInfo.MyAttribute) attr);
      }
      for (Object n : ci.getNesteds()) {
        Class<?> nestedClass = ((ClassInfo.Nested) n).getNestedClass();
        Importer.this.getDeclarationOrCreateItIfMissing(nestedClass, builder, toImportLater);
        builder.addNested(declaration, this.myMap.get(nestedClass), (ClassInfo.Nested) n);
      }
    }
    Importer.this.importDeclarations(toImportLater, builder);
  }

  public T createDeclaration(Importer.IBuilder<T> builder, ClassInfo ci) {
    T decl;
    if (this.myExisting.containsKey(ci.getDeclarationClass().getName())) {
      decl = this.myExisting.get(ci.getDeclarationClass().getName());
      builder.updateDeclaration(decl, ci);
    } else {
      decl = builder.createDeclaration(ci);
    }
    this.myMap.put(ci.getDeclarationClass(), decl);
    return decl;
  }

  private void getDeclarationOrCreateItIfMissing(Class clazz, Importer.IBuilder<T> builder, List<ClassInfo> toAddLater) {
    if (!(this.myMap.containsKey(clazz))) {
      ClassInfo classInfo = this.myProvider.createClassInfo(clazz);
      Importer.this.createDeclaration(builder, classInfo);
      if (!(this.myExisting.containsKey(classInfo.getDeclarationClass().getName()))) {
        toAddLater.add(classInfo);
      }
    }
  }

  public static interface IBuilder<T> {
    public T createDeclaration(ClassInfo ci);
    public void addParent(T declaration, T parent);
    public void addInterface(T declaration, T interfaceDeclaration);
    public void addAttribute(T declaration, ClassInfo.MyAttribute attribute);
    public void addNested(T declaration, T nestedDeclaration, ClassInfo.Nested nested);
    public void updateDeclaration(T declaration, ClassInfo ci);
  }

  public static interface IClassInfoProvider {
    public ClassInfo createClassInfo(Class clazz);
  }
}
