package jetbrains.mps.build.generictasks.taskfromjar;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.Set;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.jar.JarFile;
import java.util.Arrays;
import java.util.List;
import java.io.IOException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.DataType;
import java.util.LinkedList;
import org.apache.tools.ant.taskdefs.ConditionTask;
import org.apache.tools.ant.taskdefs.EchoXML;
import java.util.Enumeration;
import java.util.jar.JarEntry;
import java.util.Collections;
import java.io.FileNotFoundException;
import java.io.File;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.MalformedURLException;
import java.io.InputStream;
import org.objectweb.asm.ClassReader;

public class Scanner {
  private static final Logger LOG = Logger.getLogger(Scanner.class);
  private static final String CLASSFILE_EXT = ".class";
  public static final String LIB_ANT_JAR = "/lib/ant.jar";
  public static final String LIB_ANT_JUNIT_JAR = "/lib/ant-junit.jar";
  private static final String PROPERTY_EXT = "org/apache/tools/ant/taskdefs/defaults.properties";

  private final Set<ClassInfo> myRoots = new HashSet<ClassInfo>();
  private final Set<String> mySrcJars = new LinkedHashSet<String>();
  private String myAntPath;
  private final Set<JarFile> myJarFiles = new LinkedHashSet<JarFile>();
  private ClassLoader myClassLoader;
  private NamesMap myNamesMap = new NamesMap();

  public Scanner(String antPath, String... srcJars) {
    this.myAntPath = antPath;
    this.mySrcJars.addAll(Arrays.asList(srcJars));
  }

  public List<ClassInfo> scan() throws IOException, ClassNotFoundException {
    this.myClassLoader = Scanner.createClassLoader(this.myAntPath, this.mySrcJars.toArray(new String[this.mySrcJars.size()]));
    JarFile antJar = new JarFile(this.myAntPath + Scanner.LIB_ANT_JAR);
    this.getNamesMap(antJar);
    for (String srcJar : this.mySrcJars) {
      JarFile jarFile = new JarFile(srcJar);
      this.myJarFiles.add(jarFile);
      this.getNamesMap(jarFile);
    }
    Class<Task> taskClass = (Class<Task>) this.myClassLoader.loadClass(Task.class.getName());
    Class<DataType> datatypeClass = (Class<DataType>) this.myClassLoader.loadClass(DataType.class.getName());
    this.myRoots.add(new ClassInfo(taskClass));
    this.myRoots.add(new ClassInfo(datatypeClass));
    List<ClassInfo> toImport = new LinkedList<ClassInfo>();
    for (JarFile srcJar : this.myJarFiles) {
      Set<ClassInfo<? extends Task>> taskClasses = Scanner.getTaskClasses(srcJar, this.myClassLoader, taskClass);
      if (antJar.getName().equals(srcJar.getName())) {
        taskClasses.add(new ClassInfo(this.myClassLoader.loadClass(ConditionTask.class.getName())));
        taskClasses.add(new ClassInfo(this.myClassLoader.loadClass(EchoXML.class.getName())));
      }
      Set<ClassInfo<? extends DataType>> datatypeClasses = Scanner.getTaskClasses(srcJar, this.myClassLoader, datatypeClass);
      toImport.addAll(taskClasses);
      toImport.addAll(datatypeClasses);
    }
    return toImport;
  }

  private void getNamesMap(JarFile jarFile) {
    Enumeration<JarEntry> entries = jarFile.entries();
    if (!(entries.hasMoreElements())) {
      return;
    }
    do {
      JarEntry e = entries.nextElement();
      if (e.getName().endsWith(Scanner.PROPERTY_EXT)) {
        try {
          this.myNamesMap.parsePropertyFile(jarFile.getInputStream(e));
        } catch (IOException e1) {
          Scanner.LOG.error(e1);
        }
      }
    } while (entries.hasMoreElements());
  }

  public NamesMap getNamesMap() {
    return this.myNamesMap;
  }

  public Set<ClassInfo> getRoots() {
    return Collections.unmodifiableSet(this.myRoots);
  }

  public Importer.IClassInfoProvider createClassInfoProvider() {
    return new Importer.IClassInfoProvider() {
      public ClassInfo createClassInfo(Class clazz) {
        return Scanner.getClassInfo(clazz);
      }
    };
  }

  public ClassInfo createClassInfo(String className) throws ClassNotFoundException, FileNotFoundException {
    this.myClassLoader = Scanner.createClassLoader(this.myAntPath, this.mySrcJars.toArray(new String[this.mySrcJars.size()]));
    Class<?> clazz = this.myClassLoader.loadClass(className);
    return Scanner.getClassInfo(clazz, this.myJarFiles.toArray(new JarFile[this.myJarFiles.size()]));
  }

  public static ClassLoader createClassLoader(String antPath, String[] classpath) throws FileNotFoundException {
    String antJarPath = antPath + Scanner.LIB_ANT_JAR;
    File f = new File(antJarPath);
    if (!(f.exists())) {
      throw new FileNotFoundException("Path " + antJarPath + " does not exist.");
    }
    for (String dir : classpath) {
      f = new File(dir);
      if (!(f.exists())) {
        throw new FileNotFoundException("Path " + dir + " does not exist.");
      }
    }
    try {
      URL[] urls = new URL[classpath.length + 1];
      urls[0] = new URL("file:///" + antJarPath);
      int i = 1;
      for (String dir : classpath) {
        urls[i] = new URL("file:///" + dir);
        i++;
      }
      return new URLClassLoader(urls);
    } catch (MalformedURLException e) {
      Scanner.LOG.error(e);
      return null;
    }
  }

  /*package*/ static <T> Set<ClassInfo<? extends T>> getTaskClasses(JarFile jarFile, ClassLoader loader, Class<? extends T> parentClass) {
    Enumeration<JarEntry> entries = jarFile.entries();
    if (!(entries.hasMoreElements())) {
      return Collections.EMPTY_SET;
    }
    Set<ClassInfo<? extends T>> taskClasses = new LinkedHashSet<ClassInfo<? extends T>>();
    do {
      JarEntry e = entries.nextElement();
      String name = e.getName();
      if (!(name.endsWith(Scanner.CLASSFILE_EXT))) {
        continue;
      }
      try {
        InputStream stream = jarFile.getInputStream(e);
        ClassReader classReader = new ClassReader(stream);
        name = classReader.getClassName();
        name = Scanner.replaceSlashes(name);
        Class<? extends T> clazz = (Class<? extends T>) loader.loadClass(name).asSubclass(parentClass);
        if (clazz.equals(parentClass)) {
          continue;
        }
        ClassInfo<T> classInfo = new ClassInfo<T>(clazz, classReader);
        taskClasses.add(classInfo);
      } catch (ClassNotFoundException e1) {
        Scanner.LOG.error(e1);
      } catch (ClassCastException e1) {
      } catch (NoClassDefFoundError e1) {
      } catch (IOException e1) {
        Scanner.LOG.error(e1);
      }
    } while (entries.hasMoreElements());
    return taskClasses;
  }

  private static String getClassName(String name) {
    return Scanner.replaceSlashes(name).substring(0, name.length() - Scanner.CLASSFILE_EXT.length());
  }

  private static String replaceSlashes(String name) {
    return name.replace("/", ".").replace("\\", ".");
  }

  /*package*/ static ClassInfo getClassInfo(Class clazz, JarFile... jarFiles) {
    for (JarFile srcJar : jarFiles) {
      ClassInfo classInfo = Scanner.getClassInfo(clazz, srcJar);
      if (classInfo != null) {
        return classInfo;
      }
    }
    return new ClassInfo(clazz);
  }

  private static ClassInfo getClassInfo(Class clazz, JarFile jarFile) {
    Enumeration<JarEntry> entries = jarFile.entries();
    do {
      JarEntry e = entries.nextElement();
      if (!(e.getName().endsWith(Scanner.CLASSFILE_EXT))) {
        continue;
      }
      if (clazz.getName().equals(Scanner.getClassName(e.getName()))) {
        try {
          return new ClassInfo(clazz, new ClassReader(jarFile.getInputStream(e)));
        } catch (IOException e1) {
          break;
        }
      }
    } while (entries.hasMoreElements());
    return null;
  }

  public static String getShortClassName(Class<?> clazz) {
    String fullName = clazz.getName().toLowerCase();
    int pos2 = fullName.lastIndexOf(".");
    fullName = fullName.substring(pos2 + 1);
    if (fullName.contains("$")) {
      fullName = fullName.substring(fullName.lastIndexOf("$") + 1);
    }
    return fullName;
  }
}
