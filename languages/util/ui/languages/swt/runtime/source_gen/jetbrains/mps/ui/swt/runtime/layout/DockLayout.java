package jetbrains.mps.ui.swt.runtime.layout;

/*Generated by MPS */

import org.eclipse.swt.widgets.Layout;
import org.eclipse.swt.graphics.Point;
import java.util.List;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.graphics.Rectangle;
import org.eclipse.swt.SWT;
import java.util.ArrayList;

public class DockLayout extends Layout {
  private static Point ZERO = new Point(0, 0);

  private List<Control> north;
  private List<Control> south;
  private List<Control> east;
  private List<Control> west;

  public DockLayout() {
  }

  protected Point computeSize(Composite comp, int wHint, int hHint, boolean flushCache) {
    Control center = this.collectControls(comp);
    int width = this.size(this.west, flushCache).x + this.size(center, flushCache).x + this.size(this.east, flushCache).x;
    width = Math.max(width, this.size(this.north, flushCache).x);
    width = Math.max(width, this.size(this.south, flushCache).x);
    int mheight = Math.max(this.size(this.east, flushCache).y, Math.max(this.size(center, flushCache).y, this.size(this.west, flushCache).y));
    int height = this.size(this.north, flushCache).y + mheight + this.size(this.south, flushCache).y;
    return new Point(Math.max(width, wHint), Math.max(height, hHint));
  }

  protected void layout(Composite comp, boolean flushCache) {
    Rectangle carea = comp.getClientArea();
    Rectangle insides = new Rectangle(carea.x, carea.y, carea.width, carea.height);
    Control center = null;
    for (Control child : comp.getChildren()) {
      DockLayoutData bd = (DockLayoutData) child.getLayoutData();
      if (DockLayoutData.CENTER != bd) {
        this.placeControl(child, bd, insides, flushCache);
      } else if (center == null) {
        center = child;
      }
    }
    this.placeControl(center, DockLayoutData.CENTER, insides, flushCache);
  }

  @Override
  protected boolean flushCache(Control comp) {
    return super.flushCache(comp);
  }

  private void placeControl(Control ctrl, DockLayoutData border, Rectangle insides, boolean flushCache) {
    if (ctrl == null) {
      return;
    }
    Point pt = this.size(ctrl, flushCache);
    switch (border) {
      case NORTH:
        ctrl.setBounds(insides.x, insides.y, insides.width - insides.x, pt.y);
        insides.y += pt.y;
        break;
      case SOUTH:
        ctrl.setBounds(insides.x, insides.height - pt.y, insides.width - insides.x, pt.y);
        insides.height -= pt.y;
        break;
      case EAST:
        ctrl.setBounds(insides.width - pt.x, insides.y, pt.x, insides.height - insides.y);
        insides.width -= pt.x;
        break;
      case WEST:
        ctrl.setBounds(insides.x, insides.y, pt.x, insides.height - insides.y);
        insides.x += pt.x;
        break;
      case CENTER:
        ctrl.setBounds(insides.x, insides.y, insides.width - insides.x, insides.height - insides.y);
        break;
      default:
        throw new RuntimeException("Unknown constant in BorderData");
    }
  }

  private Point size(Control ctrl, boolean flushCache) {
    return (ctrl != null ?
      ctrl.computeSize(SWT.DEFAULT, SWT.DEFAULT, flushCache) :
      DockLayout.ZERO
    );
  }

  private Point size(List<Control> ctrls, boolean flushCache) {
    switch ((ctrls == null ?
      0 :
      ctrls.size()
    )) {
      case 0:
        return DockLayout.ZERO;
      case 1:
        return this.size(ctrls.get(0), flushCache);
      default:
        Point res = new Point(0, 0);
        for (Control ctrl : ctrls) {
          Point sz = ctrl.computeSize(SWT.DEFAULT, SWT.DEFAULT, flushCache);
          res.x += sz.x;
          res.y += sz.y;
        }
        return res;
    }
  }

  private Control collectControls(Composite comp) {
    this.north = null;
    this.south = null;
    this.east = null;
    this.west = null;
    Control center = null;
    for (Control child : comp.getChildren()) {
      switch ((DockLayoutData) child.getLayoutData()) {
        case NORTH:
          this.north = this.addControl(child, this.north);
          break;
        case SOUTH:
          this.south = this.addControl(child, this.south);
          break;
        case EAST:
          this.east = this.addControl(child, this.east);
          break;
        case WEST:
          this.west = this.addControl(child, this.west);
          break;
        case CENTER:
          if (center == null) {
            center = child;
          }
          break;
        default:
          throw new RuntimeException("Unknown constant in BorderData");
      }
    }
    return center;
  }

  private List<Control> addControl(Control ctrl, List<Control> list) {
    if (list == null) {
      list = new ArrayList<Control>();
    }
    list.add(ctrl);
    return list;
  }
}
