package jetbrains.mps.ui.swt.runtime.layout;

/*Generated by MPS */

import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.layout.GridData;
import java.util.Vector;
import java.util.List;
import java.util.Iterator;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.SWT;

public class GridLayoutUtil {
  private static String PADDING = "jetbrains.mps.ui.swt.runtime.PADDING";
  private static Object FLAG = new Object();

  public GridLayoutUtil() {
  }

  public static void setCell(Control control, int xcell, int ycell) {
    Control[] controls = control.getParent().getChildren();
    GridLayout layout = (GridLayout) control.getParent().getLayout();
    int columns = Math.max(1, layout.numColumns);
    GridData cdata = (GridData) control.getLayoutData();
    int width = Math.max(1, cdata.horizontalSpan);
    int height = Math.max(1, cdata.verticalSpan);
    int newColumns = Math.max(columns, xcell + width);
    int newRows = Math.max(1, ycell + height);
    Vector<Control> matrix = new Vector<Control>();
    matrix.setSize(newRows * newColumns);
    GridLayoutUtil.fillMatrix(matrix, controls, control, columns, newColumns, newRows);
    GridLayoutUtil.moveControl(control, ycell * newColumns + xcell, matrix);
    GridLayoutUtil.setControl(matrix, newColumns, control, xcell, ycell, width, height);
    GridLayoutUtil.fillPads(control.getParent(), matrix, newColumns);
    layout.numColumns = newColumns;
  }

  private static void dump(List<Control> matrix, int cols) {
    for (Iterator<Control> it = matrix.iterator(); it.hasNext();) {
      System.out.print("[");
      String sep = "";
      for (int i = 0; i < cols; i++) {
        Control c = it.next();
        System.out.print(sep + String.valueOf(c));
        sep = ", ";
      }
      System.out.println("]");
    }
  }

  private static void setControl(Vector<Control> matrix, int columns, Control control, int x, int y, int w, int h) {
    for (int i = x; i - x < w; ++i) {
      for (int j = y; j - y < h; ++j) {
        if (matrix.get(j * columns + i) != null) {
          GridLayoutUtil.clearPad(matrix, columns, i, j);
        } else if (i == x && i > 0) {
          for (int k = i - 1; k >= 0; --k) {
            Control mbpad = matrix.get(j * columns + k);
            if (mbpad != null && FLAG.equals(mbpad.getData(PADDING))) {
              GridLayoutUtil.clearPad(matrix, columns, x - 1, j);
              break;
            }
          }
        }
        matrix.set(j * columns + i, control);
      }
    }
  }

  private static void fillPads(Composite parent, Vector<Control> matrix, int columns) {
    int rows = matrix.size() / columns;
    for (int i = 0; i < columns; ++i) {
      for (int j = 0; j < rows; ++j) {
        Control c = matrix.get(j * columns + i);
        if (c == null) {
          fillLargestHole(parent, matrix, columns, i, j);
        }
      }
    }
  }

  private static void fillLargestHole(Composite parent, Vector<Control> matrix, int columns, int left, int top) {
    int rows = matrix.size() / columns;
    int right = left + 1;
    while (right < columns && matrix.get(top * columns + right) == null) {
      ++right;
    }
    int bottom = top + 1;
with_bottom:
    while (bottom < rows) {
      for (int i = left; i < right; ++i) {
        if (matrix.get(bottom * columns + i) != null) {
          break with_bottom;
        }
      }
      ++bottom;
    }
    Control pad = GridLayoutUtil.createPad(parent, top * columns + left, matrix, right - left, bottom - top);
    for (int i = left; i < right; ++i) {
      for (int j = top; j < bottom; ++j) {
        matrix.set(j * columns + i, pad);
      }
    }
  }

  private static Control createPad(Composite parent, int pos, Vector<Control> matrix, int hspan, int vspan) {
    Label pad = new Label(parent, SWT.NONE);
    pad.setText("*");
    GridData data = new GridData();
    pad.setLayoutData(data);
    data.horizontalSpan = hspan;
    data.verticalSpan = vspan;
    GridLayoutUtil.moveControl(pad, pos, matrix);
    return pad;
  }

  private static void clearPad(Vector<Control> matrix, int columns, int x, int y) {
    Control pad = matrix.get(y * columns + x);
    assert FLAG.equals(pad.getData(PADDING));
    while (x > 0 && matrix.get(y * columns + x - 1) == pad) {
      --x;
    }
    while (y > 0 && matrix.get((y - 1) * columns + x) == pad) {
      --y;
    }
    GridData data = (GridData) pad.getLayoutData();
    int w = data.horizontalSpan;
    int h = data.verticalSpan;
    for (int i = x; i - x < w; ++i) {
      for (int j = y; j - y < h; ++j) {
        matrix.set(j * columns + i, null);
      }
    }
    pad.dispose();
  }

  private static boolean moveControl(Control control, int pos, Vector<Control> matrix) {
    Control prev = null;
    Control next = null;
    for (int z = pos; z >= 0; --z) {
      if ((prev = matrix.get(z)) != null) {
        control.moveBelow(prev);
        break;
      }
    }
    if (prev == null) {
      for (int a = pos; a < matrix.size(); ++a) {
        if ((next = matrix.get(a)) != null) {
          control.moveAbove(next);
          break;
        }
      }
    }
    return next != null || prev != null;
  }

  private static void fillMatrix(Vector<Control> matrix, Control[] controls, Control exclude, int columns, int newColumns, int newRows) {
    int rows = 1;
    int x = 0;
    int y = 0;
    for (Control c : controls) {
      if (exclude == c) {
        continue;
      }
      GridData data = (GridData) c.getLayoutData();
      if (data == null || data.exclude) {
        continue;
      }
      do {
        if (x >= columns) {
          ++y;
          x = 0;
          if (++rows > newRows) {
            newRows = rows;
            matrix.setSize(newRows * newColumns);
          }
        }
        while (x < columns && matrix.get(y * newColumns + x) != null) {
          ++x;
        }
      } while (x >= columns);
      int hspan = Math.max(1, data.horizontalSpan);
      int vspan = Math.max(1, data.verticalSpan);
      rows = Math.max(rows, y + vspan);
      if (rows > newRows) {
        newRows = rows;
        matrix.setSize(newRows * newColumns);
      }
      for (int i = x; i - x < hspan; i++) {
        for (int j = y; j - y < vspan; j++) {
          matrix.set(j * columns + i, c);
        }
      }
      x += hspan;
    }
  }
}
