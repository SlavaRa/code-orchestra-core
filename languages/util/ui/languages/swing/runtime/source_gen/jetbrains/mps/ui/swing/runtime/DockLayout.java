package jetbrains.mps.ui.swing.runtime;

/*Generated by MPS */

import java.awt.LayoutManager;
import java.awt.LayoutManager2;
import java.awt.Dimension;
import java.util.LinkedHashMap;
import java.awt.Component;
import java.util.List;
import java.awt.Container;
import java.awt.Insets;
import java.awt.Rectangle;
import java.util.Map;
import java.util.ArrayList;

public class DockLayout implements LayoutManager, LayoutManager2 {
  private static Dimension ZERO = new Dimension(0, 0);
  private static Dimension MAX = new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);

  private LinkedHashMap<Component, DockLayoutData> componentData = new LinkedHashMap<Component, DockLayoutData>();
  private List<Component> north;
  private List<Component> south;
  private List<Component> east;
  private List<Component> west;

  public DockLayout() {
  }

  public DockLayoutData getConstraints(Component comp) {
    return this.componentData.get(comp);
  }

  public void addLayoutComponent(String string, Component component) {
    this.addLayoutComponent(component, DockLayoutData.fromString(string));
  }

  public void removeLayoutComponent(Component component) {
    synchronized (component.getTreeLock()) {
      this.componentData.remove(component);
    }
  }

  public Dimension preferredLayoutSize(Container container) {
    synchronized (container.getTreeLock()) {
      return this.computeSize(container, true);
    }
  }

  public Dimension minimumLayoutSize(Container container) {
    synchronized (container.getTreeLock()) {
      return this.computeSize(container, false);
    }
  }

  public void layoutContainer(Container container) {
    synchronized (container.getTreeLock()) {
      Insets insets = container.getInsets();
      Rectangle insides = new Rectangle(insets.left, insets.top, container.getWidth() - insets.right, container.getHeight() - insets.bottom);
      Component center = null;
      for (Map.Entry<Component, DockLayoutData> ent : this.componentData.entrySet()) {
        if (DockLayoutData.CENTER != ent.getValue()) {
          this.placeComponent(ent.getKey(), ent.getValue(), insides);
        } else if (center == null) {
          center = ent.getKey();
        }
      }
      this.placeComponent(center, DockLayoutData.CENTER, insides);
    }
  }

  public void addLayoutComponent(Component component, Object object) {
    synchronized (component.getTreeLock()) {
      DockLayoutData bd = (object == null ?
        DockLayoutData.CENTER :
        (DockLayoutData) object
      );
      this.componentData.put(component, bd);
    }
  }

  public Dimension maximumLayoutSize(Container container) {
    return DockLayout.MAX;
  }

  public float getLayoutAlignmentX(Container container) {
    return 0.5f;
  }

  public float getLayoutAlignmentY(Container container) {
    return 0.5f;
  }

  public void invalidateLayout(Container container) {
    //  do nothing 
  }

  private Dimension computeSize(Container container, boolean pref) {
    synchronized (container.getTreeLock()) {
      Component center = this.collectComponents();
      int width = this.size(this.west, pref).width + this.size(center, pref).width + this.size(this.east, pref).width;
      width = Math.max(width, this.size(this.north, pref).width);
      width = Math.max(width, this.size(this.south, pref).width);
      int mHeight = Math.max(this.size(this.east, pref).height, this.size(center, pref).height);
      mHeight = Math.max(mHeight, this.size(this.west, pref).height);
      int height = this.size(this.north, pref).height + mHeight + this.size(this.south, pref).height;
      Insets insets = container.getInsets();
      return new Dimension(width + insets.left + insets.right, height + insets.top + insets.bottom);
    }
  }

  private void placeComponent(Component comp, DockLayoutData border, Rectangle insides) {
    if (comp == null) {
      return;
    }
    Dimension dim = this.size(comp, true);
    switch (border) {
      case NORTH:
        comp.setBounds(insides.x, insides.y, insides.width - insides.x, dim.height);
        insides.y += dim.height;
        break;
      case SOUTH:
        comp.setBounds(insides.x, insides.height - dim.height, insides.width - insides.x, dim.height);
        insides.height -= dim.height;
        break;
      case EAST:
        comp.setBounds(insides.width - dim.width, insides.y, dim.width, insides.height - insides.y);
        insides.width -= dim.width;
        break;
      case WEST:
        comp.setBounds(insides.x, insides.y, dim.width, insides.height - insides.y);
        insides.x += dim.width;
        break;
      case CENTER:
        comp.setBounds(insides.x, insides.y, insides.width - insides.x, insides.height - insides.y);
        break;
      default:
        throw new RuntimeException("Unknown constant in BorderData");
    }
  }

  private Dimension size(Component comp, boolean pref) {
    if (comp == null) {
      return DockLayout.ZERO;
    }
    return (pref ?
      comp.getPreferredSize() :
      comp.getMinimumSize()
    );
  }

  private Dimension size(List<Component> comps, boolean pref) {
    switch ((comps == null ?
      0 :
      comps.size()
    )) {
      case 0:
        return DockLayout.ZERO;
      case 1:
        return this.size(comps.get(0), pref);
      default:
        Dimension res = new Dimension(0, 0);
        for (Component cmp : comps) {
          Dimension dim = (pref ?
            cmp.getPreferredSize() :
            cmp.getMinimumSize()
          );
          res.width += dim.width;
          res.height += dim.height;
        }
        return res;
    }
  }

  private Component collectComponents() {
    this.north = null;
    this.south = null;
    this.east = null;
    this.west = null;
    Component center = null;
    for (Map.Entry<Component, DockLayoutData> ent : this.componentData.entrySet()) {
      switch (ent.getValue()) {
        case NORTH:
          this.north = this.addControl(ent.getKey(), this.north);
          break;
        case SOUTH:
          this.south = this.addControl(ent.getKey(), this.south);
          break;
        case EAST:
          this.east = this.addControl(ent.getKey(), this.east);
          break;
        case WEST:
          this.west = this.addControl(ent.getKey(), this.west);
          break;
        case CENTER:
          if (center == null) {
            center = ent.getKey();
          }
          break;
        default:
          throw new RuntimeException("Unknown constant in DockLayoutData");
      }
    }
    return center;
  }

  private List<Component> addControl(Component ctrl, List<Component> list) {
    if (list == null) {
      list = new ArrayList<Component>();
    }
    list.add(ctrl);
    return list;
  }
}
