package jetbrains.mps.baseLanguage.contracts.generator.template.utils;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.baseLanguage.search.ClassifierAndSuperClassifiersScope;
import jetbrains.mps.baseLanguage.search.IClassifiersSearchScope;

public class ContractsUtils {
  private static final String IMPL_SUFFIX = "Impl";
  private static final String RES_PREFIX = "resultOf_";

  public ContractsUtils() {
  }

  public static List<SNode> getFilteredConditions(SNode method, SNode filter) {
    List<SNode> result = new ArrayList<SNode>();
    for (SNode condition : ListSequence.fromList(getConditions(method))) {
      if (SNodeOperations.getConceptDeclaration(condition) == filter) {
        ListSequence.fromList(result).addElement(condition);
      }
    }
    return result;
  }

  private static List<SNode> getConditions(SNode method) {
    List<SNode> interfaceMethods = getOverridenInterfaceMethod(method);
    List<SNode> resultList = new ArrayList<SNode>();
    for (SNode intMethod : ListSequence.fromList(interfaceMethods)) {
      ListSequence.fromList(resultList).addSequence(ListSequence.fromList(SLinkOperations.getTargets(AttributeOperations.getAttribute(intMethod, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.contracts.structure.MethodConditions"))), "condition", true)));
    }
    return resultList;
  }

  public static boolean needProcessing(SNode method) {
    return ListSequence.fromList(getConditions(method)).isNotEmpty();
  }

  public static String makeImplName(String methodName) {
    return methodName + IMPL_SUFFIX;
  }

  public static String makeResultName(String methodName) {
    return RES_PREFIX + methodName;
  }

  private static List<SNode> getOverridenInterfaceMethod(SNode method) {
    List<SNode> resultList = new ArrayList<SNode>();
    if (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(method), "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
      return resultList;
    }
    SNode parent = SNodeOperations.cast(SNodeOperations.getParent(method), "jetbrains.mps.baseLanguage.structure.ClassConcept");
    ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope(parent, IClassifiersSearchScope.INSTANCE_METHOD);
    List<SNode> overridenMethods = scope.getOverriddenMethods(method);
    for (SNode node : ListSequence.fromList(overridenMethods)) {
      SNode baseMethod = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
      if (SNodeOperations.isInstanceOf(baseMethod, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
        SNode instanceMethod = SNodeOperations.cast(baseMethod, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration");
        if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(instanceMethod), "jetbrains.mps.baseLanguage.structure.Interface")) {
          ListSequence.fromList(resultList).addElement(instanceMethod);
        }
      }
    }
    return resultList;
  }
}
