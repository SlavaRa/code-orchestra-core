package jetbrains.mps.baseLanguage.dates.unittest.tests;

/*Generated by MPS */

import junit.framework.TestCase;
import jetbrains.mps.baseLanguage.dates.runtime.DateTimeOperations;
import org.joda.time.DateTimeFieldType;
import junit.framework.Assert;
import jetbrains.mps.baseLanguage.dates.runtime.CompareType;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import jetbrains.mps.baseLanguage.dates.runtime.DateTimeArithmetics;
import org.joda.time.Period;
import jetbrains.mps.baseLanguage.dates.runtime.InlineDateFormatter;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.DateTimeFormatterBuilder;

public class Round_Test extends TestCase {
  public void test_round() throws Exception {
    Long dt = System.currentTimeMillis();
    Long roundDt = DateTimeOperations.round(dt, DateTimeFieldType.dayOfMonth());
    Assert.assertTrue(DateTimeOperations.compare(dt, CompareType.NE, roundDt, DateTimeFieldType.millisOfSecond()));
  }

  public void test_roundInTwoZones() throws Exception {
    DateTime clockchange = DateTimeOperations.convert(DateTimeOperations.parse("2009-03-29 01:59:00", (MainFormatTable.INSTANCE).getFormatter("date/time"), null, DateTimeZone.forID("Asia/Singapore"), null), DateTimeZone.forID("Asia/Singapore"));
    Assert.assertEquals("2009-03-29 02:00:00", DateTimeOperations.print(DateTimeOperations.round((DateTimeArithmetics.plus(clockchange, Period.minutes(2))), DateTimeFieldType.hourOfDay()), (new InlineDateFormatter() {
      public DateTimeFormatter createFormatter() {
        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();
        builder.append((MainFormatTable.INSTANCE).getFormatter("date/time"));
        return builder.toFormatter();
      }
    }).createFormatter(), null));

    clockchange = DateTimeOperations.convert(DateTimeOperations.parse("2009-03-29 01:59:00", (MainFormatTable.INSTANCE).getFormatter("date/time"), null, DateTimeZone.forID("Europe/Moscow"), null), DateTimeZone.forID("Europe/Moscow"));
    Assert.assertEquals("2009-03-29 03:00:00", DateTimeOperations.print(DateTimeOperations.round((DateTimeArithmetics.plus(clockchange, Period.minutes(3))), DateTimeFieldType.hourOfDay()), (MainFormatTable.INSTANCE).getFormatter("date/time"), null));
  }

  public void test_floor() throws Exception {
    Long dt = System.currentTimeMillis();
    Long roundDownDt = DateTimeOperations.roundFloor(dt, DateTimeFieldType.monthOfYear());
    Assert.assertFalse(DateTimeOperations.compare(dt, CompareType.LT, roundDownDt, DateTimeFieldType.millisOfSecond()));
  }

  public void test_floorInTZ() throws Exception {
    DateTime dt = DateTimeOperations.convert(System.currentTimeMillis(), DateTimeZone.getDefault());
    DateTime rounded = DateTimeOperations.roundFloor(dt, DateTimeFieldType.monthOfYear());
    Assert.assertFalse(DateTimeOperations.compare(dt, CompareType.LT, rounded, DateTimeFieldType.millisOfSecond()));
  }

  public void test_ceiling() throws Exception {
    Long dt = System.currentTimeMillis();
    Long roundUpDt = DateTimeOperations.roundCeiling(dt, DateTimeFieldType.minuteOfHour());
    Assert.assertFalse(DateTimeOperations.compare(dt, CompareType.GT, roundUpDt, DateTimeFieldType.millisOfSecond()));
  }

  public void test_ceilingInTZ() throws Exception {
    DateTime dt = DateTimeOperations.convert(System.currentTimeMillis(), DateTimeZone.getDefault());
    DateTime rounded = DateTimeOperations.roundCeiling(dt, DateTimeFieldType.dayOfMonth());
    Assert.assertFalse(DateTimeOperations.compare(dt, CompareType.GT, rounded, DateTimeFieldType.millisOfSecond()));
  }

  public void test_roundNever() throws Exception {
    Long never = DateTimeOperations.never();
    Long roundDownNever = DateTimeOperations.roundFloor(never, DateTimeFieldType.minuteOfHour());
    Long roundUpNever = DateTimeOperations.roundCeiling(never, DateTimeFieldType.minuteOfHour());
    Assert.assertFalse(DateTimeOperations.compare(roundDownNever, CompareType.GT, never, DateTimeFieldType.millisOfSecond()) || DateTimeOperations.compare(roundUpNever, CompareType.GT, never, DateTimeFieldType.millisOfSecond()));
  }

  public void test_roundNeverInMonaco() throws Exception {
    DateTime never1 = DateTimeOperations.convert(DateTimeOperations.never(), DateTimeZone.forID("Europe/Monaco"));
    Assert.assertTrue(DateTimeOperations.compare(DateTimeOperations.roundFloor(never1, DateTimeFieldType.minuteOfHour()), CompareType.EQ, never1, DateTimeFieldType.millisOfSecond()) && DateTimeOperations.compare(DateTimeOperations.roundCeiling(never1, DateTimeFieldType.minuteOfHour()), CompareType.EQ, never1, DateTimeFieldType.millisOfSecond()));
  }
}
