package jetbrains.mps.baseLanguage.dates.unittest.tests;

/*Generated by MPS */

import junit.framework.TestCase;
import jetbrains.mps.baseLanguage.dates.runtime.DateTimeOperations;
import org.joda.time.DateTimeFieldType;
import junit.framework.Assert;
import org.joda.time.Period;
import org.joda.time.PeriodType;
import jetbrains.mps.baseLanguage.dates.runtime.CompareType;
import jetbrains.mps.baseLanguage.dates.runtime.DateTimeArithmetics;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.DurationFieldType;

public class Property_Test extends TestCase {
  public void test_minute() throws Exception {
    Long month = DateTimeOperations.round(System.currentTimeMillis(), DateTimeFieldType.dayOfMonth());
    Integer expected = 0;
    Assert.assertEquals(expected, DateTimeOperations.get(month, DateTimeFieldType.minuteOfHour()));
  }

  public void test_month() throws Exception {
    Assert.assertTrue(DateTimeOperations.get(System.currentTimeMillis(), DateTimeFieldType.monthOfYear()) < 13);
  }

  public void test_inPropertyOldForInstant() throws Exception {
    Long min27 = DateTimeOperations.convert(Period.seconds(1620));
    Assert.assertTrue(DateTimeOperations.compare(new Period((long) (min27), PeriodType.minutes()), CompareType.EQ, Period.minutes(27)));
    Assert.assertNotNull(DateTimeArithmetics.minus(DateTimeOperations.never(), min27));
    Assert.assertNotNull(new Period((DateTimeArithmetics.minus(DateTimeOperations.never(), min27)).getMillis(), PeriodType.minutes()));
    Assert.assertFalse(DateTimeOperations.compare(new Period((DateTimeArithmetics.minus(DateTimeOperations.never(), min27)).getMillis(), PeriodType.minutes()), CompareType.EQ, Period.minutes(27)));
    Assert.assertTrue(DateTimeOperations.compare(new Period(Math.abs((DateTimeArithmetics.minus(DateTimeOperations.never(), min27)).getMillis()), PeriodType.minutes()), CompareType.EQ, Period.minutes(27)));
  }

  public void test_inPropertyOldForDuration() throws Exception {
    Long dt = DateTimeArithmetics.minus(System.currentTimeMillis(), Period.minutes(27));
    Assert.assertTrue(DateTimeOperations.compare(new Period((DateTimeArithmetics.minus((DateTimeArithmetics.plus(dt, Period.minutes(1620))), dt)).getMillis(), PeriodType.hours()), CompareType.EQ, Period.hours(27)));
    Assert.assertFalse(DateTimeOperations.compare(new Period((DateTimeArithmetics.minus(dt, (DateTimeArithmetics.plus(dt, Period.minutes(1620))))).getMillis(), PeriodType.hours()), CompareType.EQ, Period.hours(27)));
    Assert.assertTrue(DateTimeOperations.compare(new Period(Math.abs((DateTimeArithmetics.minus(dt, (DateTimeArithmetics.plus(dt, Period.minutes(1620))))).getMillis()), PeriodType.hours()), CompareType.EQ, Period.hours(27)));
  }

  public void test_inPropertyOldForInstantFromDatetime() throws Exception {
    DateTime nw = DateTimeOperations.with(DateTimeOperations.convert(System.currentTimeMillis(), DateTimeZone.UTC), DateTimeFieldType.minuteOfHour(), 53);
    DateTime before = DateTimeArithmetics.minus(nw, Period.minutes(27));
    Assert.assertTrue(DateTimeOperations.compare(new Period((long) (DateTimeOperations.convert((DateTimeArithmetics.minus(nw, before)))), PeriodType.minutes()), CompareType.EQ, Period.minutes(27)));
  }

  public void test_inPropertyForDatetime() throws Exception {
    DateTime nw = DateTimeOperations.with(DateTimeOperations.convert(System.currentTimeMillis(), DateTimeZone.UTC), DateTimeFieldType.minuteOfHour(), 53);
    DateTime before = DateTimeArithmetics.minus(nw, Period.minutes(27));
    Assert.assertTrue(DateTimeOperations.compare(nw, CompareType.EQ, before, DateTimeFieldType.hourOfDay()));
    Assert.assertTrue(DateTimeOperations.compare(DateTimeArithmetics.minus(nw, before), CompareType.EQ, Period.minutes(27)));
    Assert.assertTrue(new Period((Period) DateTimeArithmetics.minus(nw, before), PeriodType.minutes()).get(DurationFieldType.minutes()) == 27);
  }
}
