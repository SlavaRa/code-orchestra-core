package jetbrains.mps.nanoc.debug.programState;

/*Generated by MPS */

import jetbrains.mps.debug.api.programState.IStackFrame;
import jetbrains.mps.debug.api.programState.ILocation;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.nanoc.debug.answer.RecordValue;
import jetbrains.mps.debug.api.programState.NullLocation;
import jetbrains.mps.debug.api.programState.IThread;
import java.util.Map;
import jetbrains.mps.debug.api.programState.IWatchable;
import jetbrains.mps.debug.api.programState.IValue;
import java.util.HashMap;
import jetbrains.mps.nanoc.debug.answer.ResultAnswer;
import jetbrains.mps.nanoc.debug.answer.ListValue;
import jetbrains.mps.nanoc.debug.answer.GDBValue;

public class GDBStackFrame implements IStackFrame {
  public static final String FUNCTION = "func";
  public static final String FILE = "file";
  public static final String LINE = "line";
  public static final String LEVEL = "level";
  public static final String LOCALS = "locals";
  public static final String NAME = "name";
  public static final String VALUE = "value";

  private int myLevel;
  private String myRoutine;
  private String myFileAbsolutePath;
  private int myPosition;
  private DefaultThread myThread;
  private ILocation myLocation;
  private List<SimpleVarWatchable> myVariables = new ArrayList<SimpleVarWatchable>();
  private boolean myIsNonProgram = false;

  public GDBStackFrame(RecordValue value, DefaultThread thread, String sourceGen) {
    String s = value.getStringValue(LEVEL);
    myLevel = Integer.parseInt(s);
    myRoutine = value.getStringValue(FUNCTION);
    Integer position = value.getIntegerValue(LINE);
    if (position != null) {
      myPosition = position;
    } else {
      myIsNonProgram = true;
    }
    myFileAbsolutePath = value.getStringValue(FILE);
    myThread = thread;
    if (myIsNonProgram) {
      myLocation = new NullLocation();
    } else {
      myLocation = new GDBLocation(myFileAbsolutePath, myRoutine, myPosition, sourceGen);
    }
  }

  public ILocation getLocation() {
    return myLocation;
  }

  public IThread getThread() {
    return myThread;
  }

  public Map<IWatchable, IValue> getWatchableValues() {
    HashMap<IWatchable, IValue> result = new HashMap<IWatchable, IValue>();
    for (SimpleVarWatchable variable : myVariables) {
      result.put(variable, variable.getValue());
    }
    return result;
  }

  public IValue getValue(IWatchable watchable) {
    for (SimpleVarWatchable variable : myVariables) {
      if (variable == watchable) {
        return variable.getValue();
      }
    }
    return null;
  }

  public List<IWatchable> getVisibleWatchables() {
    return new ArrayList<IWatchable>(myVariables);
  }

  public int getLevel() {
    return myLevel;
  }

  public void fillLocals(ResultAnswer answer) {
    ListValue localsList = (ListValue) answer.getResults().getPropertyValue(LOCALS);
    for (GDBValue value : localsList.getValues()) {
      RecordValue varRecord = (RecordValue) value;
      String varName = varRecord.getStringValue(NAME);
      String varValue = varRecord.getStringValue(VALUE);
      myVariables.add(new SimpleVarWatchable(varName, varValue));
    }
  }

  public boolean isNonProgram() {
    return myIsNonProgram;
  }
}
