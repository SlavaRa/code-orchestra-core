package jetbrains.mps.nanoc.plugin;

/*Generated by MPS */

import jetbrains.mps.execution.api.configurations.BaseMpsBeforeTaskProvider;
import com.intellij.openapi.util.Key;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SNode;
import com.intellij.openapi.project.Project;
import java.util.concurrent.CountDownLatch;
import com.intellij.execution.process.ProcessHandler;
import jetbrains.mps.execution.api.commands.OutputRedirector;
import com.intellij.execution.process.ProcessAdapter;
import com.intellij.execution.process.ProcessEvent;
import com.intellij.execution.process.ProcessOutputTypes;
import java.io.File;
import com.intellij.execution.ExecutionException;

public class CompileWithGcc_BeforeTask extends BaseMpsBeforeTaskProvider<CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask> {
  private static final Key<CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask> KEY = Key.create("jetbrains.mps.nanoc.plugin.CompileWithGcc_BeforeTask");
  private static Logger LOG = Logger.getLogger(CompileWithGcc_BeforeTask.class);

  public CompileWithGcc_BeforeTask() {
    super("Compile with gcc");
  }

  protected CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask createTaskImpl() {
    return new CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask();
  }

  public Key<CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask> getId() {
    return KEY;
  }

  public static class CompileWithGcc_BeforeTask_RunTask extends BaseMpsBeforeTaskProvider.BaseMpsBeforeRunTask {
    private SNode myFile;

    public CompileWithGcc_BeforeTask_RunTask() {
    }

    public boolean configure(SNode file) {
      myFile = file;
      return true;
    }

    public boolean execute(Project project) {
      try {
        // todo show progress window 
        final CountDownLatch countDown = new CountDownLatch(1);
        ProcessHandler process = OutputRedirector.redirect(new Gcc_Command().createProcess(myFile), new ProcessAdapter() {
          @Override
          public void processTerminated(ProcessEvent event) {
            countDown.countDown();
          }

          @Override
          public void onTextAvailable(ProcessEvent event, Key key) {
            if (ProcessOutputTypes.STDERR.equals(key)) {
              LOG.error(event.getText());
            } else {
              LOG.info(event.getText());
            }
          }
        });
        process.startNotify();
        countDown.await();
        return new File(Gcc_Command.getExecutableFile(myFile).getAbsolutePath()).exists();
      } catch (ExecutionException e) {
        LOG.error("", e);
        return false;
      } catch (InterruptedException e) {
        LOG.error("", e);
        return false;
      }
    }
  }
}
