package jetbrains.mps.samples.lambdaCalculus.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractDependentComputation_Runtime;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class LetReferenceTypeComputation_DependentComputation extends AbstractDependentComputation_Runtime {
  public LetReferenceTypeComputation_DependentComputation() {
  }

  public String getConceptFQName() {
    return "jetbrains.mps.samples.lambdaCalculus.structure.LetRef";
  }

  public String getBlockingConceptFQName() {
    return "jetbrains.mps.samples.lambdaCalculus.structure.LambdaExpression";
  }

  public SNode getBlockingNode(SNode node) {
    return SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(SLinkOperations.getTarget(node, "variable", false)), "jetbrains.mps.samples.lambdaCalculus.structure.LetExpression"), "value", true);
  }

  public boolean isBlocking(SNode node) {
    SNode parent = SNodeOperations.getParent(node);
    return SNodeOperations.isInstanceOf(parent, "jetbrains.mps.samples.lambdaCalculus.structure.LetExpression") && SLinkOperations.getTarget(SNodeOperations.cast(parent, "jetbrains.mps.samples.lambdaCalculus.structure.LetExpression"), "value", true) == node;
  }
}
