package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import javax.swing.JPanel;
import jetbrains.mps.ide.ui.MPSTree;
import jetbrains.mps.smodel.SModel;
import java.util.List;
import jetbrains.mps.vcs.diff.oldchanges.OldChange;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import jetbrains.mps.smodel.IOperationContext;
import java.awt.BorderLayout;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import com.intellij.ui.ScrollPaneFactory;
import javax.swing.JSplitPane;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.ide.actions.ExpandAllToolbarAction;
import com.intellij.ide.actions.CollapseAllToolbarAction;
import com.intellij.openapi.actionSystem.CustomShortcutSet;
import com.intellij.openapi.keymap.KeymapManager;
import com.intellij.openapi.actionSystem.IdeActions;
import jetbrains.mps.vcs.diff.DiffBuilder;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.ui.MPSTreeNode;
import jetbrains.mps.ide.projectPane.Icons;
import jetbrains.mps.smodel.SNodeId;
import com.intellij.ide.TreeExpander;
import jetbrains.mps.ide.ui.TextTreeNode;
import jetbrains.mps.util.CollectionUtil;
import jetbrains.mps.vcs.diff.oldchanges.UsedLanguagesChange;
import jetbrains.mps.vcs.diff.oldchanges.AddNodeChange;
import jetbrains.mps.vcs.diff.oldchanges.OldAddRootChange;
import jetbrains.mps.vcs.diff.oldchanges.DeleteNodeChange;
import jetbrains.mps.vcs.diff.oldchanges.MoveNodeChange;
import jetbrains.mps.vcs.diff.oldchanges.SetNodeChange;
import jetbrains.mps.vcs.diff.oldchanges.OldSetPropertyChange;
import jetbrains.mps.vcs.diff.oldchanges.OldSetReferenceChange;
import jetbrains.mps.vcs.diff.oldchanges.ChangeConceptChange;

/*package*/ class OldModelDifferenceComponent extends JPanel {
  private OldModelChangesTree myModelTree;
  private MPSTree myChangesTree = new OldModelDifferenceComponent.MyChangesTree();
  private SModel myNewModel;
  private List<OldChange> myChanges;
  private ActionToolbar myModelTreeToolBar;
  private DefaultActionGroup myModelTreeActionGroup;
  private ActionToolbar myChangesTreeToolBar;
  private DefaultActionGroup myChangesTreeActionGroup;
  private IOperationContext myContext;

  public OldModelDifferenceComponent(IOperationContext context) {
    setLayout(new BorderLayout());
    myContext = context;
    myModelTree = new OldModelDifferenceComponent.MyModelTree(context);
    myModelTreeActionGroup = new DefaultActionGroup();
    myChangesTreeActionGroup = new DefaultActionGroup();
    createToolBarAndActions(myModelTree, myModelTreeActionGroup, "Model");
    createToolBarAndActions(myChangesTree, myChangesTreeActionGroup, "Changes");
    myModelTreeToolBar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, myModelTreeActionGroup, true);
    myChangesTreeToolBar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, myChangesTreeActionGroup, true);
    myModelTreeToolBar.setLayoutPolicy(ActionToolbar.AUTO_LAYOUT_POLICY);
    myChangesTreeToolBar.setLayoutPolicy(ActionToolbar.AUTO_LAYOUT_POLICY);
    JPanel modelPanel = new JPanel(new BorderLayout());
    modelPanel.add(myModelTreeToolBar.getComponent(), BorderLayout.NORTH);
    modelPanel.add(ScrollPaneFactory.createScrollPane(myModelTree), BorderLayout.CENTER);
    JPanel changesPanel = new JPanel(new BorderLayout());
    changesPanel.add(myChangesTreeToolBar.getComponent(), BorderLayout.NORTH);
    changesPanel.add(ScrollPaneFactory.createScrollPane(myChangesTree), BorderLayout.CENTER);
    JSplitPane splitter = new JSplitPane(JSplitPane.VERTICAL_SPLIT, modelPanel, changesPanel);
    splitter.setDividerLocation(500);
    add(splitter, BorderLayout.CENTER);
    updateView();
  }

  public OldModelChangesTree getModelTree() {
    return myModelTree;
  }

  private void createToolBarAndActions(MPSTree tree, DefaultActionGroup actionGroup, String name) {
    OldModelDifferenceComponent.MyTreeExpander treeExpander = new OldModelDifferenceComponent.MyTreeExpander(tree);
    AnAction expandAllAction = new ExpandAllToolbarAction(treeExpander, "Expand " + name + " Tree");
    AnAction collapseAllAction = new CollapseAllToolbarAction(treeExpander, "Collapse " + name + " Tree");
    collapseAllAction.registerCustomShortcutSet(new CustomShortcutSet(KeymapManager.getInstance().getActiveKeymap().getShortcuts(IdeActions.ACTION_COLLAPSE_ALL)), tree);
    expandAllAction.registerCustomShortcutSet(new CustomShortcutSet(KeymapManager.getInstance().getActiveKeymap().getShortcuts(IdeActions.ACTION_EXPAND_ALL)), tree);
    actionGroup.add(expandAllAction);
    actionGroup.add(collapseAllAction);
  }

  public OldModelDifferenceComponent showDifference(SModel oldModel, SModel newModel) {
    DiffBuilder builder = new DiffBuilder(oldModel, newModel);
    final List<OldChange> changes = builder.getChanges();
    return showDifference(oldModel, newModel, changes);
  }

  public OldModelDifferenceComponent showDifference(SModel oldModel, SModel newModel, List<OldChange> changes) {
    myNewModel = newModel;
    myModelTree.showDifference(oldModel, newModel, changes);
    myChanges = changes;
    updateView();
    return this;
  }

  /*package*/ void updateView() {
    myChangesTree.rebuildNow();
    myChangesTree.expandRoot();
    myModelTree.rebuildNow();
    myModelTree.expandRoot();
  }

  protected void doubleClickOnNode(final SNode node) {
  }

  public void addAction(AnAction action) {
    myModelTreeActionGroup.add(action);
    myModelTreeToolBar.updateActionsImmediately();
  }

  private class ChangeNode extends MPSTreeNode {
    private OldChange myChange;

    public ChangeNode(OldChange change) {
      super(change, null);
      myChange = change;
      setNodeIdentifier(myChange.toString());
      setIcon(Icons.DEFAULT_ICON);
    }

    public void doubleClick() {
      SNodeId affectedNode = myChange.getAffectedNodeId();
      myModelTree.expandNode(affectedNode);
    }

    public boolean isLeaf() {
      return true;
    }
  }

  private class MyTreeExpander implements TreeExpander {
    private MPSTree myTree;

    public MyTreeExpander(MPSTree tree) {
      myTree = tree;
    }

    public void expandAll() {
      myTree.expandAll();
    }

    public boolean canExpand() {
      return true;
    }

    public void collapseAll() {
      MPSTreeNode root = myModelTree.getRootNode();
      int childCount = root.getChildCount();
      for (int i = 0; i < childCount; i++) {
        myModelTree.collapseAll((MPSTreeNode) root.getChildAt(i));
      }
    }

    public boolean canCollapse() {
      return true;
    }
  }

  private class MyChangesTree extends MPSTree {
    private MyChangesTree() {
    }

    private <C extends OldChange> TextTreeNode getChangeTypeSubtree(Class<C> changeClass, String title) {
      List<C> filteredChanges = CollectionUtil.filter(changeClass, myChanges);
      if (!(filteredChanges.isEmpty())) {
        TextTreeNode changesNode = new TextTreeNode(title + " (" + filteredChanges.size() + ")");
        for (C change : filteredChanges) {
          changesNode.add(new OldModelDifferenceComponent.ChangeNode(change));
        }
        return changesNode;
      }
      return null;
    }

    private <C extends OldChange> void addSubtree(TextTreeNode root, Class<C> changeClass, String title) {
      TextTreeNode subtree = getChangeTypeSubtree(changeClass, title);
      if (subtree != null) {
        root.add(subtree);
      }
    }

    protected MPSTreeNode rebuild() {
      if (myNewModel == null) {
        return new TextTreeNode("No Changes To Display");
      } else {
        TextTreeNode changes = new TextTreeNode("Changes");
        addSubtree(changes, UsedLanguagesChange.class, "Used Languages");
        addSubtree(changes, AddNodeChange.class, "Add Node");
        addSubtree(changes, OldAddRootChange.class, "Add Root");
        addSubtree(changes, DeleteNodeChange.class, "Delete Node");
        addSubtree(changes, MoveNodeChange.class, "Move Node");
        addSubtree(changes, SetNodeChange.class, "Set Node");
        addSubtree(changes, OldSetPropertyChange.class, "Set Property");
        addSubtree(changes, OldSetReferenceChange.class, "Set Reference");
        addSubtree(changes, ChangeConceptChange.class, "Change Concept");
        return changes;
      }
    }
  }

  private class MyModelTree extends OldModelChangesTree {
    public MyModelTree(IOperationContext context) {
      super(context);
    }

    @Override
    protected void doubleClickOnNode(SNode node) {
      OldModelDifferenceComponent.this.doubleClickOnNode(node);
    }
  }
}
