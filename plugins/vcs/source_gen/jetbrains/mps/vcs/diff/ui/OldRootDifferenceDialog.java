package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import jetbrains.mps.ide.dialogs.BaseDialog;
import jetbrains.mps.nodeEditor.EditorMessageOwner;
import javax.swing.JSplitPane;
import jetbrains.mps.smodel.SModel;
import javax.swing.JPanel;
import com.intellij.ui.FocusTrackback;
import com.intellij.openapi.wm.FocusWatcher;
import jetbrains.mps.nodeEditor.selection.SelectionListener;
import jetbrains.mps.nodeEditor.selection.SingularSelectionListenerAdapter;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.nodeEditor.selection.SingularSelection;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SNode;
import java.awt.Frame;
import java.awt.HeadlessException;
import java.awt.GridLayout;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.event.FocusEvent;
import java.awt.Dimension;
import jetbrains.mps.smodel.IOperationContext;
import java.awt.BorderLayout;
import javax.swing.JLabel;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import jetbrains.mps.smodel.SNodeId;
import java.util.LinkedHashSet;
import com.intellij.util.containers.MultiMap;
import java.util.List;
import jetbrains.mps.vcs.diff.oldchanges.OldChange;
import java.util.ArrayList;
import jetbrains.mps.vcs.diff.oldchanges.MoveNodeChange;
import org.apache.commons.lang.ObjectUtils;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.HashSet;
import jetbrains.mps.vcs.diff.DiffBuilder;
import javax.swing.JComponent;
import java.util.Set;
import jetbrains.mps.vcs.diff.oldchanges.OldAddRootChange;
import java.util.Collection;
import jetbrains.mps.ide.projectPane.Icons;
import javax.swing.border.EmptyBorder;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.Cursor;

public class OldRootDifferenceDialog extends BaseDialog implements EditorMessageOwner {
  private JSplitPane myContainer;
  private SModel myNewModel;
  private SModel myOldModel;
  private OldDiffEditorComponent myNewEditorComponent;
  private OldDiffEditorComponent myOldEditorComponent;
  private JPanel myTopPanel;
  private JPanel myBottomPanel;
  private FocusTrackback myFocusTrackback;
  private FocusWatcher myFocusWatcher;
  private SelectionListener myCellSelectionListener = new SingularSelectionListenerAdapter() {
    @Override
    protected void selectionChangedTo(EditorComponent component, final SingularSelection newSelection) {
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          if (newSelection != null && newSelection.getEditorCell().getSNode() != null) {
            SNode sNode;
            sNode = myNewModel.getNodeById(newSelection.getEditorCell().getSNode().getSNodeId());
            myNewEditorComponent.inspect(sNode);
            sNode = myOldModel.getNodeById(newSelection.getEditorCell().getSNode().getSNodeId());
            myOldEditorComponent.inspect(sNode);
          }
        }
      });
    }
  };
  private boolean myViewportSetInProgress;

  public OldRootDifferenceDialog(Frame parent, final SModel newModel, final SModel oldModel, boolean editable, boolean modal) throws HeadlessException {
    super(parent, "Difference");
    setModal(modal);
    myTopPanel = new JPanel(new GridLayout(1, 2));
    myBottomPanel = new JPanel(new GridLayout(1, 2));
    myContainer = new JSplitPane(JSplitPane.VERTICAL_SPLIT, myTopPanel, myBottomPanel);
    myContainer.setResizeWeight(1.0);
    myNewModel = newModel;
    myOldModel = oldModel;
    myFocusTrackback = new FocusTrackback(this, parent, false);
    WindowAdapter focusListener = new WindowAdapter() {
      public void windowOpened(WindowEvent e) {
        if (myContainer != null) {
          myContainer.requestFocusInWindow();
          myFocusTrackback.registerFocusComponent(myContainer);
        }
      }
    };
    addWindowListener(focusListener);
    myFocusWatcher = new FocusWatcher() {
      protected void focusLostImpl(final FocusEvent e) {
        myFocusTrackback.consume();
      }
    };
    myFocusWatcher.install(myContainer);
  }

  public Dimension getPreferredSize() {
    return new Dimension(500, 400);
  }

  public void init(final IOperationContext context, final SNode node, String newRevisionName, String oldRevisionName) {
    final SNode[] oldNode = new SNode[1];
    final SNode[] newNode = new SNode[1];
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        oldNode[0] = myOldModel.getNodeById(node.getSNodeId());
        newNode[0] = myNewModel.getNodeById(node.getSNodeId());
      }
    });
    myOldEditorComponent = addEditor(context, oldNode[0], oldRevisionName);
    myNewEditorComponent = addEditor(context, newNode[0], newRevisionName);
    rebuildChangeBlocks();
  }

  private OldDiffEditorComponent addEditor(IOperationContext context, final SNode node, String revisionName) {
    final OldDiffEditorComponent result = new OldDiffEditorComponent(context, node) {
      @Override
      public void configureBlock(OldChangesBlock block) {
        if (!(myNewModel.isNotEditable())) {
          block.setRollbackButton(new OldRootDifferenceDialog.RollbackButton(block.getChanges(), getChanges()));
        }
      }
    };
    JPanel panel = new JPanel(new BorderLayout());
    panel.add(new JLabel(revisionName), BorderLayout.PAGE_START);
    panel.add(result.getExternalComponent(), BorderLayout.CENTER);
    myTopPanel.add(panel);
    myBottomPanel.add(result.getInspector().getExternalComponent());
    result.getSelectionManager().addSelectionListener(myCellSelectionListener);
    result.getViewport().addChangeListener(new ChangeListener() {
      public void stateChanged(ChangeEvent e) {
        if (myViewportSetInProgress) {
          return;
        }
        myViewportSetInProgress = true;
        result.synchronizeViewWith(myNewEditorComponent);
        result.synchronizeViewWith(myOldEditorComponent);
        myViewportSetInProgress = false;
      }
    });
    return result;
  }

  private void sortChildren(SNodeId nodeId) {
    SNode newNode = myNewModel.getNodeById(nodeId);
    SNode oldNode = myOldModel.getNodeById(nodeId);
    if (newNode == null || oldNode == null) {
      return;
    }
    LinkedHashSet<String> rolesOrder = new LinkedHashSet<String>();
    for (SNode child : oldNode.getChildrenIterable()) {
      rolesOrder.add(child.getRole_());
    }
    MultiMap<String, SNode> childrenForRoles = new MultiMap<String, SNode>();
    for (SNode child : newNode.getChildrenIterable()) {
      childrenForRoles.putValue(child.getRole_(), child);
    }
    for (SNode child : newNode.getChildren()) {
      newNode.removeChild(child);
    }
    for (String role : rolesOrder) {
      for (SNode child : childrenForRoles.get(role)) {
        newNode.addChild(role, child);
      }
    }
  }

  private void applySafeMoves(final List<OldChange> changes) {
    ArrayList<MoveNodeChange> movesToApply = new ArrayList<MoveNodeChange>();
    for (OldChange change : changes) {
      if (change instanceof MoveNodeChange) {
        MoveNodeChange moveNodeChange = (MoveNodeChange) change;
        SNode newNode = myNewModel.getNodeById(change.getAffectedNodeId());
        SNode oldNode = myOldModel.getNodeById(change.getAffectedNodeId());
        assert newNode != null && oldNode != null;
        if (ObjectUtils.equals(newNode.getRole_(), oldNode.getRole_()) && SNodeOperations.getIndexInParent(newNode) == SNodeOperations.getIndexInParent(oldNode)) {
          movesToApply.add(moveNodeChange);
        }
      }
    }
    HashSet<SNodeId> nodesToSortChildren = new HashSet<SNodeId>();
    for (MoveNodeChange moveNodeChange : movesToApply) {
      nodesToSortChildren.add(moveNodeChange.getNewParent());
    }
    for (SNodeId nodeId : nodesToSortChildren) {
      sortChildren(nodeId);
    }
    changes.removeAll(movesToApply);
  }

  private void rebuildChangeBlocks() {
    myNewEditorComponent.removeAllChanges();
    myOldEditorComponent.removeAllChanges();
    final List<OldChange> revertChanges = new DiffBuilder(myNewModel, myOldModel).getChanges();
    ModelAccess.instance().runWriteActionInCommandAsync(new Runnable() {
      public void run() {
        applySafeMoves(revertChanges);
        myNewEditorComponent.hightlight(revertChanges, true, true);
        myOldEditorComponent.hightlight(revertChanges, false, true);
        myNewEditorComponent.makeChangeBlocks();
        myOldEditorComponent.makeChangeBlocks();
      }
    }, myOldEditorComponent.getOperationContext().getProject());
  }

  protected JComponent getMainComponent() {
    return myContainer;
  }

  @BaseDialog.Button(name = "Close", mnemonic = 'C', position = 0, defaultButton = true)
  public void onClose() {
    dispose();
  }

  private void applyChange(MultiMap<SNodeId, OldChange> dependenciesMap, Set<OldChange> appliedChanges, Set<SNodeId> notAppliedNodes, OldChange changeToApply) {
    if (appliedChanges.contains(changeToApply)) {
      return;
    }
    appliedChanges.add(changeToApply);
    notAppliedNodes.remove(changeToApply.getAffectedNodeId());
    changeToApply.apply(myNewModel);
    if (dependenciesMap.containsKey(changeToApply.getAffectedNodeId())) {
      for (OldChange dependant : dependenciesMap.get(changeToApply.getAffectedNodeId())) {
        boolean dependenciesResolved = true;
        for (SNodeId dependency : dependant.getDependencies()) {
          if (notAppliedNodes.contains(dependency)) {
            dependenciesResolved = false;
            break;
          }
        }
        if (dependenciesResolved) {
          applyChange(dependenciesMap, appliedChanges, notAppliedNodes, dependant);
        }
      }
    }
    if (changeToApply instanceof OldAddRootChange) {
      myNewEditorComponent.editNode(myNewModel.getNodeById(changeToApply.getAffectedNodeId()), myNewEditorComponent.getOperationContext());
    }
  }

  @Override
  public void dispose() {
    myFocusTrackback.restoreFocus();
    myFocusWatcher.deinstall(myContainer);
    myNewEditorComponent.dispose();
    myOldEditorComponent.dispose();
    super.dispose();
  }

  private static MultiMap<SNodeId, OldChange> getChangeDependencies(Collection<OldChange> changes) {
    MultiMap<SNodeId, OldChange> result = new MultiMap<SNodeId, OldChange>();
    for (OldChange change : changes) {
      for (SNodeId dependant : change.getDependencies()) {
        result.putValue(dependant, change);
      }
      if (change.getAffectedNodeId() != null) {
        result.putValue(change.getAffectedNodeId(), change);
      }
    }
    return result;
  }

  /*package*/ class RollbackButton extends JLabel {
    private List<OldChangeEditorMessage> myChangeMessages;
    private List<OldChange> myChanges;

    public RollbackButton(List<OldChangeEditorMessage> changeMessages, List<OldChange> changes) {
      super(Icons.ROLLBACK);
      myChangeMessages = changeMessages;
      myChanges = changes;
      setBorder(new EmptyBorder(0, 2, 1, 2));
      setBackground(Color.WHITE);
      setToolTipText("Rollback");
      setPreferredSize(new Dimension(getWidth(), getHeight()));
      setSize(getWidth(), getHeight());
      addMouseListener(new MouseAdapter() {
        public void mousePressed(MouseEvent e) {
          revert();
        }
      });
      setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
    }

    public int getWidth() {
      return getIcon().getIconWidth() + 6;
    }

    public int getHeight() {
      return getIcon().getIconHeight();
    }

    protected void revert() {
      ModelAccess.instance().runWriteActionInCommand(new Runnable() {
        public void run() {
          HashSet<SNodeId> notAppliedNodes = new HashSet<SNodeId>();
          for (OldChange change : myChanges) {
            notAppliedNodes.add(change.getAffectedNodeId());
          }
          HashSet<OldChange> appliedChanges = new HashSet<OldChange>();
          MultiMap<SNodeId, OldChange> dependenciesMap = OldRootDifferenceDialog.getChangeDependencies(myChanges);
          for (OldChangeEditorMessage m : myChangeMessages) {
            applyChange(dependenciesMap, appliedChanges, notAppliedNodes, m.getChange());
          }
        }
      });
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          rebuildChangeBlocks();
        }
      });
    }
  }
}
