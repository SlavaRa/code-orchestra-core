package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import javax.swing.JPanel;
import jetbrains.mps.vcs.diff.Merger;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.SModel;
import java.awt.BorderLayout;
import java.awt.GridLayout;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.ide.ui.HeaderWrapper;
import jetbrains.mps.vcs.diff.Conflict;
import jetbrains.mps.smodel.SNode;
import javax.swing.tree.TreeNode;
import javax.swing.JCheckBox;
import javax.swing.AbstractAction;
import java.awt.event.ActionEvent;
import java.awt.FlowLayout;
import com.intellij.openapi.actionSystem.ActionGroup;
import java.util.List;
import jetbrains.mps.vcs.diff.oldchanges.OldChange;
import jetbrains.mps.workbench.action.BaseAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;
import jetbrains.mps.workbench.action.ActionUtils;

public class OldMergeView extends JPanel {
  private Merger myMerger;
  private IOperationContext myContext;
  private OldModelChangesTree myMineChangesTree;
  private OldModelChangesTree myRepoChangesTree;
  private OldMergeResultView myResultView;

  public OldMergeView(final IOperationContext context, final SModel baseModel, final SModel mine, final SModel repo) {
    setLayout(new BorderLayout());
    myContext = context;
    JPanel controlsPanel = createControlsPanel();
    final JPanel panel = new JPanel(new GridLayout(1, 2));
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        myMerger = new Merger(baseModel, mine, repo);
        myMerger.doRebuild(new Runnable() {
          public void run() {
          }
        });
        OldModelDifferenceComponent mineModelDiff = new OldModelDifferenceComponent(context);
        mineModelDiff.showDifference(baseModel, mine, myMerger.getBaseMineChanges());
        myMineChangesTree = mineModelDiff.getModelTree();
        panel.add(new HeaderWrapper("My Changes", mineModelDiff));
        myResultView = new OldMergeResultView(context, baseModel, mine, repo, myMerger) {
          @Override
          protected void showConflict(Conflict conflict) {
            SNode node;
            node = mine.getNodeById(conflict.getChange2().getAffectedNodeId());
            if (node == null) {
              node = baseModel.getNodeById(conflict.getChange2().getAffectedNodeId());
            }
            TreeNode treeNode1 = myMineChangesTree.findNodeWith(node);
            myMineChangesTree.selectNode(treeNode1);
            node = repo.getNodeById(conflict.getChange1().getAffectedNodeId());
            if (node == null) {
              node = baseModel.getNodeById(conflict.getChange1().getAffectedNodeId());
            }
            TreeNode treeNode2 = myRepoChangesTree.findNodeWith(node);
            myRepoChangesTree.selectNode(treeNode2);
          }
        };
        panel.add(new HeaderWrapper("Merge Result", myResultView));
        OldModelDifferenceComponent repoModelDiff = new OldModelDifferenceComponent(context);
        repoModelDiff.showDifference(baseModel, repo, myMerger.getBaseRepoChanges());
        myRepoChangesTree = repoModelDiff.getModelTree();
        panel.add(new HeaderWrapper("Repository Changes", repoModelDiff));
        updateView();
      }
    });
    add(panel);
    add(controlsPanel, BorderLayout.PAGE_END);
  }

  private JPanel createControlsPanel() {
    final JCheckBox showOnlyConflicts = new JCheckBox();
    showOnlyConflicts.setAction(new AbstractAction("Show conflicts only") {
      public void actionPerformed(ActionEvent e) {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            myMineChangesTree.setShowOnlyConflicts(showOnlyConflicts.getModel().isSelected());
            myRepoChangesTree.setShowOnlyConflicts(showOnlyConflicts.getModel().isSelected());
          }
        });
        updateView();
      }
    });
    JPanel myBottomPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
    myBottomPanel.add(showOnlyConflicts);
    return myBottomPanel;
  }

  private void updateView() {
    myRepoChangesTree.getConflicts().clear();
    myMineChangesTree.getConflicts().clear();
    for (Conflict conflict : myMerger.getUnresolvedConflicts()) {
      myRepoChangesTree.getConflicts().add(conflict.getChange1().getAffectedNodeId());
      myMineChangesTree.getConflicts().add(conflict.getChange2().getAffectedNodeId());
    }
    myResultView.updateView();
    myRepoChangesTree.rebuildNow();
    myMineChangesTree.rebuildNow();
  }

  public boolean isResolved() {
    return myMerger.isResolved();
  }

  public SModel getResultModel() {
    return myMerger.getResultModel();
  }

  private class MyChangesTree extends OldModelChangesTree {
    /*package*/ MyChangesTree(IOperationContext context) {
      super(context);
    }

    @Override
    protected void doubleClickOnNode(final SNode node) {
    }

    @Override
    protected ActionGroup getActionGroupForChanges(final List<OldChange> changes) {
      BaseAction excludeAction = new BaseAction("Exclude") {
        protected void doExecute(AnActionEvent e, Map<String, Object> map) {
          for (OldChange change : changes) {
            myMerger.excludeChange(change);
            getExcludetNodes().add(change.getAffectedNodeId());
          }
          myMerger.doRebuild(new Runnable() {
            public void run() {
              updateView();
            }
          });
        }
      };
      excludeAction.setDisableOnNoProject(false);
      BaseAction includeAction = new BaseAction("Include") {
        protected void doExecute(AnActionEvent event, Map<String, Object> map) {
          for (OldChange change : changes) {
            myMerger.includeChange(change);
            getExcludetNodes().remove(change.getAffectedNodeId());
          }
          myMerger.doRebuild(new Runnable() {
            public void run() {
              updateView();
            }
          });
        }
      };
      includeAction.setDisableOnNoProject(false);
      return ActionUtils.groupFromActions(excludeAction, includeAction);
    }
  }
}
