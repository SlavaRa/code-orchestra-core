package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import jetbrains.mps.vcs.diff.merge.MergeContext;
import jetbrains.mps.vcs.diff.changes.ChangeSet;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.Map;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.util.DisjointSets;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class ChangeGroupBuilder {
  private MergeContext myMergeContext;
  private ChangeSet myChangeSet;
  private boolean myInspector = false;
  private DiffEditor myLeftEditor;
  private DiffEditor myRightEditor;
  private List<ChangeGroup> myChangeGroups = null;
  private List<ChangeGroupInvalidateListener> myInvalidateListeners = ListSequence.fromList(new ArrayList<ChangeGroupInvalidateListener>());

  public ChangeGroupBuilder(@Nullable MergeContext mergeContext, @NotNull ChangeSet changeSet, @NotNull DiffEditor leftEditor, @NotNull DiffEditor rightEditor, boolean inspector) {
    myMergeContext = mergeContext;
    myChangeSet = changeSet;
    myLeftEditor = leftEditor;
    myRightEditor = rightEditor;
    myInspector = inspector;
    if (myInspector) {
      EditorComponent.RebuildListener rebuildListener = new EditorComponent.RebuildListener() {
        public void editorRebuilt(EditorComponent editor) {
          invalidate();
        }
      };
      myLeftEditor.getInspector().addRebuildListener(rebuildListener);
      myRightEditor.getInspector().addRebuildListener(rebuildListener);
    }
  }

  public EditorComponent getLeftComponent() {
    return myLeftEditor.getEditorComponent(myInspector);
  }

  public EditorComponent getRightComponent() {
    return myRightEditor.getEditorComponent(myInspector);
  }

  private void calculateChangeGroups() {
    final Map<ModelChange, Bounds> left = MapSequence.fromMap(new HashMap<ModelChange, Bounds>());
    final Map<ModelChange, Bounds> right = MapSequence.fromMap(new HashMap<ModelChange, Bounds>());
    for (ModelChange change : ListSequence.fromList(myChangeSet.getModelChanges())) {
      Bounds leftBounds = findBounds(myLeftEditor.getMessagesForChange(change), getLeftComponent());
      Bounds rightBounds = findBounds(myRightEditor.getMessagesForChange(change), getRightComponent());

      if (leftBounds.length() <= 0 && rightBounds.length() <= 0) {
        continue;
      }

      MapSequence.fromMap(left).put(change, leftBounds);
      MapSequence.fromMap(right).put(change, rightBounds);
    }
    Set<ModelChange> changes = MapSequence.fromMap(left).keySet();
    DisjointSets<ModelChange> ds = new DisjointSets<ModelChange>(changes);
    for (ModelChange a : SetSequence.fromSet(changes)) {
      for (ModelChange b : SetSequence.fromSet(changes)) {
        if (!((int) MapSequence.fromMap(left).get(a).end() - 1 < (int) MapSequence.fromMap(left).get(b).start() || (int) MapSequence.fromMap(left).get(b).end() - 1 < (int) MapSequence.fromMap(left).get(a).start())) {
          ds.unite(a, b);
        }
        if (!((int) MapSequence.fromMap(right).get(a).end() - 1 < (int) MapSequence.fromMap(right).get(b).start() || (int) MapSequence.fromMap(right).get(b).end() - 1 < (int) MapSequence.fromMap(right).get(a).start())) {
          ds.unite(a, b);
        }
      }
    }
    myChangeGroups = ListSequence.fromList(new ArrayList<ChangeGroup>());
    for (Set<ModelChange> s : Sequence.fromIterable(ds.getSets())) {
      Bounds lb = SetSequence.fromSet(s).select(new ISelector<ModelChange, Bounds>() {
        public Bounds select(ModelChange ch) {
          return MapSequence.fromMap(left).get(ch);
        }
      }).reduceLeft(new ILeftCombinator<Bounds, Bounds>() {
        public Bounds combine(Bounds a, Bounds b) {
          return a.merge(b);
        }
      });
      Bounds rb = SetSequence.fromSet(s).select(new ISelector<ModelChange, Bounds>() {
        public Bounds select(ModelChange ch) {
          return MapSequence.fromMap(right).get(ch);
        }
      }).reduceLeft(new ILeftCombinator<Bounds, Bounds>() {
        public Bounds combine(Bounds a, Bounds b) {
          return a.merge(b);
        }
      });
      ListSequence.fromList(myChangeGroups).addElement(new ChangeGroup(lb, rb, SetSequence.fromSet(s).toListSequence(), myMergeContext));
    }
    myChangeGroups = ListSequence.fromList(myChangeGroups).sort(new ISelector<ChangeGroup, Comparable<?>>() {
      public Comparable<?> select(ChangeGroup g) {
        return (int) g.getLeftBounds().start();
      }
    }, true).toListSequence();
  }

  public void addInvalidateListener(@NotNull ChangeGroupInvalidateListener listener) {
    ListSequence.fromList(myInvalidateListeners).addElement(listener);
  }

  public void removeInvalidateListener(@NotNull ChangeGroupInvalidateListener listener) {
    ListSequence.fromList(myInvalidateListeners).removeElement(listener);
  }

  public List<ChangeGroup> getChangeGroups() {
    if (myChangeGroups == null) {
      calculateChangeGroups();
    }
    return myChangeGroups;
  }

  public void invalidate() {
    myChangeGroups = null;
    ListSequence.fromList(myInvalidateListeners).visitAll(new IVisitor<ChangeGroupInvalidateListener>() {
      public void visit(ChangeGroupInvalidateListener it) {
        it.changeGroupsInvalidated();
      }
    });
  }

  @Nullable
  public MergeContext getMergeContext() {
    return myMergeContext;
  }

  public int getEditorVerticalOffset() {
    if (myInspector) {
      return 0;
    } else {
      assert getLeftComponent().getExternalComponent().getY() == getRightComponent().getExternalComponent().getY();
      return getLeftComponent().getExternalComponent().getY();
    }
  }

  private static Bounds findBounds(Iterable<ChangeEditorMessage> messages, final EditorComponent editorComponent) {
    Bounds bounds = null;
    if (Sequence.fromIterable(messages).isNotEmpty()) {
      bounds = Sequence.fromIterable(messages).select(new ISelector<ChangeEditorMessage, Bounds>() {
        public Bounds select(ChangeEditorMessage m) {
          return m.getBounds(editorComponent);
        }
      }).where(new IWhereFilter<Bounds>() {
        public boolean accept(Bounds b) {
          return b.length() > 0;
        }
      }).reduceLeft(new ILeftCombinator<Bounds, Bounds>() {
        public Bounds combine(Bounds a, Bounds b) {
          return a.merge(b);
        }
      });
    }
    if (bounds == null || bounds.length() <= 0) {
      int y = editorComponent.getRootCell().getY();
      return new Bounds(y, y);
    } else {
      return bounds;
    }
  }
}
