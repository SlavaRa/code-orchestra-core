package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.messageTargets.EditorMessageWithTarget;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.nodeEditor.EditorMessageOwner;
import jetbrains.mps.errors.MessageStatus;
import java.awt.Color;
import jetbrains.mps.vcs.diff.changes.ChangeType;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.errors.messageTargets.MessageTargetEnum;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.EditorMessage;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.errors.messageTargets.DeletedNodeMessageTarget;
import jetbrains.mps.ide.util.ColorAndGraphicsUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Vertical;
import jetbrains.mps.nodeEditor.style.StyleAttributes;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import jetbrains.mps.vcs.diff.changes.NodeChange;
import jetbrains.mps.errors.messageTargets.PropertyMessageTarget;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import jetbrains.mps.errors.messageTargets.ReferenceMessageTarget;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class ChangeEditorMessage extends EditorMessageWithTarget {
  private ModelChange myChange;
  private ChangeEditorMessage.ConflictChecker myConflictsChecker;

  private ChangeEditorMessage(SNode node, MessageTarget target, EditorMessageOwner owner, ModelChange change, ChangeEditorMessage.ConflictChecker conflictChecker) {
    super(node, MessageStatus.OK, target, null, "", owner);
    myChange = change;
    myConflictsChecker = conflictChecker;
  }

  public boolean isConflicted() {
    return myConflictsChecker != null && myConflictsChecker.isChangeConflicted(myChange);
  }

  @Override
  public Color getColor() {
    return ChangeColors.get((isConflicted() ?
      ChangeType.CONFLICTED :
      myChange.getType()
    ));
  }

  public ModelChange getChange() {
    return myChange;
  }

  @Override
  public boolean isBackground() {
    return true;
  }

  @Override
  public void paint(Graphics graphics, EditorComponent component, EditorCell cell) {
    boolean targetIsNode = myMessageTarget.getTarget() == MessageTargetEnum.NODE;
    boolean shouldPaintSelection = (targetIsNode ?
      getNode() == cell.getSNode() :
      !(cell instanceof EditorCell_Collection)
    );
    if (shouldPaintSelection) {
      cell.paintSelection(graphics, getColor(), false);
      repaintConflictedMessages(graphics, cell);
    } else {
      if (myMessageTarget.getTarget() == MessageTargetEnum.DELETED_CHILD) {
        drawDeletedChild(graphics, cell);
      } else {
        Rectangle bounds = cell.getBounds();
        graphics.setColor(ChangeColors.get((isConflicted() ?
          ChangeType.CONFLICTED :
          ChangeType.CHANGE
        )));
        graphics.drawRect(bounds.x + 1, bounds.y + 1, bounds.width - 2, bounds.height - 2);
      }
    }
  }

  private void repaintConflictedMessages(Graphics graphics, EditorCell cell) {
    // This is a workaround for case when any change message is going to be painted over 
    // "conflicted" red frame. In this case, we repaint conflicted red frame again 
    EditorCell_Collection parent = cell.getParent();
    if (parent != null && parent.getChildCount() == 1) {
      EditorMessage messageToRepaint = ListSequence.fromList(((List<EditorMessage>) parent.getMessages())).findFirst(new IWhereFilter<EditorMessage>() {
        public boolean accept(EditorMessage m) {
          return m instanceof ChangeEditorMessage && ((ChangeEditorMessage) m).isConflicted();
        }
      });
      if (messageToRepaint != null) {
        messageToRepaint.paint(graphics, cell.getEditor(), parent);
      }
    }
  }

  private void drawDeletedChild(Graphics graphics, EditorCell cell) {
    Rectangle bounds = cell.getBounds();
    if (myMessageTarget.getRole().equals(cell.getRole())) {
      int index = ((DeletedNodeMessageTarget) myMessageTarget).getNextChildIndex();
      if (index != -1) {
        EditorCell_Collection collectionCell = (EditorCell_Collection) cell;

        if (hasChildrenWithDifferentNode(cell)) {
          int cellIndex = getChildCellIndex(collectionCell, index);
          if (isVertical(collectionCell)) {
            drawHorizontalLine(graphics, collectionCell, cellIndex);
          } else {
            drawVerticalLineWithArrows(graphics, collectionCell, cellIndex);
          }
        } else {
          cell.paintSelection(graphics, getColor(), false);
        }
      }
    } else {
      graphics.setColor(getColor());
      graphics.drawLine(bounds.x, bounds.y, bounds.x + bounds.width, bounds.y);
    }
  }

  private void drawHorizontalLine(Graphics graphics, EditorCell_Collection collectionCell, int cellIndex) {
    Rectangle bounds = collectionCell.getBounds();
    int y;
    if (-1 < cellIndex && cellIndex < collectionCell.getChildCount()) {
      y = collectionCell.getChildAt(cellIndex).getY();
    } else {
      y = ((int) collectionCell.getChildAt(collectionCell.getChildCount() - 1).getBounds().getMaxY());
    }
    graphics.setColor(getColor());
    graphics.drawLine((int) bounds.getMinX(), y, (int) bounds.getMaxX(), y);
  }

  private void drawVerticalLineWithArrows(Graphics graphics, EditorCell_Collection collectionCell, int cellIndex) {
    int x;
    Rectangle childCellBounds;
    if (-1 < cellIndex && cellIndex < collectionCell.getChildCount()) {
      childCellBounds = collectionCell.getCellAt(cellIndex).getBounds();
      x = childCellBounds.x;
    } else {
      childCellBounds = collectionCell.getCellAt(collectionCell.getChildCount() - 1).getBounds();
      x = (int) childCellBounds.getMaxX();
    }
    int y1 = childCellBounds.y;
    int y2 = (int) childCellBounds.getMaxY();

    graphics.setColor(getColor());
    graphics.drawLine(x, y1, x, y2);
    graphics.fillPolygon(new int[]{x, x - 3, x + 3}, new int[]{y1 - 2, y1 - 5, y1 - 5}, 3);
    graphics.fillPolygon(new int[]{x, x - 3, x + 3}, new int[]{y2 + 2, y2 + 5, y2 + 5}, 3);

    graphics.setColor(ColorAndGraphicsUtil.brightenColor(getColor(), 0.8f));
    graphics.drawPolygon(new int[]{x, x - 3, x + 3}, new int[]{y1 - 2, y1 - 5, y1 - 5}, 3);
    graphics.drawPolygon(new int[]{x, x - 3, x + 3}, new int[]{y2 + 2, y2 + 5, y2 + 5}, 3);
  }

  public Bounds getBounds(EditorComponent component) {
    if (myMessageTarget.getTarget() != MessageTargetEnum.DELETED_CHILD) {
      return getBoundsSuper(component);
    } else {
      DeletedNodeMessageTarget cmt = ((DeletedNodeMessageTarget) myMessageTarget);
      EditorCell cell = getCell(component);
      if (cell == null) {
        return new Bounds(-1, -1);
      }
      if (cmt.getRole().equals(cell.getRole())) {
        if (hasChildrenWithDifferentNode(cell)) {
          return getBoundsForChild((EditorCell_Collection) cell, cmt.getNextChildIndex());
        } else {
          return getBoundsSuper(component);
        }
      } else {
        int y = (int) cell.getBounds().getMinY();
        return new Bounds(y, y + 1);
      }
    }
  }

  private Bounds getBoundsForChild(EditorCell_Collection cell, int index) {
    int cellIndex = getChildCellIndex(cell, index);
    int lastCellIndex = cell.getChildCount() - 1;

    int minY;
    int maxY;
    if (cellIndex > lastCellIndex) {
      Rectangle lastCellBounds = cell.getChildAt(lastCellIndex).getBounds();
      minY = (isVertical(cell) ?
        (int) lastCellBounds.getMaxY() :
        (int) lastCellBounds.getMinY()
      );
      maxY = Math.max((int) lastCellBounds.getMaxY(), minY + 1);
    } else {
      minY = (int) cell.getChildAt(cellIndex).getBounds().getMinY();
      maxY = (isVertical(cell) ?
        minY + 1 :
        (int) cell.getCellAt(cellIndex).getBounds().getMaxY()
      );
    }
    return new Bounds(minY, maxY);
  }

  private Bounds getBoundsSuper(EditorComponent component) {
    return new Bounds(super.getStart(component), super.getStart(component) + super.getHeight(component));
  }

  @Override
  public int getStart(EditorComponent component) {
    return (int) getBounds(component).start();
  }

  @Override
  public int getHeight(EditorComponent component) {
    return getBounds(component).length();
  }

  private static boolean hasChildrenWithDifferentNode(EditorCell cell) {
    if (cell instanceof EditorCell_Collection) {
      final EditorCell_Collection collectionCell = (EditorCell_Collection) cell;
      return Sequence.fromIterable(((Iterable<EditorCell>) collectionCell)).any(new IWhereFilter<EditorCell>() {
        public boolean accept(EditorCell child) {
          return child.getSNode() != collectionCell.getSNode();
        }
      });
    } else {
      return false;
    }
  }

  private static boolean isVertical(EditorCell cell) {
    return cell instanceof EditorCell_Collection && (((EditorCell_Collection) cell).getCellLayout() instanceof CellLayout_Vertical || cell.getStyle().get(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE));
  }

  private static int getChildCellIndex(@NotNull EditorCell_Collection collectionCell, int nodeIndex) {
    if (nodeIndex == -1) {
      return -1;
    }
    int currentNodeIndex = -1;
    for (int i = 0; i < collectionCell.getChildCount(); i++) {
      if (collectionCell.getChildAt(i).getSNode() != collectionCell.getSNode()) {
        currentNodeIndex++;
      }
      if (currentNodeIndex == nodeIndex) {
        return i;
      }
    }
    if (currentNodeIndex == nodeIndex - 1) {
      return collectionCell.getChildCount();
    }
    assert false;
    return -1;
  }

  public static List<ChangeEditorMessage> createMessages(SModel editedModel, ModelChange change, EditorMessageOwner owner, ChangeEditorMessage.ConflictChecker conflictChecker) {
    List<ChangeEditorMessage> messages = ListSequence.fromList(new LinkedList<ChangeEditorMessage>());
    SNodeId id;
    MessageTarget messageTarget;
    if (change instanceof AddRootChange || change instanceof DeleteRootChange) {
      id = change.getRootId();
      messageTarget = new NodeMessageTarget();
    } else if (change instanceof SetPropertyChange) {
      id = ((NodeChange) change).getAffectedNodeId();
      messageTarget = new PropertyMessageTarget(((SetPropertyChange) change).getPropertyName());
    } else if (change instanceof SetReferenceChange) {
      id = ((NodeChange) change).getAffectedNodeId();
      messageTarget = new ReferenceMessageTarget(((SetReferenceChange) change).getRole());
    } else if (change instanceof NodeGroupChange) {
      NodeGroupChange ngc = ((NodeGroupChange) change);
      SModel changeModel = change.getChangeSet().getNewModel();
      boolean reversed = changeModel != editedModel;
      if (reversed) {
        changeModel = change.getChangeSet().getOldModel();
      }

      String role = ngc.getRole();
      SNodeId parentId = ngc.getParentNodeId();
      List<SNode> changeChildren = changeModel.getNodeById(parentId).getChildren(role);

      int changeBegin = (reversed ?
        ngc.getBegin() :
        ngc.getResultBegin()
      );
      int changeEnd = (reversed ?
        ngc.getEnd() :
        ngc.getResultEnd()
      );

      // We need to check change models because current edited model can have different indices 
      // (for instance, when some changes are already applied) 
      SNodeId beginId = (changeBegin < changeChildren.size() ?
        changeChildren.get(changeBegin).getSNodeId() :
        null
      );
      SNodeId endId = (changeEnd < changeChildren.size() ?
        changeChildren.get(changeEnd).getSNodeId() :
        null
      );
      int currentChildrenSize = editedModel.getNodeById(parentId).getChildren(role).size();

      int beginIndex = (beginId == null ?
        currentChildrenSize :
        SNodeOperations.getIndexInParent(((SNode) editedModel.getNodeById(beginId)))
      );
      int endIndex = (endId == null ?
        currentChildrenSize :
        SNodeOperations.getIndexInParent(((SNode) editedModel.getNodeById(endId)))
      );

      assert 0 <= beginIndex && beginIndex <= endIndex && endIndex <= currentChildrenSize;
      if (beginIndex == endIndex) {
        // delete nodes 
        id = parentId;
        messageTarget = new DeletedNodeMessageTarget(role, beginIndex);
      } else {
        List<SNode> editedChildren = editedModel.getNodeById(parentId).getChildren(role);
        for (int i = beginIndex; i < endIndex; i++) {
          ListSequence.fromList(messages).addElement(new ChangeEditorMessage(editedChildren.get(i), new NodeMessageTarget(), owner, change, conflictChecker));
        }
        return messages;
      }
    } else {
      return null;
    }
    SNode node = editedModel.getNodeById(id);
    ListSequence.fromList(messages).addElement(new ChangeEditorMessage(node, messageTarget, owner, change, conflictChecker));
    return messages;
  }

  public static interface ConflictChecker {
    public boolean isChangeConflicted(ModelChange change);
  }
}
