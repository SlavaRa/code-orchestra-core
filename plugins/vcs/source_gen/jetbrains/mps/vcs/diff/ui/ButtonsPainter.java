package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.leftHighlighter.AbstractFoldingAreaPainter;
import javax.swing.Icon;
import java.util.List;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.awt.Graphics;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.awt.event.MouseEvent;
import java.awt.Cursor;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import java.awt.Point;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.projectPane.Icons;
import java.awt.image.BufferedImage;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import javax.swing.ImageIcon;

public abstract class ButtonsPainter extends AbstractFoldingAreaPainter {
  private static final int ICON_SIZE = 11;
  private static final int GAP = 3;
  private static final int LEFT_MARGIN = 5;
  protected static final Icon MIRRORED_APPLY_ICON;

  private int myWidth;
  private ChangeGroupBuilder myChangeGroupBuilder;
  private boolean myHighlightLeft;
  private List<FoldingAreaButton> myButtons = null;
  private FoldingAreaButton myCurrentButton = null;

  public ButtonsPainter(int iconCount, EditorComponent editorComponent, ChangeGroupBuilder changeGroupBuilder) {
    super(editorComponent.getLeftEditorHighlighter());
    myWidth = (GAP + ICON_SIZE) * iconCount + LEFT_MARGIN;
    myChangeGroupBuilder = changeGroupBuilder;
    myHighlightLeft = changeGroupBuilder.getLeftComponent() == editorComponent;
    myChangeGroupBuilder.addInvalidateListener(new ChangeGroupInvalidateListener() {
      public void changeGroupsInvalidated() {
        relayout();
      }
    });
  }

  protected boolean isHighlightLeft() {
    return myHighlightLeft;
  }

  protected ChangeGroupBuilder getChangeGroupBuilder() {
    return myChangeGroupBuilder;
  }

  public int getWeight() {
    return 2;
  }

  @Override
  public int getLeftAreaWidth() {
    return (myHighlightLeft ?
      0 :
      myWidth
    );
  }

  @Override
  public int getRightAreaWidth() {
    return (myHighlightLeft ?
      myWidth :
      0
    );
  }

  @Override
  protected void paintInLocalCoordinates(Graphics graphics) {
    ensureButtonsCreated();

    for (FoldingAreaButton b : ListSequence.fromList(myButtons)) {
      b.paint(graphics);
    }
  }

  private void ensureButtonsCreated() {
    if (myButtons == null) {
      myButtons = ListSequence.fromList(new ArrayList<FoldingAreaButton>());

      int previousStart = Integer.MIN_VALUE;
      for (ChangeGroup cg : ListSequence.fromList(myChangeGroupBuilder.getChangeGroups())) {
        int y = Math.max((int) cg.getBounds(myHighlightLeft).start(), previousStart + GAP + ICON_SIZE);
        ListSequence.fromList(myButtons).addSequence(Sequence.fromIterable(createButtonsForChangeGroup(cg, y)));
        previousStart = y;
      }
    }
  }

  protected abstract Iterable<FoldingAreaButton> createButtonsForChangeGroup(ChangeGroup changeGroup, int y);

  @Override
  public void mouseMoved(MouseEvent event) {
    myCurrentButton = findButtonUnder(event.getPoint());
    if (myCurrentButton == null) {
      event.getComponent().setCursor(null);
    } else {
      event.getComponent().setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
    }
  }

  @Override
  public String getToolTipText() {
    return check_of7u5x_a0a9(myCurrentButton);
  }

  @Override
  public void mousePressed(MouseEvent event) {
    if (event.getButton() == MouseEvent.BUTTON1 && event.getID() == MouseEvent.MOUSE_CLICKED) {
      check_of7u5x_a0a0a01(myCurrentButton);
      event.consume();
    }
  }

  @Override
  public void mouseExited(MouseEvent event) {
    myCurrentButton = null;
    event.getComponent().setCursor(null);
  }

  @Nullable
  private FoldingAreaButton findButtonUnder(@NotNull final Point p) {
    ensureButtonsCreated();

    final int x = p.x - getLeftHighlighter().getFoldingLineX();
    return ListSequence.fromList(myButtons).findFirst(new IWhereFilter<FoldingAreaButton>() {
      public boolean accept(FoldingAreaButton b) {
        return b.getX() - GAP / 2 < x && x < b.getX() + ICON_SIZE + GAP / 2 && b.getY() - GAP / 2 < p.y && p.y < b.getY() + ICON_SIZE + GAP / 2;
      }
    });
  }

  @Override
  public void relayout() {
    myButtons = null;
  }

  protected int getX(int index) {
    int x = (1 + index) * (-GAP - ICON_SIZE) - LEFT_MARGIN;
    if (myHighlightLeft) {
      x = myWidth + x + ICON_SIZE;
    }
    return x;
  }

  private static String check_of7u5x_a0a9(FoldingAreaButton checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getToolTipText();
    }
    return null;
  }

  private static void check_of7u5x_a0a0a01(FoldingAreaButton checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.performAction();
    }

  }

  static {
    Icon icon = Icons.APPLY;
    BufferedImage image = new BufferedImage(icon.getIconWidth(), icon.getIconHeight(), BufferedImage.TYPE_INT_RGB);
    Graphics2D g2d = ((Graphics2D) image.getGraphics());
    g2d.setTransform(AffineTransform.getScaleInstance(-1, 1));
    icon.paintIcon(null, g2d, -icon.getIconWidth(), 0);
    MIRRORED_APPLY_ICON = new ImageIcon(image);
  }
}
