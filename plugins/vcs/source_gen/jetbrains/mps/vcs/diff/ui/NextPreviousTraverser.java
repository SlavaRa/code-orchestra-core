package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import javax.swing.Icon;
import com.intellij.openapi.util.IconLoader;
import jetbrains.mps.ide.projectPane.Icons;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.List;
import jetbrains.mps.nodeEditor.EditorComponent;
import com.intellij.openapi.actionSystem.ActionToolbar;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.selection.SelectionListener;
import jetbrains.mps.nodeEditor.selection.Selection;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Arrays;
import com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.workbench.action.BaseAction;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.openapi.util.Computable;
import jetbrains.mps.smodel.SNode;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;

public class NextPreviousTraverser {
  private static final Icon PREVIOUS_ICON = IconLoader.getIcon("/actions/previousOccurence.png", Icons.class);
  private static final Icon NEXT_ICON = IconLoader.getIcon("/actions/nextOccurence.png", Icons.class);
  protected static Log log = LogFactory.getLog(NextPreviousTraverser.class);

  private List<ChangeGroupBuilder> myChangeGroupBuilders;
  private EditorComponent myLastEditor;
  private NextPreviousTraverser.TheAction myPreviousAction = new NextPreviousTraverser.TheAction(true);
  private NextPreviousTraverser.TheAction myNextAction = new NextPreviousTraverser.TheAction(false);
  private ActionToolbar myActionToolbar = null;

  public NextPreviousTraverser(@NotNull List<ChangeGroupBuilder> changeGroupBuilders, @NotNull EditorComponent firstEditor) {
    myChangeGroupBuilders = changeGroupBuilders;
    myLastEditor = firstEditor;

    final SelectionListener selectionListener = new SelectionListener() {
      public void selectionChanged(EditorComponent editorComponent, Selection oldSelection, Selection newSelection) {
        myLastEditor = editorComponent;
        updateToolbar();
      }
    };
    ListSequence.fromList(myChangeGroupBuilders).visitAll(new IVisitor<ChangeGroupBuilder>() {
      public void visit(ChangeGroupBuilder cgb) {
        cgb.addInvalidateListener(new ChangeGroupInvalidateListener() {
          public void changeGroupsInvalidated() {
            updateToolbar();
          }
        });
      }
    });
    SetSequence.fromSet(SetSequence.fromSetWithValues(new HashSet<EditorComponent>(), ListSequence.fromList(myChangeGroupBuilders).translate(new ITranslator2<ChangeGroupBuilder, EditorComponent>() {
      public Iterable<EditorComponent> translate(ChangeGroupBuilder b) {
        return Arrays.asList(b.getLeftComponent(), b.getRightComponent());
      }
    }))).visitAll(new IVisitor<EditorComponent>() {
      public void visit(EditorComponent ec) {
        ec.getSelectionManager().addSelectionListener(selectionListener);
      }
    });
  }

  public void setActionToolbar(ActionToolbar actionToolbar) {
    myActionToolbar = actionToolbar;
  }

  private void updateToolbar() {
    if (myActionToolbar != null) {
      ApplicationManager.getApplication().invokeLater(new Runnable() {
        public void run() {
          myActionToolbar.updateActionsImmediately();
        }
      });
    }
  }

  @Nullable
  private ChangeGroupBuilder getBuilderAsLeft() {
    return ListSequence.fromList(myChangeGroupBuilders).findFirst(new IWhereFilter<ChangeGroupBuilder>() {
      public boolean accept(ChangeGroupBuilder b) {
        return b.getLeftComponent() == myLastEditor;
      }
    });
  }

  @Nullable
  private ChangeGroupBuilder getBuilderAsRight() {
    return ListSequence.fromList(myChangeGroupBuilders).findFirst(new IWhereFilter<ChangeGroupBuilder>() {
      public boolean accept(ChangeGroupBuilder b) {
        return b.getRightComponent() == myLastEditor;
      }
    });
  }

  private Bounds findNeighbourGroupAsLeftOrRight(final int currentY, boolean previous, final boolean left) {
    assert ListSequence.fromList(myChangeGroupBuilders).any(new IWhereFilter<ChangeGroupBuilder>() {
      public boolean accept(ChangeGroupBuilder b) {
        return b.getLeftComponent() == myLastEditor || b.getRightComponent() == myLastEditor;
      }
    });

    ChangeGroupBuilder builder = (left ?
      getBuilderAsLeft() :
      getBuilderAsRight()
    );
    if (builder == null) {
      return null;
    }
    List<ChangeGroup> changeGroups = builder.getChangeGroups();
    ChangeGroup changeGroup;
    if (previous) {
      changeGroup = ListSequence.fromList(changeGroups).findLast(new IWhereFilter<ChangeGroup>() {
        public boolean accept(ChangeGroup cg) {
          return (int) cg.getBounds(left).end() < currentY;
        }
      });
    } else {
      changeGroup = ListSequence.fromList(changeGroups).findFirst(new IWhereFilter<ChangeGroup>() {
        public boolean accept(ChangeGroup cg) {
          return (int) cg.getBounds(left).start() > currentY;
        }
      });
    }
    return check_mf966z_a7a4(changeGroup, left);
  }

  private Bounds getNeighbourGroupBounds(boolean previous) {
    // -1 means that group is not available 

    int currentY = myLastEditor.getViewport().getViewPosition().y;
    EditorCell selectedCell = myLastEditor.getSelectedCell();
    if (selectedCell != null) {
      currentY = selectedCell.getY();
    }
    Bounds asLeft = findNeighbourGroupAsLeftOrRight(currentY, previous, true);
    Bounds asRight = findNeighbourGroupAsLeftOrRight(currentY, previous, false);
    Bounds max;
    Bounds min;
    if (asLeft == null) {
      {
        Tuples._2<Bounds, Bounds> _tmp_mf966z_a0j0f = MultiTuple.<Bounds,Bounds>from(null, asRight);
        min = _tmp_mf966z_a0j0f._0();
        max = _tmp_mf966z_a0j0f._1();
      }
    } else if (asRight == null) {
      {
        Tuples._2<Bounds, Bounds> _tmp_mf966z_a0a9a5 = MultiTuple.<Bounds,Bounds>from(null, asLeft);
        min = _tmp_mf966z_a0a9a5._0();
        max = _tmp_mf966z_a0a9a5._1();
      }
    } else {
      if ((int) asLeft.start() < (int) asRight.start()) {
        {
          Tuples._2<Bounds, Bounds> _tmp_mf966z_a0a0a9a5 = MultiTuple.<Bounds,Bounds>from(asLeft, asRight);
          min = _tmp_mf966z_a0a0a9a5._0();
          max = _tmp_mf966z_a0a0a9a5._1();
        }
      } else {
        {
          Tuples._2<Bounds, Bounds> _tmp_mf966z_a0a0a0j0f = MultiTuple.<Bounds,Bounds>from(asRight, asLeft);
          min = _tmp_mf966z_a0a0a0j0f._0();
          max = _tmp_mf966z_a0a0a0j0f._1();
        }
      }
    }
    if (asLeft != null && asRight != null) {
      return (previous ?
        max :
        min
      );
    } else {
      return max;
    }
  }

  public BaseAction previousAction() {
    return myPreviousAction;
  }

  public BaseAction nextAction() {
    return myNextAction;
  }

  private void goToChangeGroup(Bounds bounds) {
    goToY((int) bounds.end());
    goToY((int) bounds.start());
  }

  private void goToY(int y) {
    EditorCell editorCell = myLastEditor.findCellWeak(1, y + 1);
    if (editorCell != null) {
      myLastEditor.changeSelection(editorCell);
    } else {
      if (log.isWarnEnabled()) {
        log.warn(String.format("Could not find cell for coordinates (1, %d), editor for concept %s", y, ModelAccess.instance().<String>runReadAction(new Computable<String>() {
          public String compute() {
            return check_mf966z_a0a0a2a0a0b0j(myLastEditor.getEditedNode());
          }
        })));
      }
    }
  }

  private static Bounds check_mf966z_a7a4(ChangeGroup checkedDotOperand, boolean left) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getBounds(left);
    }
    return null;
  }

  private static String check_mf966z_a0a0a2a0a0b0j(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getConceptFqName();
    }
    return null;
  }

  private class TheAction extends BaseAction {
    private boolean myPrevious;

    private TheAction(boolean previous) {
      super("Go to " + ((previous ?
        "Previous" :
        "Next"
      )) + " Change", null, (previous ?
        NextPreviousTraverser.PREVIOUS_ICON :
        NextPreviousTraverser.NEXT_ICON
      ));
      setDisableOnNoProject(false);
      setExecuteOutsideCommand(true);
      myPrevious = previous;
    }

    protected void doExecute(AnActionEvent event, Map<String, Object> map) {
      assert getNeighbourGroupBounds(myPrevious) != null;
      goToChangeGroup(getNeighbourGroupBounds(myPrevious));
    }

    @Override
    protected void doUpdate(AnActionEvent event, Map<String, Object> map) {
      event.getPresentation().setEnabled(getNeighbourGroupBounds(myPrevious) != null);
    }
  }
}
