package jetbrains.mps.vcs.diff;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SModel;
import java.util.Map;
import jetbrains.mps.vcs.diff.oldchanges.OldChange;
import jetbrains.mps.smodel.SNode;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.smodel.SNodeId;
import java.util.HashSet;
import jetbrains.mps.vcs.diff.oldchanges.DeleteNodeChange;
import jetbrains.mps.util.CollectionUtil;
import jetbrains.mps.vcs.diff.oldchanges.NewNodeChange;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.vcs.diff.oldchanges.ModelImportChange;
import jetbrains.mps.vcs.diff.oldchanges.AddLanguageAspectChange;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.vcs.diff.oldchanges.ChangeConceptChange;
import jetbrains.mps.vcs.diff.oldchanges.UsedLanguagesChange;
import jetbrains.mps.vcs.diff.oldchanges.UsedDevkitsChange;
import jetbrains.mps.vcs.diff.oldchanges.EngagedOnGenerationLanguagesChange;
import java.util.LinkedHashSet;
import jetbrains.mps.vcs.diff.oldchanges.SetNodeChange;
import jetbrains.mps.vcs.diff.oldchanges.AddNodeChange;
import jetbrains.mps.vcs.diff.oldchanges.OldAddRootChange;
import org.apache.commons.lang.ObjectUtils;
import jetbrains.mps.vcs.diff.oldchanges.MoveNodeChange;
import jetbrains.mps.vcs.diff.oldchanges.OldSetPropertyChange;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.vcs.diff.oldchanges.OldSetReferenceChange;
import jetbrains.mps.vcs.diff.oldchanges.DeleteReferenceChange;
import jetbrains.mps.smodel.search.SModelSearchUtil;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

@Deprecated
public class DiffBuilder {
  private static final Logger LOG = Logger.getLogger(DiffBuilder.class);

  private SModel myOldModel;
  private SModel myNewModel;
  private Map<OldChange, SNode> myChangeGroups = new HashMap<OldChange, SNode>();
  private List<OldChange> myChanges = new ArrayList<OldChange>();

  @Deprecated
  public DiffBuilder(SModel oldModel, SModel newModel) {
    myOldModel = oldModel;
    myNewModel = newModel;
    collectChanges();
  }

  private void collectChanges() {
    Set<SNodeId> intersect = new HashSet<SNodeId>();
    Map<SNodeId, SNode> onlyOld = new HashMap<SNodeId, SNode>();
    Map<SNodeId, SNode> onlyNew = new HashMap<SNodeId, SNode>();
    for (SNode node : myOldModel.nodes()) {
      SNodeId id = node.getSNodeId();
      if (myNewModel.getNodeById(id) != null) {
        intersect.add(id);
      } else {
        onlyOld.put(id, node);
      }
    }
    for (SNode node : myNewModel.nodes()) {
      SNodeId id = node.getSNodeId();
      if (myOldModel.getNodeById(id) == null) {
        onlyNew.put(id, node);
      }
    }
    collectAddedLanguageImports();
    collectChangedUsedDevkits();
    collectEngagedOnGenerationLanguages();
    collectAddedModelImport();
    collectLanguageAspects();
    collectDeletedNodes(onlyOld);
    collectAddedNodes(onlyNew);
    collectMovedNodes(intersect);
    collectPropertyChanges();
    collectReferenceChanges();
    collectConceptChanges(intersect);
    makeChangeGroups();
  }

  private void makeChangeGroups() {
    Set<SNodeId> deletedNodes = new HashSet<SNodeId>();
    for (DeleteNodeChange change : CollectionUtil.filter(DeleteNodeChange.class, myChanges)) {
      deletedNodes.add(change.getAffectedNodeId());
    }
    for (DeleteNodeChange change : CollectionUtil.filter(DeleteNodeChange.class, myChanges)) {
      SNode deleted = myOldModel.getNodeById(change.getAffectedNodeId());
      assert deleted != null;
      SNode deleteRoot = deleted;
      while (deleteRoot.getParent() != null && deletedNodes.contains(deleteRoot.getParent().getSNodeId())) {
        deleteRoot = deleteRoot.getParent();
      }
      myChangeGroups.put(change, deleteRoot);
    }
    Set<SNodeId> addedNodes = new HashSet<SNodeId>();
    for (NewNodeChange change : CollectionUtil.filter(NewNodeChange.class, myChanges)) {
      addedNodes.add(change.getAffectedNodeId());
    }
    for (OldChange change : myChanges) {
      SNodeId id = change.getAffectedNodeId();
      if (id == null) {
        continue;
      }
      SNode added = myNewModel.getNodeById(id);
      if (added == null) {
        continue;
      }
      SNode addRoot = added;
      while (addRoot.getParent() != null && addedNodes.contains(addRoot.getParent().getSNodeId())) {
        addRoot = addRoot.getParent();
      }
      myChangeGroups.put(change, addRoot);
    }
  }

  public Map<OldChange, SNode> getChangeGroups() {
    return myChangeGroups;
  }

  private void collectAddedModelImport() {
    List<SModelReference> oldImportElements = SModelOperations.getImportedModelUIDs(myOldModel);
    List<SModelReference> newImportElements = SModelOperations.getImportedModelUIDs(myNewModel);
    Set<SModelReference> addedImports = getDiff(oldImportElements, newImportElements);
    Set<SModelReference> deletedImports = getDiff(newImportElements, oldImportElements);
    for (SModelReference ref : addedImports) {
      myChanges.add(new ModelImportChange(ref, false));
    }
    for (SModelReference ref : deletedImports) {
      myChanges.add(new ModelImportChange(ref, true));
    }
  }

  private void collectLanguageAspects() {
    List<SModel.ImportElement> oldImportElements = myOldModel.getAdditionalModelVersions();
    for (SModel.ImportElement importElement : myNewModel.getAdditionalModelVersions()) {
      boolean alreadyPresent = false;
      for (SModel.ImportElement oldImportElement : oldImportElements) {
        if (oldImportElement.getModelReference().equals(importElement.getModelReference()) && oldImportElement.getReferenceID() == importElement.getReferenceID()) {
          alreadyPresent = true;
          break;
        }
      }
      if (!(alreadyPresent)) {
        myChanges.add(new AddLanguageAspectChange(importElement));
      }
    }
  }

  private void collectConceptChanges(Set<SNodeId> intersected) {
    for (SNodeId id : intersected) {
      SNode newNode = myNewModel.getNodeById(id);
      SNode oldNode = myOldModel.getNodeById(id);
      assert newNode != null;
      assert oldNode != null;
      String oldConceptName = oldNode.getConceptFqName();
      String newConceptName = newNode.getConceptFqName();
      if (!(oldConceptName.equals(newConceptName))) {
        ModuleReference oldLanguage = oldNode.getConceptLanguage();
        ModuleReference newLanguage = newNode.getConceptLanguage();
        if ((newLanguage != null) && (oldLanguage != null) && newLanguage.equals(oldLanguage)) {
          int oldVersion = getStructureImportVersion(myOldModel, oldLanguage);
          int newVersion = getStructureImportVersion(myNewModel, newLanguage);
          if (oldVersion != newVersion) {
            LOG.debug("Refactoring in language " + oldLanguage + " from " + oldVersion + " to " + newVersion + ".\n" + "Ignoring concept change of node " + id + " from " + oldConceptName + " to " + newConceptName);
            continue;
          }
        }
        myChanges.add(new ChangeConceptChange(id, newConceptName));
      }
    }
  }

  private int getStructureImportVersion(SModel model, ModuleReference language) {
    for (SModel.ImportElement el : model.getAdditionalModelVersions()) {
      if ((language.getModuleFqName() + ".structure").equals(el.getModelReference().getLongName())) {
        return el.getUsedVersion();
      }
    }
    return -1;
  }

  private void collectAddedLanguageImports() {
    List<ModuleReference> oldLanguages = myOldModel.importedLanguages();
    List<ModuleReference> newLanguages = myNewModel.importedLanguages();
    Set<ModuleReference> addedImports = getDiff(oldLanguages, newLanguages);
    Set<ModuleReference> deletedImports = getDiff(newLanguages, oldLanguages);
    for (ModuleReference ref : addedImports) {
      myChanges.add(new UsedLanguagesChange(ref, false));
    }
    for (ModuleReference ref : deletedImports) {
      myChanges.add(new UsedLanguagesChange(ref, true));
    }
  }

  private void collectChangedUsedDevkits() {
    List<ModuleReference> oldDevkits = myOldModel.importedDevkits();
    List<ModuleReference> newDevkits = myNewModel.importedDevkits();
    Set<ModuleReference> addedDevkits = getDiff(oldDevkits, newDevkits);
    Set<ModuleReference> deletedDevkits = getDiff(newDevkits, oldDevkits);
    for (ModuleReference ref : addedDevkits) {
      myChanges.add(new UsedDevkitsChange(ref, false));
    }
    for (ModuleReference ref : deletedDevkits) {
      myChanges.add(new UsedDevkitsChange(ref, true));
    }
  }

  private void collectEngagedOnGenerationLanguages() {
    List<ModuleReference> oldLanguages = myOldModel.engagedOnGenerationLanguages();
    List<ModuleReference> newLanguages = myNewModel.engagedOnGenerationLanguages();
    Set<ModuleReference> addedImports = getDiff(oldLanguages, newLanguages);
    Set<ModuleReference> deletedImports = getDiff(newLanguages, oldLanguages);
    for (ModuleReference ref : addedImports) {
      myChanges.add(new EngagedOnGenerationLanguagesChange(ref, false));
    }
    for (ModuleReference ref : deletedImports) {
      myChanges.add(new EngagedOnGenerationLanguagesChange(ref, true));
    }
  }

  private <C> Set<C> getDiff(List<C> oldList, List<C> newList) {
    Set<C> addedImports = new LinkedHashSet<C>(newList);
    addedImports.removeAll(oldList);
    return addedImports;
  }

  private void collectDeletedNodes(Map<SNodeId, SNode> onlyOld) {
    for (Map.Entry<SNodeId, SNode> entry : onlyOld.entrySet()) {
      List<SNodeId> childrenIds = new ArrayList<SNodeId>();
      for (SNode child : entry.getValue().getChildren()) {
        childrenIds.add(child.getSNodeId());
      }
      myChanges.add(new DeleteNodeChange(entry.getKey(), childrenIds));
    }
  }

  private void collectAddedNodes(Map<SNodeId, SNode> onlyNew) {
    for (Map.Entry<SNodeId, SNode> entry : onlyNew.entrySet()) {
      SNode node = entry.getValue();
      SNodeId id = entry.getKey();
      assert node != null;
      String role = node.getRole_();
      if (role != null) {
        if (!(isMultipleCardinality(node.getParent().getConceptFqName(), role))) {
          SNodeId parentId = node.getParent().getSNodeId();
          SNode oldParent = myOldModel.getNodeById(parentId);
          SNodeId oldChildId = null;
          if (oldParent != null) {
            if (oldParent.getChild(role) != null) {
              oldChildId = oldParent.getChild(role).getSNodeId();
            }
          }
          String prevRole = null;
          SNode prevSibling = node.prevSibling();
          if (prevSibling != null) {
            prevRole = prevSibling.getRole_();
          }
          myChanges.add(new SetNodeChange(node.getConceptFqName(), id, role, parentId, oldChildId, prevRole));
        } else {
          SNode prevChild = node.getParent().getPrevChild(node);
          SNodeId prevId = null;
          String prevRole = null;
          if (prevChild != null) {
            prevId = prevChild.getSNodeId();
          } else {
            SNode prevSubling = node.prevSibling();
            if (prevSubling != null) {
              prevRole = prevSubling.getRole_();
            }
          }
          myChanges.add(new AddNodeChange(node.getConceptFqName(), id, role, node.getParent().getSNodeId(), prevId, prevRole));
        }
      } else {
        myChanges.add(new OldAddRootChange(node.getConceptFqName(), id));
      }
    }
  }

  private void collectMovedNodes(Set<SNodeId> intersect) {
    for (SNodeId id : intersect) {
      SNode n = myNewModel.getNodeById(id);
      SNode o = myOldModel.getNodeById(id);
      assert n != null && o != null;
      SNodeId nid = getParentId(n);
      SNodeId oid = getParentId(o);
      SNode nPrevSibling = n.prevSibling();
      SNode oPrevSibling = o.prevSibling();
      if (ObjectUtils.equals(nid, oid)) {
        if (nPrevSibling == oPrevSibling) {
          continue;
        }
        if (nPrevSibling != null && oPrevSibling != null && nPrevSibling.getId().equals(oPrevSibling.getId())) {
          continue;
        }
        if (nPrevSibling != null && getChangesFor(nPrevSibling.getSNodeId()).size() > 0) {
          continue;
        }
        if (oPrevSibling != null && getChangesFor(oPrevSibling.getSNodeId()).size() > 0) {
          continue;
        }
      }
      if (nPrevSibling != null) {
        myChanges.add(new MoveNodeChange(id, nid, nPrevSibling.getSNodeId(), n.getRole_()));
      } else {
        myChanges.add(new MoveNodeChange(id, nid, null, n.getRole_()));
      }
    }
  }

  private List<OldChange> getChangesFor(SNodeId sNodeId) {
    List<OldChange> result = new ArrayList<OldChange>();
    for (OldChange change : myChanges) {
      if (sNodeId.equals(change.getAffectedNodeId())) {
        result.add(change);
      }
    }
    return result;
  }

  private SNodeId getParentId(SNode n) {
    if (n.getParent() == null) {
      return null;
    }
    return n.getParent().getSNodeId();
  }

  private void collectPropertyChanges() {
    for (SNode newNode : myNewModel.nodes()) {
      SNodeId id = newNode.getSNodeId();
      SNode oldNode = myOldModel.getNodeById(id);
      if (oldNode == null) {
        for (String prop : newNode.getProperties().keySet()) {
          myChanges.add(new OldSetPropertyChange(id, prop, newNode.getProperties().get(prop)));
        }
      } else {
        Set<String> newNodeProps = newNode.getPropertyNames();
        Set<String> oldNodeProps = oldNode.getPropertyNames();
        Set<String> deletedProps = new HashSet<String>(oldNodeProps);
        deletedProps.removeAll(newNodeProps);
        for (String deletedProp : deletedProps) {
          myChanges.add(new OldSetPropertyChange(id, deletedProp, null));
        }
        for (String nnp : newNodeProps) {
          if (!(eq(newNode.getProperties().get(nnp), oldNode.getProperties().get(nnp)))) {
            myChanges.add(new OldSetPropertyChange(id, nnp, newNode.getProperties().get(nnp)));
          }
        }
      }
    }
  }

  private boolean eq(Object o1, Object o2) {
    if (o1 == null) {
      return o1 == o2;
    }
    return o1.equals(o2);
  }

  private void collectReferenceChanges() {
    for (SNode newNode : myNewModel.nodes()) {
      SNodeId id = newNode.getSNodeId();
      SNode oldNode = myOldModel.getNodeById(id);
      if (oldNode == null) {
        for (SReference ref : newNode.getReferences()) {
          myChanges.add(new OldSetReferenceChange(id, myNewModel, ref, ref.getTargetNode()));
        }
      } else {
        Set<String> roles = new HashSet<String>(newNode.getReferenceRoles());
        roles.addAll(oldNode.getReferenceRoles());
        for (String role : roles) {
          if (!(isMultipleCardinality(newNode.getConceptFqName(), role))) {
            if (oldNode.getReference(role) != null && newNode.getReference(role) == null) {
              myChanges.add(new DeleteReferenceChange(id, myNewModel, oldNode.getReference(role)));
            } else {
              if (!(("" + getTargetId(newNode.getReference(role))).equals("" + getTargetId(oldNode.getReference(role))))) {
                myChanges.add(new OldSetReferenceChange(id, myNewModel, newNode.getReference(role), newNode.getReferent(role)));
              }
            }
          } else {
            System.out.println("we have too many references : " + newNode + " " + newNode.getId());
            System.out.println("role : " + role);
            System.out.println("not supported!");
            isMultipleCardinality(newNode.getConceptFqName(), role);
          }
        }
      }
    }
  }

  private String getTargetId(SReference ref) {
    if (ref == null) {
      return null;
    }
    SNodeId id = ref.getTargetNodeId();
    if (id == null) {
      return null;
    }
    return id.toString();
  }

  private boolean isMultipleCardinality(String fqName, String role) {
    SNode ld = (SNode) SModelSearchUtil.findLinkDeclaration(SModelUtil.findConceptDeclaration(fqName, GlobalScope.getInstance()), role);
    if (ld == null) {
      return false;
    }
    return SPropertyOperations.hasValue(ld, "sourceCardinality", "1..n", "0..1") || SPropertyOperations.hasValue(ld, "sourceCardinality", "0..n", "0..1");
  }

  public List<OldChange> getChanges() {
    return new ArrayList<OldChange>(myChanges);
  }
}
