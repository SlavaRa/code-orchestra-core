package jetbrains.mps.vcs.diff.merge;

/*Generated by MPS */

import jetbrains.mps.vcs.diff.changes.ChangeSet;
import java.util.Map;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.SModel;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.vcs.diff.changes.NodeCopier;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.vcs.diff.changes.MetadataChange;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.vcs.diff.changes.NodeChange;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Collections;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.SModelAdapter;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import jetbrains.mps.smodel.event.SModelRootEvent;

public class MergeContext {
  private ChangeSet myMineChangeSet;
  private ChangeSet myRepositoryChangeSet;
  private Map<ModelChange, List<ModelChange>> myConflictingChanges = MapSequence.fromMap(new HashMap<ModelChange, List<ModelChange>>());
  private Map<ModelChange, List<ModelChange>> mySymmetricChanges = MapSequence.fromMap(new HashMap<ModelChange, List<ModelChange>>());
  private Map<SNodeId, List<ModelChange>> myRootToChanges = MapSequence.fromMap(new HashMap<SNodeId, List<ModelChange>>());
  private Map<SNodeId, List<ModelChange>> myNodeToChanges = MapSequence.fromMap(new HashMap<SNodeId, List<ModelChange>>());
  private List<ModelChange> myMetadataChanges = ListSequence.fromList(new ArrayList<ModelChange>());
  private SModel myResultModel;
  private Set<ModelChange> myResolvedChanges = SetSequence.fromSet(new HashSet<ModelChange>());
  private NodeCopier myNodeCopier;
  private MergeContext.MyResultModelListener myModelListener = new MergeContext.MyResultModelListener();
  private MergeContext.ChangesInvalidateHandler myChangesInvalidateHandler;

  public MergeContext(final SModel base, final SModel mine, final SModel repository) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        MergeConflictsBuilder conflictsBuilder = new MergeConflictsBuilder(base, mine, repository);
        myMineChangeSet = conflictsBuilder.myMineChangeSet;
        myRepositoryChangeSet = conflictsBuilder.myRepositoryChangeSet;
        myConflictingChanges = conflictsBuilder.myConflictingChanges;
        mySymmetricChanges = conflictsBuilder.mySymmetricChanges;
        fillRootToChangesMap();
        fillNodeToChangesMap();

        myResultModel = CopyUtil.copyModel(base);
        int pv = Math.max(base.getPersistenceVersion(), Math.max(mine.getPersistenceVersion(), repository.getPersistenceVersion()));
        myResultModel.setPersistenceVersion(pv);
        myNodeCopier = new NodeCopier(myResultModel);
      }
    });
  }

  private void fillRootToChangesMap() {
    for (ModelChange change : Sequence.fromIterable(getAllChanges())) {
      SNodeId rootId = change.getRootId();
      if (rootId == null) {
        assert change instanceof MetadataChange;
        ListSequence.fromList(myMetadataChanges).addElement(change);
      } else {
        if (MapSequence.fromMap(myRootToChanges).get(rootId) == null) {
          MapSequence.fromMap(myRootToChanges).put(rootId, ListSequence.fromList(new ArrayList<ModelChange>()));
        }
        ListSequence.fromList(MapSequence.fromMap(myRootToChanges).get(rootId)).addElement(change);
      }
    }
  }

  public void installResultModelListener() {
    myResultModel.getModelDescriptor().addModelListener(myModelListener);
  }

  private void fillNodeToChangesMap() {
    for (ModelChange change : Sequence.fromIterable(getAllChanges())) {
      SNodeId nodeId = null;
      if (change instanceof NodeGroupChange) {
        nodeId = ((NodeGroupChange) change).getParentNodeId();
      } else if (change instanceof NodeChange) {
        nodeId = ((NodeChange) change).getAffectedNodeId();
      } else if (change instanceof AddRootChange || change instanceof DeleteRootChange) {
        nodeId = change.getRootId();
      }
      if (nodeId != null) {
        if (MapSequence.fromMap(myNodeToChanges).get(nodeId) == null) {
          MapSequence.fromMap(myNodeToChanges).put(nodeId, ListSequence.fromList(new ArrayList<ModelChange>()));
        }
        ListSequence.fromList(MapSequence.fromMap(myNodeToChanges).get(nodeId)).addElement(change);
      }
    }
  }

  public Iterable<ModelChange> getApplicableChangesForRoot(SNodeId rootId) {
    return ListSequence.fromList(MapSequence.fromMap(myRootToChanges).get(rootId)).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(SetSequence.fromSet(myResolvedChanges).contains(ch)) && Sequence.fromIterable(getConflictedWith(ch)).isEmpty();
      }
    });
  }

  public Iterable<ModelChange> getApplicableChangesInNonConflictingRoots() {
    return SetSequence.fromSet(MapSequence.fromMap(myRootToChanges).keySet()).translate(new ITranslator2<SNodeId, ModelChange>() {
      public Iterable<ModelChange> translate(SNodeId root) {
        Iterable<ModelChange> unresolvedForRoot = ListSequence.fromList(MapSequence.fromMap(myRootToChanges).get(root)).where(new IWhereFilter<ModelChange>() {
          public boolean accept(ModelChange ch) {
            return !(SetSequence.fromSet(myResolvedChanges).contains(ch));
          }
        });
        if (Sequence.fromIterable(unresolvedForRoot).all(new IWhereFilter<ModelChange>() {
          public boolean accept(ModelChange ch) {
            return Sequence.fromIterable(getConflictedWith(ch)).isEmpty();
          }
        })) {
          return unresolvedForRoot;
        } else {
          return Sequence.fromIterable(Collections.<ModelChange>emptyList());
        }
      }
    }).concat(ListSequence.fromList(myMetadataChanges).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(SetSequence.fromSet(myResolvedChanges).contains(ch));
      }
    }));
  }

  public Iterable<ModelChange> getAllChanges() {
    return ListSequence.fromList(myMineChangeSet.getModelChanges()).concat(ListSequence.fromList(myRepositoryChangeSet.getModelChanges()));
  }

  public Iterable<SNodeId> getAffectedRoots() {
    return (ListSequence.fromList(myMetadataChanges).isEmpty() ?
      MapSequence.fromMap(myRootToChanges).keySet() :
      SetSequence.fromSet(MapSequence.fromMap(myRootToChanges).keySet()).concat(ListSequence.fromList(ListSequence.fromListAndArray(new ArrayList<SNodeId>(), null)))
    );
  }

  public List<ModelChange> getChangesForRoot(@NotNull SNodeId rootId) {
    return MapSequence.fromMap(myRootToChanges).get(rootId);
  }

  public List<ModelChange> getMetadataChanges() {
    return myMetadataChanges;
  }

  public Iterable<ModelChange> getConflictedWith(ModelChange change) {
    return ListSequence.fromList(MapSequence.fromMap(myConflictingChanges).get(change)).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange other) {
        return !(SetSequence.fromSet(myResolvedChanges).contains(other));
      }
    });
  }

  public boolean isChangeResolved(ModelChange change) {
    return SetSequence.fromSet(myResolvedChanges).contains(change);
  }

  public void applyChanges(Iterable<ModelChange> changes) {
    applyChangesNoRestoreIds(changes);
    myNodeCopier.restoreIds(false);
  }

  public void excludeChanges(Iterable<ModelChange> changes) {
    excludeChangesNoRestoreIds(changes);
    myNodeCopier.restoreIds(false);
  }

  private void applyChangesNoRestoreIds(Iterable<ModelChange> changes) {
    Sequence.fromIterable(changes).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return ch instanceof NodeGroupChange;
      }
    }).visitAll(new IVisitor<ModelChange>() {
      public void visit(ModelChange ch) {
        ((NodeGroupChange) ch).prepare();
      }
    });
    for (ModelChange c : Sequence.fromIterable(changes)) {
      applyChange(c);
    }
  }

  private void excludeChangesNoRestoreIds(Iterable<ModelChange> changes) {
    for (ModelChange c : Sequence.fromIterable(changes)) {
      excludeChange(c);
    }
  }

  private void applyChange(ModelChange change) {
    if (SetSequence.fromSet(myResolvedChanges).contains(change)) {
    } else {
      change.apply(myResultModel, myNodeCopier);
      SetSequence.fromSet(myResolvedChanges).addElement(change);
      SetSequence.fromSet(myResolvedChanges).addSequence(ListSequence.fromList(MapSequence.fromMap(mySymmetricChanges).get(change)));
      excludeChangesNoRestoreIds(getConflictedWith(change));
    }
  }

  private void excludeChange(ModelChange change) {
    if (SetSequence.fromSet(myResolvedChanges).contains(change)) {
    } else {
      SetSequence.fromSet(myResolvedChanges).addElement(change);
      SetSequence.fromSet(myResolvedChanges).addSequence(ListSequence.fromList(MapSequence.fromMap(mySymmetricChanges).get(change)));
    }
  }

  public boolean hasIdsToRestore() {
    return myNodeCopier.hasIdsToRestore();
  }

  public SNodeId getReplacementId(SNodeId originalId) {
    return myNodeCopier.getReplacementId(originalId);
  }

  public SModel getResultModel() {
    return myResultModel;
  }

  public SModel getBaseModel() {
    return myMineChangeSet.getOldModel();
  }

  public SModel getMyModel() {
    return myMineChangeSet.getNewModel();
  }

  public SModel getRepositoryModel() {
    return myRepositoryChangeSet.getNewModel();
  }

  public ChangeSet getMyChangeSet() {
    return myMineChangeSet;
  }

  public ChangeSet getRepositoryChangeSet() {
    return myRepositoryChangeSet;
  }

  public boolean isMyChange(ModelChange change) {
    return change.getChangeSet() == myMineChangeSet;
  }

  public MergeContextState getCurrentState() {
    return new MergeContextState(myResultModel, myResolvedChanges, myNodeCopier.getState());
  }

  public void restoreState(MergeContextState state) {
    myResultModel.setLoading(true);
    MergeContextState stateCopy = new MergeContextState(state);
    ListSequence.fromList(SModelOperations.getRoots(myResultModel, null)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode r) {
        SNodeOperations.deleteNode(r);
      }
    });
    CopyUtil.clearModelProperties(myResultModel);
    CopyUtil.copyModelProperties(stateCopy.myResultModel, myResultModel);
    ListSequence.fromList(SModelOperations.getRoots(stateCopy.myResultModel, null)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode r) {
        SModelOperations.addRootNode(myResultModel, r);
      }
    });
    myResultModel.setLoading(false);

    myResolvedChanges = stateCopy.myResolvedChanges;
    myNodeCopier.setState(stateCopy.myIdReplacementCache, myResultModel);
  }

  public void setChangesInvalidateHandler(MergeContext.ChangesInvalidateHandler changesInvalidateHandler) {
    myChangesInvalidateHandler = changesInvalidateHandler;
  }

  private void invalidateChanges(Iterable<ModelChange> changes) {
    if (Sequence.fromIterable(changes).isNotEmpty()) {
      SetSequence.fromSet(myResolvedChanges).addSequence(Sequence.fromIterable(changes));
      check_358wfv_a1a0a92(myChangesInvalidateHandler);
    }
  }

  private static void check_358wfv_a1a0a92(MergeContext.ChangesInvalidateHandler checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.someChangesInvalidated();
    }

  }

  public static interface ChangesInvalidateHandler {
    public void someChangesInvalidated();
  }

  private class MyResultModelListener extends SModelAdapter {
    private MyResultModelListener() {
    }

    private void invalidateDeletedRoot(SModelEvent event) {
      assert event.getAffectedRoot() != null;
      List<ModelChange> nodeChanges = MapSequence.fromMap(myNodeToChanges).get(event.getAffectedRoot().getSNodeId());
      invalidateChanges(ListSequence.fromList(nodeChanges).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return ch instanceof DeleteRootChange;
        }
      }));
    }

    private void beforeNodeRemovedRecursively(SNode node) {
      for (SNode child : ListSequence.fromList(SNodeOperations.getChildren(node))) {
        beforeNodeRemovedRecursively(child);
      }

      // process child 
      invalidateChanges(MapSequence.fromMap(myNodeToChanges).get(node.getSNodeId()));
    }

    private void referenceModified(SModelReferenceEvent event) {
      List<ModelChange> nodeChanges = MapSequence.fromMap(myNodeToChanges).get(event.getReference().getSourceNode().getSNodeId());
      invalidateChanges(ListSequence.fromList(nodeChanges).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return ch instanceof SetReferenceChange;
        }
      }));
      invalidateDeletedRoot(event);
    }

    @Override
    public void referenceRemoved(SModelReferenceEvent event) {
      referenceModified(event);
      invalidateDeletedRoot(event);
    }

    @Override
    public void referenceAdded(SModelReferenceEvent event) {
      referenceModified(event);
      invalidateDeletedRoot(event);
    }

    private List<NodeGroupChange> getRelevantNodeGroupChanges(SNode parent, final String role) {
      List<ModelChange> nodeChanges = MapSequence.fromMap(myNodeToChanges).get(parent.getSNodeId());
      Iterable<NodeGroupChange> allNodeGroupChanges = ListSequence.fromList(nodeChanges).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange c) {
          return c instanceof NodeGroupChange;
        }
      }).select(new ISelector<ModelChange, NodeGroupChange>() {
        public NodeGroupChange select(ModelChange c) {
          return (NodeGroupChange) c;
        }
      });
      return Sequence.fromIterable(allNodeGroupChanges).where(new IWhereFilter<NodeGroupChange>() {
        public boolean accept(NodeGroupChange ngc) {
          return role.equals(ngc.getRole());
        }
      }).toListSequence();
    }

    private void invalidateChildrenChanges(SNode parent, String role, int index, final int beginOffset, final int endOffset) {
      List<SNode> currentChildren = parent.getChildren(role);

      List<NodeGroupChange> relevantChanges = getRelevantNodeGroupChanges(parent, role);
      if (ListSequence.fromList(relevantChanges).isEmpty()) {
        return;
      }

      SNode baseParent = myMineChangeSet.getOldModel().getNodeById(parent.getSNodeId());
      if (baseParent == null) {
        return;
      }
      List<SNode> baseChildren = baseParent.getChildren(role);

      final Wrappers._int baseIndex = new Wrappers._int();
      if (0 <= index && index < currentChildren.size()) {
        final SNodeId currentChildId = currentChildren.get(index).getSNodeId();
        SNode baseChild = ListSequence.fromList(baseChildren).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode c) {
            return currentChildId.equals(c.getSNodeId());
          }
        });
        if (baseChild == null) {
          return;
        }
        baseIndex.value = SNodeOperations.getIndexInParent(baseChild);
      } else if (index == 0) {
        baseIndex.value = 0;
      } else if (index == currentChildren.size()) {
        baseIndex.value = ListSequence.fromList(baseChildren).count();
      } else {
        return;
      }
      invalidateChanges(ListSequence.fromList(relevantChanges).where(new IWhereFilter<NodeGroupChange>() {
        public boolean accept(NodeGroupChange ch) {
          return ch.getBegin() + beginOffset <= baseIndex.value && baseIndex.value < ch.getEnd() + endOffset;
        }
      }).select(new ISelector<NodeGroupChange, ModelChange>() {
        public ModelChange select(NodeGroupChange ch) {
          return (ModelChange) ch;
        }
      }));
    }

    private void invalidateChildrenChanges(SModelChildEvent event, int offset) {
      int index = event.getParent().getIndexOfChild(event.getChild()) + offset;
      int beginOffset = (offset == 1 ?
        0 :
        -1
      );
      int endOffset = (offset == -1 ?
        0 :
        1
      );
      invalidateChildrenChanges(event.getParent(), event.getChildRole(), index, beginOffset, endOffset);
    }

    @Override
    public void beforeChildRemoved(SModelChildEvent event) {
      beforeNodeRemovedRecursively(event.getChild());
      invalidateDeletedRoot(event);
      invalidateChildrenChanges(event, 0);
    }

    @Override
    public void childAdded(SModelChildEvent event) {
      invalidateDeletedRoot(event);
      invalidateChildrenChanges(event, -1);
      invalidateChildrenChanges(event, 1);
    }

    @Override
    public void propertyChanged(SModelPropertyEvent event) {
      List<ModelChange> nodeChanges = MapSequence.fromMap(myNodeToChanges).get(event.getNode().getSNodeId());
      invalidateChanges(ListSequence.fromList(nodeChanges).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return ch instanceof SetPropertyChange;
        }
      }));
      invalidateDeletedRoot(event);
    }

    @Override
    public void beforeRootRemoved(SModelRootEvent event) {
      beforeNodeRemovedRecursively(event.getRoot());
      invalidateDeletedRoot(event);
    }
  }
}
