package jetbrains.mps.vcs.diff.changes;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;

public class NodeCopier {
  private Map<SNodeId, SNodeId> myIdReplacementCache = MapSequence.fromMap(new HashMap<SNodeId, SNodeId>());
  private SModel myModel;

  public NodeCopier(SModel model) {
    myModel = model;
  }

  public SNodeId getReplacementId(SNodeId originalId) {
    return MapSequence.fromMap(myIdReplacementCache).get(originalId);
  }

  public SNode copyNode(SNode sourceNode) {
    SNode copy = CopyUtil.copyAndPreserveId(sourceNode);
    for (SNode node : ListSequence.fromList(SNodeOperations.getDescendants(copy, null, true, new String[]{}))) {
      SNodeId nodeId = node.getSNodeId();
      if (myModel.getNodeById(nodeId) != null) {
        SNodeId replacedId = SModel.generateUniqueId();
        node.setId(replacedId);
        if (!(MapSequence.fromMap(myIdReplacementCache).containsKey(nodeId))) {
          MapSequence.fromMap(myIdReplacementCache).put(nodeId, replacedId);
        }
      }
    }
    return copy;
  }

  public void restoreIds(boolean affectOthers) {
    softRestoreIds();
    if (affectOthers) {
      evictOtherDuplicates();
      softRestoreIds();
      assert Sequence.fromIterable(MapSequence.fromMap(myIdReplacementCache).values()).all(new IWhereFilter<SNodeId>() {
        public boolean accept(SNodeId id) {
          return id == null;
        }
      });
    }
  }

  private void setId(SNode node, SNodeId id) {
    SModel model = SNodeOperations.getModel(node);
    if (SNodeOperations.getParent(node) == null) {
      SNodeOperations.detachNode(node);
      node.setId(id);
      SModelOperations.addRootNode(model, node);
    } else {
      // hardcoded to get rid of dependency on core language 
      SNode stubNode = new SNode(model, "jetbrains.mps.lang.core.structure.BaseConcept");
      SNodeOperations.replaceWithAnother(node, stubNode);
      node.setId(id);
      SNodeOperations.replaceWithAnother(stubNode, node);
    }
  }

  private void softRestoreIds() {
    for (SNodeId id : SetSequence.fromSet(MapSequence.fromMap(myIdReplacementCache).keySet())) {
      if (MapSequence.fromMap(myIdReplacementCache).get(id) != null && myModel.getNodeById(id) == null) {
        // node id is free now! 
        setId(myModel.getNodeById(MapSequence.fromMap(myIdReplacementCache).get(id)), id);

        MapSequence.fromMap(myIdReplacementCache).put(id, null);
      }
    }
  }

  private void evictOtherDuplicates() {
    for (SNodeId id : SetSequence.fromSet(MapSequence.fromMap(myIdReplacementCache).keySet())) {
      SNode toBeEvicted = myModel.getNodeById(id);
      assert toBeEvicted != null;
      setId(toBeEvicted, SModel.generateUniqueId());
    }
  }

  public Map<SNodeId, SNodeId> getState() {
    final Map<SNodeId, SNodeId> state = MapSequence.fromMap(new HashMap<SNodeId, SNodeId>(MapSequence.fromMap(myIdReplacementCache).count()));
    MapSequence.fromMap(myIdReplacementCache).visitAll(new IVisitor<IMapping<SNodeId, SNodeId>>() {
      public void visit(IMapping<SNodeId, SNodeId> m) {
        MapSequence.fromMap(state).put(m.key(), m.value());
      }
    });
    return state;
  }

  public void setState(Map<SNodeId, SNodeId> state, SModel model) {
    myIdReplacementCache = state;
    myModel = model;
  }

  public boolean hasIdsToRestore() {
    return Sequence.fromIterable(MapSequence.fromMap(myIdReplacementCache).values()).any(new IWhereFilter<SNodeId>() {
      public boolean accept(SNodeId id) {
        return id != null;
      }
    });
  }
}
