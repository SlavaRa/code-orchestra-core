package jetbrains.mps.vcs.diff.oldchanges;

/*Generated by MPS */

import jetbrains.mps.smodel.SNodeId;
import java.util.List;
import java.util.Arrays;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SNode;

@Deprecated
public class MoveNodeChange extends OldChange {
  private SNodeId myNodeId;
  private SNodeId myNewParent;
  private SNodeId myPrevSibling;
  private String myNewRole;

  @Deprecated
  public MoveNodeChange(SNodeId node, SNodeId newParent, SNodeId prevSibling, String newRole) {
    myNodeId = node;
    myNewParent = newParent;
    myNewRole = newRole;
    myPrevSibling = prevSibling;
  }

  public SNodeId getNewParent() {
    return myNewParent;
  }

  public SNodeId getPrevSibling() {
    return myPrevSibling;
  }

  public String getNewRole() {
    return myNewRole;
  }

  public String toString() {
    return "move " + myNodeId + " to " + myNewParent + " before " + myPrevSibling;
  }

  public SNodeId getAffectedNodeId() {
    return myNodeId;
  }

  @Override
  public boolean isSameChange(OldChange c) {
    if (this == c) {
      return true;
    }
    if (c == null || getClass() != c.getClass()) {
      return false;
    }
    MoveNodeChange that = (MoveNodeChange) c;
    if ((myNewParent != null ?
      !(myNewParent.equals(that.myNewParent)) :
      that.myNewParent != null
    )) {
      return false;
    }
    if ((myNewRole != null ?
      !(myNewRole.equals(that.myNewRole)) :
      that.myNewRole != null
    )) {
      return false;
    }
    if (!(myNodeId.equals(that.myNodeId))) {
      return false;
    }
    if ((myPrevSibling != null ?
      !(myPrevSibling.equals(that.myPrevSibling)) :
      that.myPrevSibling != null
    )) {
      return false;
    }
    return true;
  }

  @Override
  public List<SNodeId> getDependencies() {
    return Arrays.asList(myPrevSibling, myNewParent);
  }

  @Override
  public Object getChangeKey() {
    return myNodeId;
  }

  public boolean apply(SModel m) {
    SNode node = m.getNodeById(myNodeId);
    if (node == null) {
      return false;
    }
    SNode parent = m.getNodeById(myNewParent);
    if (parent == null) {
      return false;
    }
    node.getParent().removeChild(node);
    SNode prevSibling = (myPrevSibling == null ?
      null :
      m.getNodeById(myPrevSibling)
    );
    parent.insertChild(prevSibling, myNewRole, node);
    return true;
  }
}
