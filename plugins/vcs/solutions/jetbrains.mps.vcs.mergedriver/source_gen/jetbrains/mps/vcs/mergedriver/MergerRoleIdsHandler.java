package jetbrains.mps.vcs.mergedriver;

/*Generated by MPS */

import jetbrains.mps.smodel.persistence.RoleIdsComponent;
import java.util.Map;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

/*package*/ class MergerRoleIdsHandler implements RoleIdsComponent.RoleIdsHandler {
  private boolean myConsistent = true;
  private Map<String, SNodePointer> myConceptsToPointers = MapSequence.fromMap(new HashMap<String, SNodePointer>());
  private Map<Tuples._2<String, String>, SNodePointer> myNodeRolesToPointers = MapSequence.fromMap(new HashMap<Tuples._2<String, String>, SNodePointer>());
  private Map<Tuples._2<String, String>, SNodePointer> myReferenceRolesToPointers = MapSequence.fromMap(new HashMap<Tuples._2<String, String>, SNodePointer>());
  private Map<Tuples._2<String, String>, SNodePointer> myPropertyNamesToPointers = MapSequence.fromMap(new HashMap<Tuples._2<String, String>, SNodePointer>());
  private Map<SModelReference, Integer> myModelVersions = MapSequence.fromMap(new HashMap<SModelReference, Integer>());

  /*package*/ MergerRoleIdsHandler() {
  }

  private <K, V> void storeAndCheckConsistency(Map<K, V> theMap, K key, V value) {
    if (MapSequence.fromMap(theMap).containsKey(key)) {
      myConsistent = myConsistent && eq_clnjnl_a0a0a0a0a(MapSequence.fromMap(theMap).get(key), value);
    } else {
      MapSequence.fromMap(theMap).put(key, value);
    }
  }

  public void conceptRead(String conceptFqName, SNodePointer conceptPointer) {
    storeAndCheckConsistency(myConceptsToPointers, conceptFqName, conceptPointer);
  }

  public void nodeRoleRead(String conceptFqName, String linkRole, SNodePointer linkPointer) {
    storeAndCheckConsistency(myNodeRolesToPointers, MultiTuple.<String,String>from(conceptFqName, linkRole), linkPointer);
  }

  public void referenceRoleRead(String conceptFqName, String referenceLinkRole, SNodePointer linkPointer) {
    storeAndCheckConsistency(myReferenceRolesToPointers, MultiTuple.<String,String>from(conceptFqName, referenceLinkRole), linkPointer);
  }

  public void propertyNameRead(String conceptFqName, String propertyName, SNodePointer namePointer) {
    storeAndCheckConsistency(myPropertyNamesToPointers, MultiTuple.<String,String>from(conceptFqName, propertyName), namePointer);
  }

  public void modelVersionRead(SModelReference reference, int i) {
    storeAndCheckConsistency(myModelVersions, reference, i);
  }

  public SNodePointer getConceptPointer(String conceptFqName) {
    return MapSequence.fromMap(myConceptsToPointers).get(conceptFqName);
  }

  public SNodePointer getNodeRolePointer(String conceptFqName, String linkRole) {
    return MapSequence.fromMap(myNodeRolesToPointers).get(MultiTuple.<String,String>from(conceptFqName, linkRole));
  }

  public SNodePointer getReferenceRolePointer(String conceptFqName, String referenceLinkRole) {
    return MapSequence.fromMap(myReferenceRolesToPointers).get(MultiTuple.<String,String>from(conceptFqName, referenceLinkRole));
  }

  public SNodePointer getPropertyNamePointer(String conceptFqName, String propertyName) {
    return MapSequence.fromMap(myPropertyNamesToPointers).get(MultiTuple.<String,String>from(conceptFqName, propertyName));
  }

  public int getModelVersion(SModelReference reference) {
    return MapSequence.fromMap(myModelVersions).get(reference);
  }

  /*package*/ boolean isConsistent() {
    return myConsistent;
  }

  private static boolean eq_clnjnl_a0a0a0a0a(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }
}
