package jetbrains.mps.vcs.mergedriver;

/*Generated by MPS */

import java.io.File;
import jetbrains.mps.make.java.ModelDependencies;
import java.io.OutputStream;
import jetbrains.mps.util.FileUtil;
import java.io.IOException;
import org.jdom.JDOMException;
import jetbrains.mps.util.JDOMUtil;
import org.jdom.Document;
import jetbrains.mps.make.java.RootDependencies;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;

/*package*/ class JavaDependenciesMerger extends AbstractFileMerger {
  /*package*/ JavaDependenciesMerger() {
  }

  protected int mergeFiles(File baseFile, File localFile, File latestFile) {
    try {
      ModelDependencies dependencies = loadDependencies(baseFile);
      copyDependencies(loadDependencies(localFile), dependencies);
      copyDependencies(loadDependencies(latestFile), dependencies);

      OutputStream resultStream = getResultStream(localFile);
      saveDependencies(dependencies, resultStream);
      FileUtil.closeFileSafe(resultStream);
      return MERGED;
    } catch (IOException e) {
      e.printStackTrace();
      return FATAL_ERROR;
    } catch (JDOMException e) {
      e.printStackTrace();
      return FATAL_ERROR;
    } catch (JavaDependenciesMerger.MergeException e) {
      e.printStackTrace();
      return CONFLICTS;
    }
  }

  private static ModelDependencies loadDependencies(File f) throws IOException, JDOMException {
    return ModelDependencies.fromXml(JDOMUtil.loadDocument(f).getRootElement());
  }

  private static void saveDependencies(ModelDependencies deps, OutputStream out) throws IOException {
    JDOMUtil.writeDocument(new Document(deps.toXml()), out);
  }

  private static void copyDependencies(ModelDependencies from, ModelDependencies to) throws JavaDependenciesMerger.MergeException {
    for (RootDependencies fromRootDep : Sequence.fromIterable(from.getDependencies())) {
      RootDependencies toRootDep = to.getDependency(fromRootDep.getFileName());
      if (toRootDep == null) {
        to.addDependencies(fromRootDep);
      } else {
        to.replaceRoot(mergeRootDependencies(fromRootDep, toRootDep));
      }
    }
  }

  private static RootDependencies mergeRootDependencies(RootDependencies rd1, RootDependencies rd2) throws JavaDependenciesMerger.MergeException {
    if (neq_bqsatu_a0a0d(rd1.getClassName(), rd2.getClassName())) {
      throw new JavaDependenciesMerger.MergeException("Different class names: " + rd1.getClassName() + " and " + rd2.getClassName());
    }
    Set<String> dependNodes = rd1.getDependencies();
    SetSequence.fromSet(dependNodes).addSequence(SetSequence.fromSet(rd2.getDependencies()));
    Set<String> extendsNodes = rd1.getExtends();
    SetSequence.fromSet(extendsNodes).addSequence(SetSequence.fromSet(rd2.getExtends()));
    return new RootDependencies(rd1.getClassName(), rd1.getFileName(), SetSequence.fromSet(dependNodes).toListSequence(), SetSequence.fromSet(extendsNodes).toListSequence());
  }

  private static boolean neq_bqsatu_a0a0d(Object a, Object b) {
    return !((a != null ?
      a.equals(b) :
      a == b
    ));
  }

  private static class MergeException extends Exception {
    private MergeException(String msg) {
      super(msg);
    }
  }
}
