package jetbrains.mps.ide.java.parser;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;
import jetbrains.mps.smodel.SModelUtil_new;
import java.util.HashSet;

public class ForeignReferencesConvertor {
  private static Set<String> ourAllowedClassifierConcepts;

  public ForeignReferencesConvertor() {
  }

  public SNodePointer createFromForeignId(SModelReference modelReference, SNodeId nodeId, FeatureKind targetKind) {
    SModelDescriptor regularModel = regularModelReferenceFromForeign(modelReference);
    if (regularModel == null) {
      return null;
    }
    SNode target;
    SModel model = regularModel.getSModel();
    switch (targetKind) {
      case CLASS:
        target = getMPSClassById(model, nodeId);
        break;
      case FIELD:
        target = getMPSFieldById(model, nodeId);
        break;
      case METHOD:
        target = getMPSMethodById(model, nodeId);
        break;
      default:
        target = null;
    }
    if (target == null) {
      return new SNodePointer(modelReference, nodeId);
    }
    return new SNodePointer(target);
  }

  private SModelDescriptor regularModelReferenceFromForeign(SModelReference foreingModelReference) {
    SModelDescriptor sModelDescriptor = SModelRepository.getInstance().getModelDescriptor(foreingModelReference.getSModelFqName().withStereotype(""));
    return sModelDescriptor;
  }

  private SNode getMPSClassByIdString(SModel model, String idString) {
    if (idString.startsWith(SNodeId.Foreign.ID_PREFIX)) {
      idString = idString.substring(SNodeId.Foreign.ID_PREFIX.length());
    }
    String className = idString;
    SNode node = SModelOperations.getRootByName(model, className);
    if ((node == null)) {
      return null;
    }
    if (ourAllowedClassifierConcepts.contains(node.getConceptFqName())) {
      return SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier");
    } else {
      return null;
    }
  }

  private SNode getMPSClassById(SModel model, SNodeId nodeId) {
    String idString = nodeId.toString();
    return getMPSClassByIdString(model, idString);
  }

  private SNode getMPSFieldById(SModel model, SNodeId nodeId) {
    String idString = nodeId.toString();
    SNode classifier = getMPSClassByIdString(model, NameUtil.namespaceFromLongName(idString));
    if ((classifier == null)) {
      return null;
    }
    String fieldName = NameUtil.shortNameFromLongName(idString);
    for (SNode field : SLinkOperations.getTargets(classifier, "staticField", true)) {
      if (SPropertyOperations.getString(field, "name").equals(fieldName)) {
        return field;
      }
    }
    if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      for (SNode field : SLinkOperations.getTargets(SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "field", true)) {
        if (SPropertyOperations.getString(field, "name").equals(fieldName)) {
          return field;
        }
      }
    }
    return null;
  }

  private SNode getMPSMethodById(SModel model, SNodeId nodeId) {
    String idString = nodeId.toString();
    int offset1 = idString.lastIndexOf('(');
    String methodAndClassName = idString.substring(0, offset1);
    String className = NameUtil.namespaceFromLongName(methodAndClassName);
    SNode classifier = getMPSClassByIdString(model, className);
    if ((classifier == null)) {
      return null;
    }
    String methodName = NameUtil.shortNameFromLongName(methodAndClassName);
    int offset2 = idString.lastIndexOf(')');
    String signature = idString.substring(offset1 + 1, offset2);
    boolean constructor = "<init>".equals(methodName);
    List<SNode> goodMethods = new ArrayList<SNode>();
    for (SNode method : SLinkOperations.getTargets(classifier, "method", true)) {
      if (methodName.equals(SPropertyOperations.getString(method, "name"))) {
        ListSequence.fromList(goodMethods).addElement(method);
      }
    }
    if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      SNode classConcept = SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept");
      if (constructor) {
        for (SNode method : SLinkOperations.getTargets(classConcept, "constructor", true)) {
          ListSequence.fromList(goodMethods).addElement(method);
        }
      } else {
        for (SNode method : SLinkOperations.getTargets(classConcept, "staticMethod", true)) {
          if (methodName.equals(SPropertyOperations.getString(method, "name"))) {
            goodMethods.add(method);
          }
        }
      }
    }
    for (SNode method : goodMethods) {
      Iterator<SNode> iterator = ListSequence.fromList(SLinkOperations.getTargets(method, "parameter", true)).iterator();
      StringBuilder sb = new StringBuilder();
      while (iterator.hasNext()) {
        sb.append(mpsTypeAsString(SLinkOperations.getTarget(iterator.next(), "type", true)));
        if (iterator.hasNext()) {
          sb.append(',');
        }
      }
      if (signature.equals(sb.toString())) {
        return method;
      }
    }
    return null;
  }

  public String mpsTypeAsString(SNode type) {
    if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
      StringBuilder sb = new StringBuilder();
      SNode classifierType = SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ClassifierType");
      SNode classifier = SLinkOperations.getTarget(classifierType, "classifier", false);
      sb.append(SNodeOperations.getModel(classifier).getLongName()).append('.').append(SPropertyOperations.getString(classifier, "name"));
      List<SNode> typeParameters = SLinkOperations.getTargets(classifierType, "parameter", true);
      if (typeParameters != null && !(ListSequence.fromList(typeParameters).isEmpty())) {
        sb.append('<');
        appendTypesList(sb, typeParameters);
        sb.append('>');
      }
      return sb.toString();
    }
    if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.ArrayType")) {
      return mpsTypeAsString(SLinkOperations.getTarget(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ArrayType"), "componentType", true)) + "[]";
    }
    if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.VariableArityType")) {
      return mpsTypeAsString(SLinkOperations.getTarget(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.VariableArityType"), "componentType", true)) + "...";
    }
    if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.PrimitiveType")) {
      return SModelUtil_new.getAlias(SNodeOperations.getConceptDeclaration(type));
    }
    if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
      return SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.TypeVariableReference"), "typeVariableDeclaration", false), "name");
    }
    if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.UpperBoundType")) {
      return "? extends " + mpsTypeAsString(SLinkOperations.getTarget(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.UpperBoundType"), "bound", true));
    }
    if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.LowerBoundType")) {
      return "? super " + mpsTypeAsString(SLinkOperations.getTarget(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.LowerBoundType"), "bound", true));
    }
    if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.WildCardType")) {
      return "?";
    }
    return null;
  }

  private void appendTypesList(StringBuilder sb, List<SNode> types) {
    Iterator<SNode> iterator = ListSequence.fromList(types).iterator();
    while (iterator.hasNext()) {
      sb.append(mpsTypeAsString(iterator.next()));
      if (iterator.hasNext()) {
        sb.append(',');
      }
    }
  }

  static {
    ourAllowedClassifierConcepts = new HashSet<String>();
    ourAllowedClassifierConcepts.add("jetbrains.mps.baseLanguage.structure.ClassConcept");
    ourAllowedClassifierConcepts.add("jetbrains.mps.baseLanguage.structure.Interface");
    ourAllowedClassifierConcepts.add("jetbrains.mps.baseLanguage.structure.EnumClass");
    ourAllowedClassifierConcepts.add("jetbrains.mps.baseLanguage.structure.AnonymousClass");
    ourAllowedClassifierConcepts.add("jetbrains.mps.baseLanguage.structure.Annotation");
  }
}
