package jetbrains.mps.ide.java.parser;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.Map;
import org.eclipse.jdt.internal.compiler.lookup.Binding;
import jetbrains.mps.smodel.SNode;
import java.util.HashMap;
import jetbrains.mps.smodel.SModel;
import java.util.List;
import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ASTVisitor;
import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
import org.eclipse.jdt.internal.compiler.ast.Annotation;
import org.eclipse.jdt.internal.compiler.problem.AbortCompilationUnit;
import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
import org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;
import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
import jetbrains.mps.smodel.SReference;
import org.eclipse.jdt.internal.compiler.lookup.MemberTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
import org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.TryStatement;
import org.eclipse.jdt.internal.compiler.ast.Argument;
import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;

public class ReferentsCreator {
  private static final Logger LOG = Logger.getLogger(ReferentsCreator.class);

  /*package*/ Map<Binding, SNode> myBindingMap = new HashMap<Binding, SNode>();
  /*package*/ SModel myCurrentModel;
  /*package*/ Map<String, SModel> myPackageNamesToModels;
  /*package*/ TypesProvider myTypesProvider;
  /*package*/ List<TypeDeclaration> myTypeDecls = new ArrayList<TypeDeclaration>();
  /*package*/ Set<TypeDeclaration> myTopLevelTypeDecls = new HashSet<TypeDeclaration>();

  public ReferentsCreator(Map<String, SModel> modelMap) {
    myPackageNamesToModels = modelMap;
    myTypesProvider = new TypesProvider(this);
  }

  public TypesProvider getTypesProvider() {
    return myTypesProvider;
  }

  public TypeDeclaration[] getClassifierTypeDecls() {
    return myTypeDecls.toArray(new TypeDeclaration[myTypeDecls.size()]);
  }

  public Set<TypeDeclaration> getClassifierTopLevelTypeDecls() {
    return new HashSet<TypeDeclaration>(myTopLevelTypeDecls);
  }

  public boolean isTopLevelClassifier(TypeDeclaration typeDeclaration) {
    return myTopLevelTypeDecls.contains(typeDeclaration);
  }

  public void exec(CompilationUnitDeclaration[] unitDecls) {
    ReferentsCreator.ClassesCreator classesCreator = new ReferentsCreator.ClassesCreator(this);
    for (CompilationUnitDeclaration unitDecl : unitDecls) {
      if (unitDecl.hasErrors()) {
        LOG.warning("source file " + new String(unitDecl.getFileName()) + " has compilation errors");
      }
      traverse(classesCreator, unitDecl);
    }
    ReferentsCreator.DeclsCreator declsCreator = new ReferentsCreator.DeclsCreator(this);
    for (CompilationUnitDeclaration unitDecl : unitDecls) {
      traverse(declsCreator, unitDecl);
    }
  }

  public void traverse(ASTVisitor visitor, CompilationUnitDeclaration unitDecl) {
    try {
      if (visitor.visit(unitDecl, unitDecl.scope)) {
        if (unitDecl.types != null && unitDecl.isPackageInfo()) {
          final TypeDeclaration syntheticTypeDeclaration = unitDecl.types[0];
          final MethodScope methodScope = syntheticTypeDeclaration.staticInitializerScope;
          if (unitDecl.javadoc != null) {
            unitDecl.javadoc.traverse(visitor, methodScope);
          }
          if (unitDecl.currentPackage != null) {
            final Annotation[] annotations = unitDecl.currentPackage.annotations;
            if (annotations != null) {
              int annotationsLength = annotations.length;
              for (int i = 0; i < annotationsLength; i++) {
                annotations[i].traverse(visitor, methodScope);
              }
            }
          }
        }
        if (unitDecl.currentPackage != null) {
          unitDecl.currentPackage.traverse(visitor, unitDecl.scope);
        }
        if (unitDecl.imports != null) {
          int importLength = unitDecl.imports.length;
          for (int i = 0; i < importLength; i++) {
            unitDecl.imports[i].traverse(visitor, unitDecl.scope);
          }
        }
        if (unitDecl.types != null) {
          int typesLength = unitDecl.types.length;
          for (int i = 0; i < typesLength; i++) {
            unitDecl.types[i].traverse(visitor, unitDecl.scope);
          }
        }
      }
      visitor.endVisit(unitDecl, unitDecl.scope);
    } catch (AbortCompilationUnit e) {
    }
  }

  public static boolean isEnumConstant(FieldDeclaration fieldDeclaration) {
    Expression initialization = fieldDeclaration.initialization;
    boolean isEnumConstant = initialization != null && initialization instanceof AllocationExpression && ((AllocationExpression) initialization).enumConstant != null;
    return isEnumConstant;
  }

  public static class ClassesCreator extends ASTVisitor {
    private ReferentsCreator myReferentsCreator;

    public ClassesCreator(ReferentsCreator referentsCreator) {
      myReferentsCreator = referentsCreator;
    }

    @Override
    public boolean visit(TypeDeclaration localTypeDeclaration, BlockScope scope) {
      assert (TypeDeclaration.kind(localTypeDeclaration.modifiers) != TypeDeclaration.INTERFACE_DECL);
      return process(localTypeDeclaration);
    }

    @Override
    public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope scope) {
      return process(memberTypeDeclaration);
    }

    @Override
    public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {
      String fqName = JavaCompiler.packageNameFromCompoundName(typeDeclaration.binding.compoundName);
      myReferentsCreator.myCurrentModel = myReferentsCreator.myPackageNamesToModels.get(fqName);
      return process(typeDeclaration);
    }

    @Override
    public void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {
      myReferentsCreator.myCurrentModel = null;
    }

    private boolean process(TypeDeclaration typeDeclaration) {
      SourceTypeBinding binding = typeDeclaration.binding;
      if (binding == null) {
        return false;
      }
      char[][] name = binding.compoundName;
      SModel model = myReferentsCreator.myCurrentModel;
      SNode classifier;
      SNode visibility = getClassVisibility(binding);
      if (binding.isClass()) {
        if (binding.isLocalType()) {
          classifier = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.AnonymousClass", null);
        } else {
          SNode classConcept = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.ClassConcept", null);
          SPropertyOperations.set(classConcept, "abstractClass", "" + binding.isAbstract());
          SPropertyOperations.set(classConcept, "isFinal", "" + binding.isFinal());
          classifier = classConcept;
        }
      } else
      if (binding.isInterface() && !(binding.isAnnotationType())) {
        classifier = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.Interface", null);
      } else
      if (binding.isAnnotationType()) {
        classifier = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.Annotation", null);
      } else
      if (binding.isEnum()) {
        classifier = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.EnumClass", null);
      } else {
        return false;
      }
      if (!(binding.isLocalType())) {
        String shortName = new String(name[name.length - 1]);
        int dollarIndex = -1;
        do {
          dollarIndex = shortName.indexOf('$');
          if (dollarIndex != -1) {
            shortName = shortName.substring(dollarIndex + 1);
          }
        } while (dollarIndex != -1);
        SPropertyOperations.set(classifier, "name", shortName);
      }
      SLinkOperations.setTarget(classifier, "visibility", visibility, true);
      myReferentsCreator.myBindingMap.put(binding, classifier);
      TypeParameter[] typeParameters = typeDeclaration.typeParameters;
      if (typeParameters != null) {
        for (TypeParameter typeParameter : typeParameters) {
          SNode typeVariableDeclaration = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration", null);
          SPropertyOperations.set(typeVariableDeclaration, "name", new String(typeParameter.name));
          ListSequence.fromList(SLinkOperations.getTargets(classifier, "typeVariableDeclaration", true)).addElement(typeVariableDeclaration);
        }
      }
      return true;
    }

    private SNode getClassVisibility(ReferenceBinding b) {
      SModel model = myReferentsCreator.myCurrentModel;
      if (b.isPublic()) {
        return SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.PublicVisibility", null);
      } else
      if (b.isPrivate()) {
        return SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.PrivateVisibility", null);
      } else
      if (b.isProtected()) {
        return SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.ProtectedVisibility", null);
      } else {
        return null;
      }
    }
  }

  public static class DeclsCreator extends ASTVisitor {
    private ReferentsCreator myReferentsCreator;

    public DeclsCreator(ReferentsCreator referentsCreator) {
      myReferentsCreator = referentsCreator;
    }

    @Override
    public boolean visit(TypeDeclaration localTypeDeclaration, BlockScope scope) {
      return process(localTypeDeclaration);
    }

    @Override
    public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope scope) {
      return process(memberTypeDeclaration);
    }

    @Override
    public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {
      String fqName = JavaCompiler.packageNameFromCompoundName(typeDeclaration.binding.compoundName);
      myReferentsCreator.myCurrentModel = myReferentsCreator.myPackageNamesToModels.get(fqName);
      return process(typeDeclaration);
    }

    public void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {
      myReferentsCreator.myCurrentModel = null;
    }

    private boolean process(TypeDeclaration typeDeclaration) {
      SourceTypeBinding binding = typeDeclaration.binding;
      if (binding == null) {
        return false;
      }
      SNode classifier = SNodeOperations.cast(myReferentsCreator.myBindingMap.get(binding), "jetbrains.mps.baseLanguage.structure.Classifier");
      try {
        boolean isTopLevel = true;
        if (binding instanceof LocalTypeBinding) {
          isTopLevel = false;
          if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
            return true;
          }
          SNode anonymousClass = SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass");
          SPropertyOperations.set(anonymousClass, "name", "");
          ReferenceBinding superClassBinding;
          if (binding.superInterfaces != null && !((binding.superInterfaces.length == 0))) {
            superClassBinding = binding.superInterfaces[0];
          } else {
            superClassBinding = binding.superclass;
          }
          if (superClassBinding != null) {
            SNode superClass = SNodeOperations.cast(createType(superClassBinding), "jetbrains.mps.baseLanguage.structure.ClassifierType");
            // copy classifier reference 
            // <node> 
            SReference classifierRef = SNodeOperations.getReference(superClass, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassifierType", "classifier"));
            SReference newRef = SReference.create("classifier", anonymousClass, classifierRef.getTargetSModelReference(), classifierRef.getTargetNodeId(), new String(superClassBinding.sourceName));
            anonymousClass.addReference(newRef);
            for (SNode t : SLinkOperations.getTargets(superClass, "parameter", true)) {
              ListSequence.fromList(SLinkOperations.getTargets(anonymousClass, "typeParameter", true)).addElement(SNodeOperations.copyNode(t));
            }
          }
        } else {
          ReferenceBinding superClassBinding = binding.superclass();
          if (superClassBinding != null) {
            // <node> 
            if ("java.lang.Object".equals(new String(superClassBinding.readableName()))) {
            } else
            if (binding.isEnum()) {
            } else {
              if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
                SNode classConcept = SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept");
                SNode superClass = SNodeOperations.cast(createType(superClassBinding), "jetbrains.mps.baseLanguage.structure.ClassifierType");
                SLinkOperations.setTarget(classConcept, "superclass", superClass, true);
              }
            }
          }
          ReferenceBinding[] superInterfaces = binding.superInterfaces();
          for (ReferenceBinding superInterfaceBinding : superInterfaces) {
            // <node> 
            SNode superInterface = SNodeOperations.cast(createType(superInterfaceBinding), "jetbrains.mps.baseLanguage.structure.ClassifierType");
            if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
              SNode classConcept = SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept");
              ListSequence.fromList(SLinkOperations.getTargets(classConcept, "implementedInterface", true)).addElement(superInterface);
            }
            if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.Interface")) {
              SNode intfc = SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.Interface");
              ListSequence.fromList(SLinkOperations.getTargets(intfc, "extendedInterface", true)).addElement(superInterface);
            }
          }
          if (binding instanceof MemberTypeBinding) {
            isTopLevel = false;
            MemberTypeBinding memberTypeBinding = (MemberTypeBinding) binding;
            SourceTypeBinding enclosingClass = memberTypeBinding.enclosingType;
            SNode enclosingClassifier = SNodeOperations.cast(myReferentsCreator.myBindingMap.get(enclosingClass), "jetbrains.mps.baseLanguage.structure.Classifier");
            SPropertyOperations.set(classifier, "nonStatic", "" + !(memberTypeBinding.isStatic()));
            ListSequence.fromList(SLinkOperations.getTargets(enclosingClassifier, "staticInnerClassifiers", true)).addElement(classifier);
          }
        }
        TypeParameter[] typeParameters = typeDeclaration.typeParameters;
        if (typeParameters != null) {
          SNode[] tvds = SLinkOperations.getTargets(classifier, "typeVariableDeclaration", true).toArray(new SNode[typeParameters.length]);
          for (int i = 0; i < typeParameters.length; i++) {
            TypeParameter typeParameter = typeParameters[i];
            SNode typeVar = tvds[i];
            setTypeVariableBounds(typeParameter, typeVar);
          }
        }
        myReferentsCreator.myTypeDecls.add(typeDeclaration);
        if (isTopLevel) {
          myReferentsCreator.myTopLevelTypeDecls.add(typeDeclaration);
        }
        return true;
      } catch (Throwable e) {
        throw new JavaConverterException(e);
      }
    }

    private void setTypeVariableBounds(TypeParameter typeParameter, SNode typeVar) {
      TypeVariableBinding typeVariableBinding = typeParameter.binding;
      if (typeVariableBinding.firstBound != null) {
        SLinkOperations.setTarget(typeVar, "bound", createType(typeVariableBinding.firstBound), true);
      }
      for (TypeBinding auxBoundBinding : typeVariableBinding.otherUpperBounds()) {
        ListSequence.fromList(SLinkOperations.getTargets(typeVar, "auxBounds", true)).addElement(SNodeOperations.cast(createType(auxBoundBinding), "jetbrains.mps.baseLanguage.structure.ClassifierType"));
      }
      boolean isExtends = (typeVariableBinding.superclass != null && typeVariableBinding.firstBound == typeVariableBinding.superclass) || (typeVariableBinding.superInterfaces != null && typeVariableBinding.superInterfaces != Binding.NO_SUPERINTERFACES);
      SPropertyOperations.set(typeVar, "extends", "" + isExtends);
    }

    @Override
    public boolean visit(AnnotationMethodDeclaration methodDeclaration, ClassScope scope) {
      return visit((MethodDeclaration) methodDeclaration, scope);
    }

    @Override
    public boolean visit(TryStatement tryStatement, BlockScope scope) {
      if (tryStatement.catchArguments != null) {
        for (Argument argument : tryStatement.catchArguments) {
          visitLocalDeclaration(argument);
        }
      }
      return true;
    }

    @Override
    public boolean visit(FieldDeclaration fieldDeclaration, MethodScope scope) {
      FieldBinding b = fieldDeclaration.binding;
      SNode enclosingClassifier = SNodeOperations.cast(myReferentsCreator.myBindingMap.get(scope.enclosingSourceType()), "jetbrains.mps.baseLanguage.structure.Classifier");
      boolean isEnumConstant = ReferentsCreator.isEnumConstant(fieldDeclaration);
      if (isEnumConstant) {
        createEnumField(b, enclosingClassifier);
      } else {
        createField(b, enclosingClassifier, new String(fieldDeclaration.name));
      }
      return true;
    }

    private SNode createEnumField(FieldBinding binding, SNode enclosingClassifier) {
      assert (SNodeOperations.isInstanceOf(enclosingClassifier, "jetbrains.mps.baseLanguage.structure.EnumClass"));
      SModel model = myReferentsCreator.myCurrentModel;
      SNode enumClass = SNodeOperations.cast(enclosingClassifier, "jetbrains.mps.baseLanguage.structure.EnumClass");
      SNode enumConstant = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration", null);
      SPropertyOperations.set(enumConstant, "name", new String(binding.name));
      ListSequence.fromList(SLinkOperations.getTargets(enumClass, "enumConstant", true)).addElement(enumConstant);
      myReferentsCreator.myBindingMap.put(binding, enumConstant);
      return enumConstant;
    }

    private SNode createField(FieldBinding binding, SNode enclosingClassifier, String name) {
      SNode type = null;
      if (binding != null) {
        type = createType(binding.type);
      }
      SNode field;
      if (binding == null || !(binding.isStatic())) {
        SNode fieldDeclaration = SModelOperations.createNewNode(myReferentsCreator.myCurrentModel, "jetbrains.mps.baseLanguage.structure.FieldDeclaration", null);
        if (binding != null) {
          SPropertyOperations.set(fieldDeclaration, "isVolatile", "" + binding.isVolatile());
        }
        assert (SNodeOperations.isInstanceOf(enclosingClassifier, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(enclosingClassifier, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "field", true)).addElement(fieldDeclaration);
        field = fieldDeclaration;
      } else {
        SNode staticFieldDeclaration = SModelOperations.createNewNode(myReferentsCreator.myCurrentModel, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration", null);
        field = staticFieldDeclaration;
        ListSequence.fromList(SLinkOperations.getTargets(enclosingClassifier, "staticField", true)).addElement(staticFieldDeclaration);
      }
      if (binding != null) {
        SPropertyOperations.set(field, "isFinal", "" + binding.isFinal());
        SLinkOperations.setTarget(field, "type", type, true);
        SLinkOperations.setTarget(SNodeOperations.cast(field, "jetbrains.mps.baseLanguage.structure.ClassifierMember"), "visibility", getFieldVisibility(binding), true);
        myReferentsCreator.myBindingMap.put(binding, field);
      }
      SPropertyOperations.set(field, "name", name);
      return field;
    }

    private SNode createType(TypeBinding binding) {
      return myReferentsCreator.myTypesProvider.createType(binding);
    }

    @Override
    public boolean visit(LocalDeclaration localDeclaration, BlockScope scope) {
      return visitLocalDeclaration(localDeclaration);
    }

    private boolean visitLocalDeclaration(LocalDeclaration localDeclaration) {
      SModel model = myReferentsCreator.myCurrentModel;
      LocalVariableBinding b = localDeclaration.binding;
      SNode localType = createType(localDeclaration.type.resolvedType);
      SNode newLocal = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", null);
      SPropertyOperations.set(newLocal, "name", new String(localDeclaration.name));
      SLinkOperations.setTarget(newLocal, "type", localType, true);
      if (b != null) {
        SPropertyOperations.set(newLocal, "isFinal", "" + b.isFinal());
        myReferentsCreator.myBindingMap.put(b, newLocal);
      }
      return true;
    }

    @Override
    public boolean visit(ConstructorDeclaration ctorDecl, ClassScope scope) {
      try {
        MethodBinding b = ctorDecl.binding;
        SModel model = myReferentsCreator.myCurrentModel;
        SNode enclosingType = SNodeOperations.cast(myReferentsCreator.myBindingMap.get(scope.enclosingSourceType()), "jetbrains.mps.baseLanguage.structure.Classifier");
        assert (SNodeOperations.isInstanceOf(enclosingType, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
        SNode classConcept = SNodeOperations.cast(enclosingType, "jetbrains.mps.baseLanguage.structure.ClassConcept");
        SNode constructorDeclaration = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", null);
        SNode visibility = getMethodVisibility(b);
        SLinkOperations.setTarget(constructorDeclaration, "visibility", visibility, true);
        SLinkOperations.setTarget(constructorDeclaration, "returnType", SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.VoidType", null), true);
        myReferentsCreator.myBindingMap.put(b, constructorDeclaration);
        processMethodTypeParameters(ctorDecl, constructorDeclaration);
        mapParameters(constructorDeclaration, ctorDecl);
        if (!(SNodeOperations.isInstanceOf(classConcept, "jetbrains.mps.baseLanguage.structure.AnonymousClass"))) {
          ListSequence.fromList(SLinkOperations.getTargets(classConcept, "constructor", true)).addElement(constructorDeclaration);
        }
        return true;
      } catch (Throwable e) {
        throw new JavaConverterException(e);
      }
    }

    @Override
    public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
      MethodBinding b = methodDeclaration.binding;
      SNode enclosingClassifier = SNodeOperations.cast(myReferentsCreator.myBindingMap.get(scope.enclosingSourceType()), "jetbrains.mps.baseLanguage.structure.Classifier");
      SNode newMethod = processMethodBinding(b, new String(methodDeclaration.selector), enclosingClassifier, methodDeclaration instanceof AnnotationMethodDeclaration);
      processMethodTypeParameters(methodDeclaration, newMethod);
      if (b != null) {
        SLinkOperations.setTarget(newMethod, "returnType", createType(b.returnType), true);
      }
      mapParameters(newMethod, methodDeclaration);
      return true;
    }

    private SNode processMethodBinding(MethodBinding b, String name, SNode enclosingClassifier, boolean isAnnotation) {
      SModel model = myReferentsCreator.myCurrentModel;
      SNode result;
      if (b != null && b.isStatic()) {
        SNode staticMethodDeclaration = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration", null);
        SLinkOperations.setTarget(staticMethodDeclaration, "visibility", getMethodVisibility(b), true);
        if (SNodeOperations.isInstanceOf(enclosingClassifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
          SNode classConcept = SNodeOperations.cast(enclosingClassifier, "jetbrains.mps.baseLanguage.structure.ClassConcept");
          ListSequence.fromList(SLinkOperations.getTargets(classConcept, "staticMethod", true)).addElement(staticMethodDeclaration);
        }
        result = staticMethodDeclaration;
      } else {
        SNode instanceMethodDeclaration = (isAnnotation ?
          SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration", null) :
          SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration", null)
        );
        if (b != null) {
          SPropertyOperations.set(instanceMethodDeclaration, "isAbstract", "" + b.isAbstract());
          SLinkOperations.setTarget(instanceMethodDeclaration, "visibility", getMethodVisibility(b), true);
        }
        ListSequence.fromList(SLinkOperations.getTargets(enclosingClassifier, "method", true)).addElement(instanceMethodDeclaration);
        result = instanceMethodDeclaration;
      }
      if (b != null) {
        myReferentsCreator.myBindingMap.put(b, result);
        SPropertyOperations.set(result, "isFinal", "" + b.isFinal());
      }
      SPropertyOperations.set(result, "name", name);
      return result;
    }

    private void processMethodTypeParameters(AbstractMethodDeclaration methodDeclaration, SNode newMethod) {
      SModel model = myReferentsCreator.myCurrentModel;
      TypeParameter[] typeParameters = methodDeclaration.typeParameters();
      if (typeParameters != null) {
        for (TypeParameter typeParameter : typeParameters) {
          SNode typeVariableDeclaration = SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration", null);
          SPropertyOperations.set(typeVariableDeclaration, "name", new String(typeParameter.name));
          setTypeVariableBounds(typeParameter, typeVariableDeclaration);
          ListSequence.fromList(SLinkOperations.getTargets(newMethod, "typeVariableDeclaration", true)).addElement(typeVariableDeclaration);
        }
      }
    }

    private void mapParameters(SNode method, AbstractMethodDeclaration x) {
      MethodBinding b = x.binding;
      if (b == null) {
        return;
      }
      int paramCount = ((b.parameters != null ?
        b.parameters.length :
        0
      ));
      if (paramCount > 0) {
        for (int i = 0, n = x.arguments.length; i < n; ++i) {
          Argument argument = x.arguments[i];
          SNode parameterDeclaration = createParameter(argument.binding, method);
        }
      }
    }

    private SNode createParameter(LocalVariableBinding binding, SNode enclosingMethod) {
      boolean varArg = false;
      if (binding.declaration.type instanceof ArrayTypeReference) {
        ArrayTypeReference arrayTypeReference = (ArrayTypeReference) binding.declaration.type;
        if ((arrayTypeReference.bits & ASTNode.IsVarArgs) != 0) {
          varArg = true;
        }
      }
      SNode type = myReferentsCreator.myTypesProvider.createType(binding.type, varArg);
      SNode result = SModelOperations.createNewNode(myReferentsCreator.myCurrentModel, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration", null);
      SPropertyOperations.set(result, "name", new String(binding.name));
      SLinkOperations.setTarget(result, "type", type, true);
      SPropertyOperations.set(result, "isFinal", "" + binding.isFinal());
      ListSequence.fromList(SLinkOperations.getTargets(enclosingMethod, "parameter", true)).addElement(result);
      myReferentsCreator.myBindingMap.put(binding, result);
      return result;
    }

    private SNode getMethodVisibility(MethodBinding b) {
      SModel model = myReferentsCreator.myCurrentModel;
      if (b.isPublic()) {
        return SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.PublicVisibility", null);
      } else
      if (b.isPrivate()) {
        return SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.PrivateVisibility", null);
      } else
      if (b.isProtected()) {
        return SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.ProtectedVisibility", null);
      } else {
        return null;
      }
    }

    private SNode getFieldVisibility(FieldBinding b) {
      SModel model = myReferentsCreator.myCurrentModel;
      if (b.isPublic()) {
        return SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.PublicVisibility", null);
      } else
      if (b.isPrivate()) {
        return SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.PrivateVisibility", null);
      } else
      if (b.isProtected()) {
        return SModelOperations.createNewNode(model, "jetbrains.mps.baseLanguage.structure.ProtectedVisibility", null);
      } else {
        return null;
      }
    }
  }
}
