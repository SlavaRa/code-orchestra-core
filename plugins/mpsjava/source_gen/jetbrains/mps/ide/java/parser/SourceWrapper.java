package jetbrains.mps.ide.java.parser;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.apache.commons.lang.StringUtils;

public abstract class SourceWrapper {
  protected String mySource;
  protected String myWrappedSource;
  protected String myClassName;
  protected SModel myModel;

  public SourceWrapper(String source, SModel model) {
    mySource = source;
    myModel = model;
  }

  public abstract List<SNode> getOurNodesFromClassifier(SNode classifier);

  protected String wrapStatements(String source, String shortClassName) {
    StringBuilder sb = new StringBuilder();
    classHeader(shortClassName, sb);
    methodHeader(sb);
    sb.append(source);
    methodFooter(sb);
    classFooter(sb);
    String result = sb.toString();
    return result;
  }

  protected String wrapMethods(String source, String shortClassName) {
    StringBuilder sb = new StringBuilder();
    classHeader(shortClassName, sb);
    sb.append(source);
    classFooter(sb);
    String result = sb.toString();
    return result;
  }

  protected void classFooter(StringBuilder sb) {
    sb.append("\n}");
  }

  protected void methodFooter(StringBuilder sb) {
    sb.append("}\n");
  }

  protected void methodHeader(StringBuilder sb) {
    sb.append("private void foo() {\n");
  }

  protected void classHeader(String shortClassName, StringBuilder sb) {
    sb.append("package ");
    sb.append(myModel.getLongName());
    sb.append(";\n\n");
    imports(sb);
    sb.append("public class " + shortClassName + " {\n\n");
  }

  protected void imports(StringBuilder sb) {
    sb.append("\n");
    for (SModelDescriptor modelDescriptor : SModelOperations.allImportedModels(myModel, GlobalScope.getInstance())) {
      sb.append("import " + modelDescriptor.getLongName() + ".*;\n");
    }
    sb.append("\n");
  }

  protected String synthesizedClassName() {
    return "Temp1233429";
  }

  public String getWrappedSource() {
    return myWrappedSource;
  }

  public String getShortClassName() {
    return myClassName;
  }

  public String getSource() {
    return mySource;
  }

  public static SourceWrapper wrapSource(String source, SModel model, FeatureKind featureKind) {
    switch (featureKind) {
      case CLASS:
        return new SourceWrapper.ClassWrapper(source, model);
      case CLASS_CONTENT:
        return new SourceWrapper.MethodsWrapper(source, model);
      case STATEMENTS:
        return new SourceWrapper.StatementsWrapper(source, model);
      default:
        throw new IllegalArgumentException();
    }
  }

  public static class StatementsWrapper extends SourceWrapper {
    public StatementsWrapper(String source, SModel model) {
      super(source, model);
      myClassName = synthesizedClassName();
      myWrappedSource = wrapStatements(source, myClassName);
    }

    @Override
    public List<SNode> getOurNodesFromClassifier(SNode classifier) {
      return SLinkOperations.getTargets(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(classifier, "method", true)).first(), "body", true), "statement", true);
    }
  }

  public static class MethodsWrapper extends SourceWrapper {
    public MethodsWrapper(String source, SModel model) {
      super(source, model);
      myClassName = synthesizedClassName();
      myWrappedSource = wrapMethods(source, myClassName);
    }

    @Override
    public List<SNode> getOurNodesFromClassifier(SNode classifier) {
      List<SNode> result = new ArrayList<SNode>();
      ListSequence.fromList(result).addSequence(ListSequence.fromList(SLinkOperations.getTargets(classifier, "method", true))).addSequence(ListSequence.fromList(SLinkOperations.getTargets(classifier, "staticField", true))).addSequence(ListSequence.fromList(SLinkOperations.getTargets(classifier, "staticInnerClassifiers", true)));
      SNode classs = SNodeOperations.as(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept");
      if ((classs != null)) {
        ListSequence.fromList(result).addSequence(ListSequence.fromList(SLinkOperations.getTargets(classs, "field", true))).addSequence(ListSequence.fromList(SLinkOperations.getTargets(classs, "staticMethod", true)));
      }
      return result;
    }
  }

  public static class ClassWrapper extends SourceWrapper {
    private static final String PACKAGE_ = "package ";

    public ClassWrapper(String source, SModel model) {
      super(source, model);
      String sClass = "class";
      int index = source.indexOf(sClass);
      if (index == -1) {
        sClass = "interface";
        index = source.indexOf(sClass);
      }
      if (index == -1) {
        throw new ConversionFailedException("not a class or interface");
      } else {
        int i = index + sClass.length();
        while (Character.isWhitespace(source.charAt(i))) {
          i++;
        }
        StringBuilder sb = new StringBuilder();
        while (!(Character.isWhitespace(source.charAt(i)) || source.charAt(i) == '{')) {
          char c = source.charAt(i);
          sb.append(c);
          i++;
        }
        myClassName = sb.toString();
        // replace package x.y.z; with import x.y.z.*; if necessary 
        int iPackage = source.indexOf(PACKAGE_);
        if (0 <= iPackage && iPackage < i && StringUtils.isNotEmpty(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.getModelName(model))) {
          int iPackageEnd = iPackage + PACKAGE_.length();
          while (!(Character.isWhitespace(source.charAt(iPackageEnd)) || source.charAt(iPackageEnd) == ';')) {
            iPackageEnd++;
          }
          source = source.substring(0, iPackage) + "import " + source.substring(iPackage + PACKAGE_.length(), iPackageEnd) + ".*" + source.substring(iPackageEnd);
        }
        // add package if necessary 
        if (StringUtils.isEmpty(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.getModelName(model))) {
          myWrappedSource = source;
        } else {
          myWrappedSource = PACKAGE_ + jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.getModelName(model) + ";\n" + source;
        }
      }
    }

    @Override
    public List<SNode> getOurNodesFromClassifier(SNode classifier) {
      List<SNode> result = new ArrayList<SNode>();
      ListSequence.fromList(result).addElement(classifier);
      return result;
    }
  }
}
