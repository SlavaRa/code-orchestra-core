package jetbrains.mps.ide.java.parser;

/*Generated by MPS */

import jetbrains.mps.smodel.IOperationContext;
import java.util.List;
import java.io.File;
import jetbrains.mps.workbench.dialogs.project.BaseBindedDialog;
import jetbrains.mps.reloading.IClassPathItem;
import org.jdesktop.observablecollections.ObservableCollections;
import java.util.ArrayList;
import org.jdesktop.observablecollections.ObservableList;
import java.util.Map;
import java.util.Set;
import java.util.HashMap;
import java.awt.HeadlessException;
import javax.swing.JScrollPane;
import com.intellij.ui.ScrollPaneFactory;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import javax.swing.JButton;
import javax.swing.AbstractAction;
import java.awt.event.ActionEvent;
import jetbrains.mps.workbench.dialogs.project.components.parts.boundpanels.BoundListPanel;
import jetbrains.mps.ide.dialogs.DialogDimensionsSettings;
import java.awt.Frame;
import javax.swing.JComponent;
import java.util.LinkedHashSet;

public class UIComponents {
  public UIComponents() {
  }

  public static UIComponents.MyDialog createClasspathsDialog(IOperationContext context, final List<File> sourceDir, List<String> classFqNames) {
    return new UIComponents.MyDialog(context, sourceDir, classFqNames);
  }

  public static class MyDialog extends BaseBindedDialog implements ClasspathObserver {
    private List<IClassPathItem> myAdditionalClasspaths = ObservableCollections.observableList(new ArrayList<IClassPathItem>());
    private ObservableList<String> myUnresolvedFQNames;
    private Map<IClassPathItem, Set<String>> myClasspathsToClasses = new HashMap<IClassPathItem, Set<String>>();

    protected MyDialog(IOperationContext operationContext, final List<File> sourceDirs, List<String> classFqNames) throws HeadlessException {
      super("Classpaths", operationContext);
      myUnresolvedFQNames = ObservableCollections.observableList(new ArrayList<String>(classFqNames));
      JScrollPane panel = ScrollPaneFactory.createScrollPane(ClasspathSelectionTree.createClasspathSelectionTree(this, sourceDirs));
      DefaultListCellRenderer renderer = new DefaultListCellRenderer();
      JPanel classPathPanel = createBoundListPanel("Added Classpaths", myAdditionalClasspaths, renderer);
      JPanel classesList = createBoundListPanel("Unresolved Names", myUnresolvedFQNames, renderer);
      JSplitPane innerSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, classPathPanel, classesList);
      innerSplitPane.setResizeWeight(0.5);
      JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panel, innerSplitPane);
      splitPane.setResizeWeight(0.33);
      this.setLayout(new BorderLayout());
      this.add(splitPane, BorderLayout.CENTER);
      JPanel buttonsPanel = new JPanel();
      buttonsPanel.setLayout(new FlowLayout());
      buttonsPanel.add(new JButton(new AbstractAction("OK") {
        public void actionPerformed(ActionEvent e) {
          MyDialog.this.dispose();
        }
      }), FlowLayout.LEFT);
      buttonsPanel.add(new JButton(new AbstractAction("Cancel") {
        public void actionPerformed(ActionEvent e) {
          MyDialog.this.dispose();
          myAdditionalClasspaths.clear();
        }
      }), FlowLayout.LEFT);
      this.add(buttonsPanel, BorderLayout.SOUTH);
      this.setModal(true);
    }

    private JPanel createBoundListPanel(String caption, List list, DefaultListCellRenderer renderer) {
      BoundListPanel result = new BoundListPanel(this, caption, list);
      result.setCellRenderer(renderer);
      result.init();
      return result;
    }

    @Override
    public DialogDimensionsSettings.DialogDimensions getDefaultDimensionSettings() {
      Frame mainFrame = getOperationContext().getMainFrame();
      return new DialogDimensionsSettings.DialogDimensions(mainFrame.getX() + mainFrame.getWidth() / 2, mainFrame.getY() + mainFrame.getHeight() / 2, 600, 300);
    }

    public JComponent getMainComponent() {
      return this.getRootPane();
    }

    public void classPathAdded(IClassPathItem classPath) {
      if (classPath == null) {
        return;
      }
      myAdditionalClasspaths.add(classPath);
      for (String unresolvedFQName : new ArrayList<String>(myUnresolvedFQNames)) {
        if (classPath.getClass(unresolvedFQName) != null || classPath.getAvailableClasses(unresolvedFQName).iterator().hasNext() || classPath.getSubpackages(unresolvedFQName).iterator().hasNext()) {
          addClassInClassPath(classPath, unresolvedFQName);
        }
      }
    }

    private void addClassInClassPath(IClassPathItem classPath, String fqName) {
      Set<String> fqNames = myClasspathsToClasses.get(classPath);
      if (fqNames == null) {
        fqNames = new LinkedHashSet<String>();
        myClasspathsToClasses.put(classPath, fqNames);
      }
      fqNames.add(fqName);
      myUnresolvedFQNames.remove(fqName);
    }

    public void classPathRemoved(IClassPathItem classPath) {
      if (classPath == null) {
        return;
      }
      myAdditionalClasspaths.remove(classPath);
      Set<String> unresolvedNames = myClasspathsToClasses.remove(classPath);
      if (unresolvedNames != null) {
        myUnresolvedFQNames.addAll(unresolvedNames);
      }
    }

    public List<IClassPathItem> getChosenClassPaths() {
      return new ArrayList<IClassPathItem>(myAdditionalClasspaths);
    }
  }
}
