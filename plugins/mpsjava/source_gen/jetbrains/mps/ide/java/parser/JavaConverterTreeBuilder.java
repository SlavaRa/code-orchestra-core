package jetbrains.mps.ide.java.parser;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SModel;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
import java.util.List;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.Literal;
import org.eclipse.jdt.internal.compiler.impl.Constant;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.eclipse.jdt.internal.compiler.ast.Statement;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import org.eclipse.jdt.internal.compiler.impl.BooleanConstant;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.eclipse.jdt.internal.compiler.impl.ByteConstant;
import org.eclipse.jdt.internal.compiler.impl.CharConstant;
import jetbrains.mps.util.NameUtil;
import org.eclipse.jdt.internal.compiler.impl.DoubleConstant;
import org.eclipse.jdt.internal.compiler.impl.FloatConstant;
import org.eclipse.jdt.internal.compiler.impl.IntConstant;
import org.eclipse.jdt.internal.compiler.impl.LongConstant;
import org.eclipse.jdt.internal.compiler.impl.ShortConstant;
import org.eclipse.jdt.internal.compiler.impl.StringConstant;
import org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression;
import org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression;
import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
import org.eclipse.jdt.internal.compiler.ast.ArrayReference;
import org.eclipse.jdt.internal.compiler.ast.Assignment;
import org.eclipse.jdt.internal.compiler.ast.BinaryExpression;
import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
import org.eclipse.jdt.internal.compiler.ast.CombinedBinaryExpression;
import org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;
import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
import org.eclipse.jdt.internal.compiler.ast.EqualExpression;
import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
import jetbrains.mps.smodel.SReference;
import org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression;
import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
import org.eclipse.jdt.internal.compiler.ast.PostfixExpression;
import org.eclipse.jdt.internal.compiler.ast.PrefixExpression;
import org.eclipse.jdt.internal.compiler.ast.CastExpression;
import org.eclipse.jdt.internal.compiler.ast.NameReference;
import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
import org.eclipse.jdt.internal.compiler.ast.SuperReference;
import org.eclipse.jdt.internal.compiler.ast.ThisReference;
import org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;
import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
import org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;
import org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;
import org.eclipse.jdt.internal.compiler.ast.Annotation;
import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;
import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
import org.eclipse.jdt.internal.compiler.ast.FieldReference;
import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
import org.eclipse.jdt.internal.compiler.lookup.ParameterizedFieldBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;
import jetbrains.mps.smodel.SNodePointer;
import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.NestedTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference;
import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
import org.eclipse.jdt.internal.compiler.ast.UnaryExpression;
import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
import org.eclipse.jdt.internal.compiler.lookup.Binding;
import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
import org.eclipse.jdt.internal.compiler.ast.AssertStatement;
import org.eclipse.jdt.internal.compiler.ast.Block;
import org.eclipse.jdt.internal.compiler.ast.BreakStatement;
import org.eclipse.jdt.internal.compiler.ast.CaseStatement;
import org.eclipse.jdt.internal.compiler.ast.ContinueStatement;
import org.eclipse.jdt.internal.compiler.ast.DoStatement;
import org.eclipse.jdt.internal.compiler.ast.EmptyStatement;
import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ReturnStatement;
import org.eclipse.jdt.internal.compiler.ast.ForeachStatement;
import org.eclipse.jdt.internal.compiler.ast.ForStatement;
import org.eclipse.jdt.internal.compiler.ast.IfStatement;
import org.eclipse.jdt.internal.compiler.ast.LabeledStatement;
import org.eclipse.jdt.internal.compiler.ast.SwitchStatement;
import org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;
import org.eclipse.jdt.internal.compiler.ast.ThrowStatement;
import org.eclipse.jdt.internal.compiler.ast.TryStatement;
import org.eclipse.jdt.internal.compiler.ast.WhileStatement;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Initializer;
import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
import org.eclipse.jdt.internal.compiler.ast.Argument;
import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Javadoc;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;

public class JavaConverterTreeBuilder {
  private static final Logger LOG = Logger.getLogger(JavaConverterTreeBuilder.class);

  private SModel myCurrentModel;
  private Map<String, SModel> myModelMap;
  private boolean myIsolated = false;
  private SNode myCurrentClass;
  private TypeDeclaration myCurrentTypeDeclaration;
  private SNode myCurrentMethod;
  private TypesProvider myTypesProvider;
  public List<Tuples._4<SNode, CompilationUnitDeclaration, Integer, Integer>> myBlocks = ListSequence.fromList(new ArrayList<Tuples._4<SNode, CompilationUnitDeclaration, Integer, Integer>>());
  public Map<SNode, Integer> myPositions = MapSequence.fromMap(new HashMap<SNode, Integer>());

  public JavaConverterTreeBuilder() {
  }

  public SNode processExpressionRefl(Expression expression) {
    SNode result = null;
    if (expression instanceof Literal && expression.constant != null && expression.constant != Constant.NotAConstant) {
      result = SNodeOperations.cast(dispatchRefl("processConstant", expression.constant), "jetbrains.mps.baseLanguage.structure.Expression");
    }
    if ((result == null)) {
      result = SNodeOperations.cast(dispatchRefl("processExpression", expression), "jetbrains.mps.baseLanguage.structure.Expression");
    }
    if (expression != null) {
      int parenthesisCount = (expression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;
      for (int parenthsCreated = 0; parenthsCreated < parenthesisCount; parenthsCreated++) {
        SNode parenthesizedExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
        SLinkOperations.setTarget(parenthesizedExpression, "expression", result, true);
        result = parenthesizedExpression;
      }
    }
    return result;
  }

  public SNode processStatementRefl(Statement x) {
    if (x == null) {
      return null;
    }
    SNode statement;
    if (x instanceof Expression) {
      SNode expr = processExpressionRefl((Expression) x);
      if ((expr == null)) {
        return null;
      }
      SNode expressionStatement = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ExpressionStatement", null);
      SLinkOperations.setTarget(expressionStatement, "expression", expr, true);
      statement = expressionStatement;
    } else {
      statement = SNodeOperations.cast(dispatchRefl("processStatement", x), "jetbrains.mps.baseLanguage.structure.Statement");
    }
    MapSequence.fromMap(myPositions).put(statement, x.sourceEnd());
    return statement;
  }

  protected SNode dispatchRefl(String name, Object child) {
    if (child == null) {
      return null;
    }
    try {
      Method method = getClass().getDeclaredMethod(name, child.getClass());
      return (SNode) method.invoke(this, child);
    } catch (Throwable e) {
      if (e instanceof InvocationTargetException) {
        e = ((InvocationTargetException) e).getTargetException();
      }
      throw new JavaConverterException(e);
    }
  }

  /*package*/ List<SNode> processExpressionStatements(Statement[] statements) {
    List<SNode> expressionStatements = new ArrayList<SNode>();
    if (statements != null) {
      for (int i = 0, n = statements.length; i < n; ++i) {
        SNode statement = processStatementRefl(statements[i]);
        if ((statement != null)) {
          ListSequence.fromList(expressionStatements).addElement(SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.ExpressionStatement"));
        }
      }
    }
    return expressionStatements;
  }

  /*package*/ SNode processConstant(BooleanConstant x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.BooleanConstant", null);
    SPropertyOperations.set(result, "value", "" + x.booleanValue());
    return result;
  }

  /*package*/ SNode processConstant(ByteConstant x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.IntegerConstant", null);
    SPropertyOperations.set(result, "value", "" + x.byteValue());
    return result;
  }

  /*package*/ SNode processConstant(CharConstant x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.CharConstant", null);
    String value = NameUtil.escapeChar(x.charValue());
    SPropertyOperations.set(result, "charConstant", value);
    return result;
  }

  /*package*/ SNode processConstant(DoubleConstant x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.FloatingPointConstant", null);
    SPropertyOperations.set(result, "value", x.doubleValue() + "");
    return result;
  }

  /*package*/ SNode processConstant(FloatConstant x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.FloatingPointFloatConstant", null);
    SPropertyOperations.set(result, "value", x.floatValue() + "f");
    return result;
  }

  /*package*/ SNode processConstant(IntConstant x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.IntegerConstant", null);
    SPropertyOperations.set(result, "value", "" + x.intValue());
    return result;
  }

  /*package*/ SNode processConstant(LongConstant x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.LongLiteral", null);
    SPropertyOperations.set(result, "value", x.longValue() + "L");
    return result;
  }

  /*package*/ SNode processConstant(ShortConstant x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.IntegerConstant", null);
    SPropertyOperations.set(result, "value", "" + x.shortValue());
    return result;
  }

  /*package*/ SNode processConstant(StringConstant x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StringLiteral", null);
    SPropertyOperations.set(result, "value", NameUtil.escapeString(x.stringValue()));
    return result;
  }

  /*package*/ SNode processBinaryOperation(Expression left, Expression right, SNode binaryOperation) {
    SLinkOperations.setTarget(binaryOperation, "leftExpression", processExpressionRefl(left), true);
    SLinkOperations.setTarget(binaryOperation, "rightExpression", processExpressionRefl(right), true);
    return binaryOperation;
  }

  /*package*/ SNode processExpression(AND_AND_Expression x) {
    SNode andExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.AndExpression", null);
    return processBinaryOperation(x.left, x.right, andExpression);
  }

  /*package*/ SNode processExpression(OR_OR_Expression x) {
    SNode orExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.OrExpression", null);
    return processBinaryOperation(x.left, x.right, orExpression);
  }

  /*package*/ SNode processExpression(ArrayAllocationExpression x) {
    SNode type = createType(x.resolvedType);
    if (!(SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.ArrayType"))) {
      throw new JavaConverterException("a type of array allocation should be an array type");
    }
    SNode arrayType = SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ArrayType");
    if (x.initializer != null) {
      List<SNode> initializers = new ArrayList<SNode>();
      if (x.initializer.expressions != null) {
        for (Expression expression : x.initializer.expressions) {
          ListSequence.fromList(initializers).addElement(processExpressionRefl(expression));
        }
      }
      SNode arrayCreator = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ArrayCreatorWithInitializer", null);
      for (SNode initializer : initializers) {
        ListSequence.fromList(SLinkOperations.getTargets(arrayCreator, "initValue", true)).addElement(initializer);
      }
      SLinkOperations.setTarget(arrayCreator, "componentType", SNodeOperations.copyNode(SLinkOperations.getTarget(arrayType, "componentType", true)), true);
      SNode genericNewExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
      SLinkOperations.setTarget(genericNewExpression, "creator", arrayCreator, true);
      return genericNewExpression;
    } else {
      List<SNode> dims = new ArrayList<SNode>();
      for (Expression dimension : x.dimensions) {
        if (dimension == null) {
          ListSequence.fromList(dims).addElement(null);
        } else {
          ListSequence.fromList(dims).addElement(processExpressionRefl(dimension));
        }
      }
      SNode arrayCreator = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ArrayCreator", null);
      for (SNode dim : dims) {
        SNode dimensionExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.DimensionExpression", null);
        ListSequence.fromList(SLinkOperations.getTargets(arrayCreator, "dimensionExpression", true)).addElement(dimensionExpression);
        if (dim != null) {
          SLinkOperations.setTarget(dimensionExpression, "expression", dim, true);
        }
      }
      SNode deepestComponentType = SLinkOperations.getTarget(arrayType, "componentType", true);
      while (SNodeOperations.isInstanceOf(deepestComponentType, "jetbrains.mps.baseLanguage.structure.ArrayType")) {
        deepestComponentType = SLinkOperations.getTarget(SNodeOperations.cast(deepestComponentType, "jetbrains.mps.baseLanguage.structure.ArrayType"), "componentType", true);
      }
      SLinkOperations.setTarget(arrayCreator, "componentType", SNodeOperations.copyNode(deepestComponentType), true);
      SNode genericNewExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
      SLinkOperations.setTarget(genericNewExpression, "creator", arrayCreator, true);
      return genericNewExpression;
    }
  }

  /*package*/ SNode processExpression(ArrayInitializer x) {
    List<SNode> initializers = new ArrayList<SNode>();
    if (x.expressions != null) {
      for (Expression expression : x.expressions) {
        ListSequence.fromList(initializers).addElement(processExpressionRefl(expression));
      }
    }
    SNode arrayLiteral = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ArrayLiteral", null);
    for (SNode initializer : initializers) {
      ListSequence.fromList(SLinkOperations.getTargets(arrayLiteral, "item", true)).addElement(initializer);
    }
    return arrayLiteral;
  }

  /*package*/ SNode processExpression(ArrayReference x) {
    SNode accessExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ArrayAccessExpression", null);
    SLinkOperations.setTarget(accessExpression, "array", processExpressionRefl(x.receiver), true);
    SLinkOperations.setTarget(accessExpression, "index", processExpressionRefl(x.position), true);
    return accessExpression;
  }

  /*package*/ SNode processExpression(Assignment x) {
    SNode assignmentExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.AssignmentExpression", null);
    SLinkOperations.setTarget(assignmentExpression, "lValue", processExpressionRefl(x.lhs), true);
    SLinkOperations.setTarget(assignmentExpression, "rValue", processExpressionRefl(x.expression), true);
    return assignmentExpression;
  }

  /*package*/ SNode processExpression(BinaryExpression x) {
    SNode op;
    int binOp = (x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT;
    switch (binOp) {
      case OperatorIds.LEFT_SHIFT:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ShiftLeftExpression", null);
        break;
      case OperatorIds.RIGHT_SHIFT:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ShiftRightExpression", null);
        break;
      case OperatorIds.UNSIGNED_RIGHT_SHIFT:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ShiftRightUnsignedExpression", null);
        break;
      case OperatorIds.PLUS:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.PlusExpression", null);
        break;
      case OperatorIds.MINUS:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.MinusExpression", null);
        break;
      case OperatorIds.REMAINDER:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.RemExpression", null);
        break;
      case OperatorIds.XOR:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.BitwiseXorExpression", null);
        break;
      case OperatorIds.AND:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.BitwiseAndExpression", null);
        break;
      case OperatorIds.MULTIPLY:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.MulExpression", null);
        break;
      case OperatorIds.OR:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.BitwiseOrExpression", null);
        break;
      case OperatorIds.DIVIDE:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.DivExpression", null);
        break;
      case OperatorIds.LESS_EQUAL:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.LessThanOrEqualsExpression", null);
        break;
      case OperatorIds.GREATER_EQUAL:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.GreaterThanOrEqualsExpression", null);
        break;
      case OperatorIds.GREATER:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.GreaterThanExpression", null);
        break;
      case OperatorIds.LESS:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.LessThanExpression", null);
        break;
      default:
        throw new JavaConverterException("Unsupported operator for BinaryExpression");
    }
    return processBinaryOperation(x.left, x.right, op);
  }

  /*package*/ SNode processExpression(CombinedBinaryExpression x) {
    return processExpression((BinaryExpression) x);
  }

  /*package*/ SNode processExpression(CompoundAssignment x) {
    SNode op;
    switch (x.operator) {
      case OperatorIds.PLUS:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.PlusAssignmentExpression", null);
        break;
      case OperatorIds.MINUS:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.MinusAssignmentExpression", null);
        break;
      case OperatorIds.MULTIPLY:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.MulAssignmentExpression", null);
        break;
      case OperatorIds.DIVIDE:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.DivAssignmentExpression", null);
        break;
      case OperatorIds.AND:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.AndAssignmentExpression", null);
        break;
      case OperatorIds.OR:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.OrAssignmentExpression", null);
        break;
      case OperatorIds.XOR:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.XorAssignmentExpression", null);
        break;
      case OperatorIds.REMAINDER:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.RemAssignmentExpression", null);
        break;
      case OperatorIds.LEFT_SHIFT:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.LeftShiftAssignmentExpression", null);
        break;
      case OperatorIds.RIGHT_SHIFT:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.RightShiftAssignmentExpression", null);
        break;
      case OperatorIds.UNSIGNED_RIGHT_SHIFT:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.UnsignedRightShiftAssignmentExpression", null);
        break;
      default:
        throw new JavaConverterException("Unsupported operator for CompoundAssignment");
    }
    SLinkOperations.setTarget(op, "lValue", processExpressionRefl(x.lhs), true);
    SLinkOperations.setTarget(op, "rValue", processExpressionRefl(x.expression), true);
    return op;
  }

  /*package*/ SNode processExpression(ConditionalExpression x) {
    SNode ifTest = processExpressionRefl(x.condition);
    SNode thenExpr = processExpressionRefl(x.valueIfTrue);
    SNode elseExpr = processExpressionRefl(x.valueIfFalse);
    SNode tOp = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression", null);
    SLinkOperations.setTarget(tOp, "condition", ifTest, true);
    SLinkOperations.setTarget(tOp, "ifTrue", thenExpr, true);
    SLinkOperations.setTarget(tOp, "ifFalse", elseExpr, true);
    return tOp;
  }

  /*package*/ SNode processExpression(EqualExpression x) {
    SNode op;
    switch ((x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) {
      case OperatorIds.EQUAL_EQUAL:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.EqualsExpression", null);
        break;
      case OperatorIds.NOT_EQUAL:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.NotEqualsExpression", null);
        break;
      default:
        throw new JavaConverterException("Unexpected operator for EqualExpression");
    }
    return processBinaryOperation(x.left, x.right, op);
  }

  /*package*/ SNode processExpression(ExplicitConstructorCall x) {
    if (x.isImplicitSuper()) {
      return null;
    }
    SNode result = (x.isSuperAccess() ?
      SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.SuperConstructorInvocation", null) :
      SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ThisConstructorInvocation", null)
    );
    addCallArgs(x.arguments, result);
    SReference methodReference = myTypesProvider.createMethodReference(x.binding, "baseMethodDeclaration", result);
    if (methodReference != null) {
      result.addReference(methodReference);
    }
    return result;
  }

  /*package*/ SNode processExpression(InstanceOfExpression x) {
    SNode expr = processExpressionRefl(x.expression);
    SNode testType = createType(x.type.resolvedType);
    SNode instanceOfExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.InstanceOfExpression", null);
    SLinkOperations.setTarget(instanceOfExpression, "leftExpression", expr, true);
    SLinkOperations.setTarget(instanceOfExpression, "classType", testType, true);
    return instanceOfExpression;
  }

  private SNode createType(TypeBinding binding) {
    return myTypesProvider.createType(binding);
  }

  /*package*/ SNode processExpression(PostfixExpression x) {
    SNode op;
    switch (x.operator) {
      case OperatorIds.MINUS:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.PostfixDecrementExpression", null);
        break;
      case OperatorIds.PLUS:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.PostfixIncrementExpression", null);
        break;
      default:
        throw new JavaConverterException("Unexpected postfix operator");
    }
    SLinkOperations.setTarget(op, "expression", processExpressionRefl(x.lhs), true);
    return op;
  }

  /*package*/ SNode processExpression(PrefixExpression x) {
    SNode op;
    switch (x.operator) {
      case OperatorIds.MINUS:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.PrefixDecrementExpression", null);
        break;
      case OperatorIds.PLUS:
        op = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.PrefixIncrementExpression", null);
        break;
      default:
        throw new JavaConverterException("Unexpected prefix operator");
    }
    SLinkOperations.setTarget(op, "expression", processExpressionRefl(x.lhs), true);
    return op;
  }

  /*package*/ SNode processExpression(CastExpression x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.CastExpression", null);
    SLinkOperations.setTarget(result, "expression", processExpressionRefl(x.expression), true);
    if (x.type != null) {
      if (x.type.resolvedType != null) {
        SLinkOperations.setTarget(result, "type", createType(x.type.resolvedType), true);
      } else if (x.type instanceof NameReference && ((NameReference) x.type).binding instanceof TypeBinding) {
        SLinkOperations.setTarget(result, "type", createType((TypeBinding) ((NameReference) x.type).binding), true);
      }
    }
    return result;
  }

  /*package*/ SNode processExpression(NullLiteral x) {
    return SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.NullLiteral", null);
  }

  /*package*/ SNode processExpression(SuperReference x) {
    throw new JavaConverterException("we have no super-references; this case should be analyzed as method call");
  }

  /*package*/ SNode processExpression(ThisReference x) {
    return SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ThisExpression", null);
  }

  /*package*/ SNode processExpression(NormalAnnotation x) {
    SNode annotationInstance = prepareAnnotationInstance(x);
    MemberValuePair[] pairs = x.memberValuePairs();
    if (pairs != null) {
      for (MemberValuePair pair : pairs) {
        SNode value = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.AnnotationInstanceValue", null);
        SLinkOperations.setTarget(value, "value", processExpressionRefl(pair.value), true);
        SNode valueNode = value;
        if (pair.binding == null) {
          valueNode.addReference(myTypesProvider.createErrorReference("key", new String(pair.name), valueNode));
        } else {
          valueNode.addReference(myTypesProvider.createMethodReference(pair.binding, "key", valueNode));
        }
        ListSequence.fromList(SLinkOperations.getTargets(annotationInstance, "value", true)).addElement(value);
      }
    }
    return annotationInstance;
  }

  /*package*/ SNode processExpression(MarkerAnnotation x) {
    return prepareAnnotationInstance(x);
  }

  /*package*/ SNode processExpression(SingleMemberAnnotation x) {
    SNode annotationInstance = prepareAnnotationInstance(x);
    SNode value = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.AnnotationInstanceValue", null);
    MemberValuePair[] pairs = x.memberValuePairs();
    if (pairs != null) {
      MemberValuePair pair = pairs[0];
      SLinkOperations.setTarget(value, "value", processExpressionRefl(pair.value), true);
      SNode valueNode = value;
      if (pair.binding == null) {
        valueNode.addReference(myTypesProvider.createErrorReference("key", new String(pair.name), valueNode));
      } else {
        valueNode.addReference(myTypesProvider.createMethodReference(pair.binding, "key", valueNode));
      }
      ListSequence.fromList(SLinkOperations.getTargets(annotationInstance, "value", true)).addElement(value);
    }
    return annotationInstance;
  }

  /*package*/ SNode prepareAnnotationInstance(Annotation annotation) {
    SNode annotationInstance = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.AnnotationInstance", null);
    SNode sourceNode = annotationInstance;
    AnnotationBinding annotationBinding = annotation.getCompilerAnnotation();
    SReference classifierReference = null;
    if (annotationBinding == null) {
      TypeReference type = annotation.type;
      if (type != null) {
        classifierReference = myTypesProvider.createErrorClassifierReference("annotation", type.resolvedType, sourceNode);
      }
    } else {
      classifierReference = myTypesProvider.createClassifierReference(annotationBinding.getAnnotationType(), "annotation", sourceNode);
    }
    if (classifierReference != null) {
      sourceNode.addReference(classifierReference);
    }
    return annotationInstance;
  }

  /*package*/ SNode processExpression(QualifiedThisReference x) {
    SNode thisRef = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ThisExpression", null);
    TypeBinding typeBinding = x.qualification.resolvedType;
    thisRef.addReference(myTypesProvider.createClassifierReference((ReferenceBinding) typeBinding, "classConcept", thisRef));
    return thisRef;
  }

  /*package*/ SNode processExpression(FieldReference x) {
    FieldBinding fieldBinding = x.binding;
    return expressionFromFieldBinding(fieldBinding, processExpressionRefl(x.receiver));
  }

  private ReferenceBinding getDeclaredClassBinding(FieldBinding fieldBinding) {
    if (fieldBinding instanceof ParameterizedFieldBinding) {
      return ((ParameterizedFieldBinding) fieldBinding).originalField.declaringClass;
    } else {
      return fieldBinding.declaringClass;
    }
  }

  private SNode fieldReferenceFromProblem(ProblemBinding binding, String firstName, String secondName) {
    SNode sfr = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StaticFieldReference", null);
    SNode sourceNode = sfr;
    sourceNode.addReference(myTypesProvider.createErrorReference("classifier", firstName, sourceNode));
    sourceNode.addReference(myTypesProvider.createErrorReference("variableDeclaration", secondName, sourceNode));
    return sfr;
  }

  private SNode expressionFromFieldBinding(FieldBinding fieldBinding, SNode instanceExpression) {
    String role;
    SNode sourceNode;
    SNode result;
    ReferenceBinding declaredClassBinding = getDeclaredClassBinding(fieldBinding);
    if (fieldBinding.isStatic()) {
      SNodePointer classifierPointer = myTypesProvider.createClassifierPointer(declaredClassBinding);
      if (fieldBinding.declaringClass.isEnum()) {
        SNode enumConstantReference = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.EnumConstantReference", null);
        role = "enumConstantDeclaration";
        sourceNode = enumConstantReference;
        enumConstantReference.addReference(SReference.create("enumClass", sourceNode, classifierPointer, new String(fieldBinding.name)));
        result = enumConstantReference;
      } else
      if (myCurrentClass == myTypesProvider.getRaw(declaredClassBinding)) {
        role = "variableDeclaration";
        SNode lsfr = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.LocalStaticFieldReference", null);
        sourceNode = lsfr;
        result = lsfr;
      } else {
        SNode sfr = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StaticFieldReference", null);
        sourceNode = sfr;
        role = "variableDeclaration";
        sfr.addReference(SReference.create("classifier", sourceNode, classifierPointer, new String(fieldBinding.name)));
        result = sfr;
      }
    } else {
      if (instanceExpression == null) {
        role = "variableDeclaration";
        SNode lifr = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.LocalInstanceFieldReference", null);
        sourceNode = lifr;
        result = lifr;
      } else {
        role = "fieldDeclaration";
        SNode instance;
        instance = instanceExpression;
        if (declaredClassBinding == null) {
          return createArrayLengthExpression(instance, fieldBinding);
        }
        SNode fieldRef = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation", null);
        SNode dotExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.DotExpression", null);
        SLinkOperations.setTarget(dotExpression, "operation", fieldRef, true);
        SLinkOperations.setTarget(dotExpression, "operand", instance, true);
        sourceNode = fieldRef;
        result = dotExpression;
      }
    }
    SReference fieldReference = myTypesProvider.createFieldReference(fieldBinding, role, sourceNode);
    sourceNode.addReference(fieldReference);
    return result;
  }

  private boolean isSubtype(ReferenceBinding subtype, TypeBinding supertype) {
    if (subtype instanceof ParameterizedTypeBinding) {
      subtype = ((ParameterizedTypeBinding) subtype).genericType();
    }
    if (supertype == subtype) {
      return true;
    }
    if (subtype.superclass() != null) {
      if (isSubtype(subtype.superclass(), supertype)) {
        return true;
      }
    }
    if (subtype.superInterfaces() != null) {
      for (ReferenceBinding infc : subtype.superInterfaces()) {
        if (isSubtype(infc, supertype)) {
          return true;
        }
      }
    }
    return false;
  }

  private SNode createThisExpression(MethodBinding binding, Expression receiver) {
    ReferenceBinding methodDeclaringClass = binding.declaringClass;
    SourceTypeBinding currentClass = myCurrentTypeDeclaration.binding;
    SNode thisExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ThisExpression", null);
    if (currentClass == methodDeclaringClass) {
      return thisExpression;
    }
    if (isSubtype(currentClass, methodDeclaringClass)) {
      return thisExpression;
    }
    while (!(currentClass.isStatic()) && currentClass.isNestedType()) {
      currentClass = ((NestedTypeBinding) currentClass).enclosingType;
      if (isSubtype(currentClass, methodDeclaringClass)) {
        break;
      }
    }
    thisExpression.addReference(myTypesProvider.createClassifierReference((ReferenceBinding) currentClass, "classConcept", thisExpression));
    return thisExpression;
  }

  /*package*/ SNode processValuesExpression(SyntheticMethodBinding binding) {
    SNode expression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.EnumValuesExpression", null);
    SReference classifierReference = myTypesProvider.createClassifierReference(binding.declaringClass, "enumClass", expression);
    expression.addReference(classifierReference);
    return expression;
  }

  /*package*/ SNode processValueOfExpression(SyntheticMethodBinding binding, MessageSend x) {
    SNode expression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.EnumValueOfExpression", null);
    SReference classifierReference = myTypesProvider.createClassifierReference(binding.declaringClass, "enumClass", expression);
    expression.addReference(classifierReference);
    if (x.arguments != null) {
      SLinkOperations.setTarget(expression, "value", processExpressionRefl(x.arguments[0]), true);
    }
    return expression;
  }

  /*package*/ SNode processExpression(MessageSend x) {
    if (x.binding instanceof SyntheticMethodBinding) {
      SyntheticMethodBinding syntheticMethodBinding = (SyntheticMethodBinding) x.binding;
      if (syntheticMethodBinding.purpose == SyntheticMethodBinding.EnumValues) {
        return processValuesExpression(syntheticMethodBinding);
      }
      if (syntheticMethodBinding.purpose == SyntheticMethodBinding.EnumValueOf) {
        return processValueOfExpression(syntheticMethodBinding, x);
      }
    }
    SNode methodCall = null;
    SNode result;
    if (x.binding != null && x.binding.isStatic()) {
      SNode smc = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StaticMethodCall", null);
      methodCall = smc;
      result = smc;
      SReference classifierReference = myTypesProvider.createClassifierReference(x.binding.declaringClass, "classConcept", smc);
      smc.addReference(classifierReference);
    } else
    if (x.receiver instanceof SuperReference || x.receiver instanceof QualifiedSuperReference) {
      SNode smc = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.SuperMethodCall", null);
      methodCall = smc;
      result = smc;
    } else {
      if (x.receiver instanceof ThisReference && x.receiver.isImplicitThis()) {
        SNode limc = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.LocalInstanceMethodCall", null);
        methodCall = limc;
        result = limc;
      } else {
        SNode qualifier;
        SNode imco = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation", null);
        methodCall = imco;
        qualifier = processExpressionRefl(x.receiver);
        SNode dotExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.DotExpression", null);
        SLinkOperations.setTarget(dotExpression, "operand", qualifier, true);
        SLinkOperations.setTarget(dotExpression, "operation", imco, true);
        result = dotExpression;
      }
    }
    SReference methodReference;
    if (x.binding == null) {
      methodReference = myTypesProvider.createErrorReference("baseMethodDeclaration", new String(x.selector), methodCall);
    } else
    if (x.binding instanceof ProblemMethodBinding) {
      ProblemMethodBinding problemMethodBinding = (ProblemMethodBinding) x.binding;
      methodReference = myTypesProvider.createErrorReference("baseMethodDeclaration", new String(problemMethodBinding.selector), methodCall);
    } else {
      methodReference = myTypesProvider.createMethodReference(x.binding, "baseMethodDeclaration", methodCall);
    }
    if (methodReference != null) {
      methodCall.addReference(methodReference);
    }
    addMethodTypeArgs(x.typeArguments, methodCall);
    addCallArgs(x.arguments, methodCall);
    return result;
  }

  /*package*/ SNode processExpression(AllocationExpression x) {
    MethodBinding b = x.binding;
    SNode classCreator = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ClassCreator", null);
    SReference methodReference = myTypesProvider.createMethodReference(b, "baseMethodDeclaration", classCreator);
    if (methodReference == null && x.resolvedType != null) {
      methodReference = myTypesProvider.createErrorReference("baseMethodDeclaration", new String(x.resolvedType.sourceName()), classCreator);
    }
    if (methodReference != null) {
      classCreator.addReference(methodReference);
    }
    if (x.enumConstant != null) {
      throw new JavaConverterException("unexpected enum constant creation");
    }
    if (x.resolvedType instanceof ParameterizedTypeBinding) {
      ParameterizedTypeBinding ptb = (ParameterizedTypeBinding) x.resolvedType;
      TypeBinding[] typeArguments = ptb.arguments;
      if (typeArguments != null) {
        for (TypeBinding typeBinding : typeArguments) {
          ListSequence.fromList(SLinkOperations.getTargets(classCreator, "typeParameter", true)).addElement(createType(typeBinding));
        }
      }
    }
    addMethodTypeArgs(x.typeArguments, classCreator);
    addCallArgs(x.arguments, classCreator);
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
    SLinkOperations.setTarget(result, "creator", classCreator, true);
    return result;
  }

  /*package*/ SNode processExpression(QualifiedAllocationExpression x) {
    MethodBinding b = x.binding;
    SNode creator = null;
    if (x.anonymousType != null) {
      SNode anonymousClassCreator = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.AnonymousClassCreator", null);
      creator = anonymousClassCreator;
      SNode anonymousClass = SNodeOperations.cast(myTypesProvider.getRaw(x.anonymousType.binding), "jetbrains.mps.baseLanguage.structure.AnonymousClass");
      if (x.anonymousType.methods.length > 0 && x.anonymousType.methods[0] instanceof ConstructorDeclaration) {
        MethodBinding superConstructorBinding = ((ConstructorDeclaration) x.anonymousType.methods[0]).constructorCall.binding;
        SReference methodReference = myTypesProvider.createMethodReference(superConstructorBinding, "baseMethodDeclaration", anonymousClass);
        anonymousClass.addReference(methodReference);
        addCallArgs(x.arguments, anonymousClass);
      }
      SLinkOperations.setTarget(anonymousClassCreator, "cls", anonymousClass, true);
    } else {
      if (x.enclosingInstance() == null) {
        return processExpression((AllocationExpression) x);
      }
    }
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
    SLinkOperations.setTarget(result, "creator", creator, true);
    return result;
  }

  private void addMethodTypeArgs(TypeReference[] typeArgs, SNode call) {
    if (typeArgs == null) {
      return;
    }
    for (TypeReference typeArg : typeArgs) {
      SNode type = myTypesProvider.createType(typeArg.resolvedType);
      call.addChild("typeArgument", type);
    }
  }

  private void addCallArgs(Expression[] args, SNode call) {
    if (args == null) {
      args = new Expression[0];
    }
    for (Expression arg : args) {
      SNode expression = processExpressionRefl(arg);
      ListSequence.fromList(SLinkOperations.getTargets(call, "actualArgument", true)).addElement(expression);
    }
  }

  /*package*/ SNode processExpression(ClassLiteralAccess x) {
    if (x.targetType instanceof ReferenceBinding) {
      SNode classExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ClassifierClassExpression", null);
      SReference classifierReference = myTypesProvider.createClassifierReference((ReferenceBinding) x.targetType, "classifier", classExpression);
      classExpression.addReference(classifierReference);
      return classExpression;
    }
    if (x.targetType instanceof BaseTypeBinding) {
      SNode classExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.PrimitiveClassExpression", null);
      SLinkOperations.setTarget(classExpression, "primitiveType", SNodeOperations.cast(myTypesProvider.createType(x.targetType), "jetbrains.mps.baseLanguage.structure.PrimitiveType"), true);
      return classExpression;
    }
    LOG.error("unknown class expression type");
    return null;
  }

  /*package*/ SNode processExpression(UnaryExpression x) {
    int operator = ((x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT);
    switch (operator) {
      case OperatorIds.MINUS:
        SNode unaryMinus = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.UnaryMinus", null);
        SLinkOperations.setTarget(unaryMinus, "expression", processExpressionRefl(x.expression), true);
        return unaryMinus;
      case OperatorIds.NOT:
        SNode notExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.NotExpression", null);
        SLinkOperations.setTarget(notExpression, "expression", processExpressionRefl(x.expression), true);
        return notExpression;
      case OperatorIds.PLUS:
        return processExpressionRefl(x.expression);
      case OperatorIds.TWIDDLE:
        SNode twiddle = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.BitwiseNotExpression", null);
        SLinkOperations.setTarget(twiddle, "expression", processExpressionRefl(x.expression), true);
        return twiddle;
      default:
        throw new JavaConverterException("Unexpected operator for unary expression");
    }
  }

  /*package*/ SNode processExpression(SingleNameReference x) {
    Binding binding = x.binding;
    if (binding instanceof FieldBinding) {
      return expressionFromFieldBinding((FieldBinding) binding, null);
    } else {
      return varFromVariableBinding(binding);
    }
  }

  private SNode varFromVariableBinding(Binding binding) {
    if (binding instanceof ProblemBinding) {
      SNode varReference = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.UnresolvedNameReference", null);
      SPropertyOperations.set(varReference, "resolveName", new String(((ProblemBinding) binding).name));
      return varReference;
    }
    SNode target = myTypesProvider.getRaw(binding);
    if (!(SNodeOperations.isInstanceOf(target, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"))) {
      return null;
    }
    SNode variable = SNodeOperations.cast(target, "jetbrains.mps.baseLanguage.structure.VariableDeclaration");
    SNode result;
    if (SNodeOperations.isInstanceOf(variable, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration")) {
      SNode reference = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.LocalVariableReference", null);
      reference.addReference(SReference.create("variableDeclaration", reference, variable, SPropertyOperations.getString(variable, "name")));
      result = reference;
    } else
    if (SNodeOperations.isInstanceOf(variable, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration")) {
      SNode parameterReference = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ParameterReference", null);
      SLinkOperations.setTarget(parameterReference, "variableDeclaration", SNodeOperations.cast(variable, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration"), false);
      SNodeOperations.getReference(parameterReference, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ParameterReference", "parameterDeclaration")).setResolveInfo(SPropertyOperations.getString(variable, "name"));
      result = parameterReference;
    } else {
      throw new JavaConverterException("Unknown VariableDeclaration subclass.");
    }
    return result;
  }

  /*package*/ SNode processExpression(QualifiedNameReference x) {
    Binding binding = x.binding;
    SNode result;
    if (binding instanceof ProblemBinding) {
      result = fieldReferenceFromProblem((ProblemBinding) binding, new String(x.tokens[0]), new String(x.tokens[1]));
    } else
    if (binding instanceof FieldBinding) {
      result = expressionFromFieldBinding((FieldBinding) binding, null);
    } else {
      result = varFromVariableBinding(binding);
    }
    if (x.otherBindings != null) {
      for (int i = 0; i < x.otherBindings.length; ++i) {
        FieldBinding fieldBinding = x.otherBindings[i];
        result = expressionFromFieldBinding(fieldBinding, result);
      }
    }
    return result;
  }

  private SNode createArrayLengthExpression(SNode operand, FieldBinding fieldBinding) {
    if ("length".equals(new String(fieldBinding.name))) {
      SNode dotExpression = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.DotExpression", null);
      SLinkOperations.setTarget(dotExpression, "operand", operand, true);
      SLinkOperations.setTarget(dotExpression, "operation", SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ArrayLengthOperation", null), true);
      return dotExpression;
    } else {
      throw new JavaConverterException("error matching field binding");
    }
  }

  /*package*/ List<SNode> processStatements(Statement[] statements) {
    List<SNode> result = new ArrayList<SNode>();
    if (statements != null) {
      for (Statement stmt : statements) {
        SNode statement = processStatementRefl(stmt);
        if (statement != null) {
          result.add(statement);
        }
      }
    }
    return result;
  }

  /*package*/ SNode processStatement(AssertStatement x) {
    SNode expr = processExpressionRefl(x.assertExpression);
    SNode arg = processExpressionRefl(x.exceptionArgument);
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.AssertStatement", null);
    SLinkOperations.setTarget(result, "condition", expr, true);
    SLinkOperations.setTarget(result, "message", arg, true);
    return result;
  }

  /*package*/ SNode processStatement(Block x) {
    if (x == null) {
      return null;
    }
    SNode blockStatement = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.BlockStatement", null);
    SNode statementList = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StatementList", null);
    addBlock(statementList, x.sourceStart(), x.sourceEnd());
    SLinkOperations.setTarget(blockStatement, "statements", statementList, true);
    for (SNode statement : processStatements(x.statements)) {
      ListSequence.fromList(SLinkOperations.getTargets(statementList, "statement", true)).addElement(statement);
    }
    return blockStatement;
  }

  /*package*/ SNode processStatement(BreakStatement x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.BreakStatement", null);
    if (x.label != null) {
      SPropertyOperations.set(result, "label", new String(x.label));
    }
    return result;
  }

  /*package*/ SNode processCaseStatement(CaseStatement x) {
    SNode expression = processExpressionRefl(x.constantExpression);
    SNode switchCase = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.SwitchCase", null);
    SLinkOperations.setTarget(switchCase, "expression", expression, true);
    SLinkOperations.setTarget(switchCase, "body", SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StatementList", null), true);
    addBlock(SLinkOperations.getTarget(switchCase, "body", true), x.sourceStart(), x.sourceEnd());
    return switchCase;
  }

  /*package*/ SNode processStatement(ContinueStatement x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ContinueStatement", null);
    if (x.label != null) {
      SPropertyOperations.set(result, "label", new String(x.label));
    }
    return result;
  }

  /*package*/ SNode processStatement(DoStatement x) {
    SNode loopTest = processExpressionRefl(x.condition);
    SNode loopBody = processStatementRefl(x.action);
    SNode doWhileStatement = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.DoWhileStatement", null);
    SLinkOperations.setTarget(doWhileStatement, "condition", loopTest, true);
    SNode body = getStatementListFromStatement(loopBody, x.action);
    SLinkOperations.setTarget(doWhileStatement, "body", body, true);
    return doWhileStatement;
  }

  /*package*/ SNode processStatement(EmptyStatement x) {
    return SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.Statement", null);
  }

  /*package*/ SNode processStatement(LocalDeclaration x) {
    SNode localVariableDeclaration = getLocalVariableDeclaration(x);
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement", null);
    SLinkOperations.setTarget(result, "localVariableDeclaration", localVariableDeclaration, true);
    return result;
  }

  private SNode getLocalVariableDeclaration(LocalDeclaration x) {
    SNode local = SNodeOperations.cast(myTypesProvider.getRaw(x.binding), "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration");
    if ((local == null)) {
      return null;
    }
    SNode initializer = processExpressionRefl(x.initialization);
    SLinkOperations.setTarget(local, "initializer", initializer, true);
    addVariableAnnotations(local, x);
    return local;
  }

  /*package*/ SNode processStatement(ReturnStatement x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ReturnStatement", null);
    SLinkOperations.setTarget(result, "expression", processExpressionRefl(x.expression), true);
    return result;
  }

  /*package*/ SNode processStatement(ForeachStatement x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ForeachStatement", null);
    SNode action = processStatementRefl(x.action);
    SNode body = getStatementListFromStatement(action, x.action);
    SNode elementVar = SNodeOperations.cast(myTypesProvider.getRaw(x.elementVariable.binding), "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration");
    SNode iterable = processExpressionRefl(x.collection);
    SLinkOperations.setTarget(result, "iterable", iterable, true);
    SLinkOperations.setTarget(result, "variable", elementVar, true);
    SLinkOperations.setTarget(result, "body", body, true);
    return result;
  }

  /*package*/ SNode processStatement(ForStatement x) {
    SNode forStatement = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ForStatement", null);
    List<SNode> init = processStatements(x.initializations);
    if (!(init.isEmpty())) {
      boolean first = true;
      for (SNode statement : init) {
        if (SNodeOperations.isInstanceOf(statement, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement")) {
          SNode lvds = SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement");
          SNode variableDeclaration = SLinkOperations.getTarget(lvds, "localVariableDeclaration", true);
          SNodeOperations.detachNode(variableDeclaration);
          if (first) {
            SLinkOperations.setTarget(forStatement, "variable", variableDeclaration, true);
            first = false;
          } else {
            SNode additionalForLoopVariable = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.AdditionalForLoopVariable", null);
            myTypesProvider.replaceUnsafe(variableDeclaration, additionalForLoopVariable);
            SPropertyOperations.set(additionalForLoopVariable, "name", SPropertyOperations.getString(variableDeclaration, "name"));
            SNode inititalizer = SLinkOperations.getTarget(variableDeclaration, "initializer", true);
            if ((inititalizer != null)) {
              SNodeOperations.detachNode(inititalizer);
              SLinkOperations.setTarget(additionalForLoopVariable, "initializer", inititalizer, true);
            }
            ListSequence.fromList(SLinkOperations.getTargets(forStatement, "additionalVar", true)).addElement(additionalForLoopVariable);
          }
        }
      }
    }
    SNode expr = processExpressionRefl(x.condition);
    SLinkOperations.setTarget(forStatement, "condition", expr, true);
    List<SNode> incr = processExpressionStatements(x.increments);
    if (!(incr.isEmpty())) {
      for (SNode expressionStatement : incr) {
        SNode expression = SLinkOperations.getTarget(expressionStatement, "expression", true);
        SNodeOperations.detachNode(expression);
        ListSequence.fromList(SLinkOperations.getTargets(forStatement, "iteration", true)).addElement(expression);
      }
    }
    SNode loopBody = processStatementRefl(x.action);
    SNode body = getStatementListFromStatement(loopBody, x.action);
    SLinkOperations.setTarget(forStatement, "body", body, true);
    return forStatement;
  }

  /*package*/ SNode processStatement(IfStatement x) {
    SNode expr = processExpressionRefl(x.condition);
    SNode thenStmt = processStatementRefl(x.thenStatement);
    SNode elseStmt = processStatementRefl(x.elseStatement);
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.IfStatement", null);
    SLinkOperations.setTarget(result, "condition", expr, true);
    if ((elseStmt != null)) {
      SLinkOperations.setTarget(result, "ifFalseStatement", elseStmt, true);
    }
    SNode ifTrue = getStatementListFromStatement(thenStmt, x.thenStatement);
    // adjust start of the "if" statement list block to get comments from "if (...)" there 
    getBlock(ifTrue)._2(x.sourceStart);
    SLinkOperations.setTarget(result, "ifTrue", ifTrue, true);
    return result;
  }

  /*package*/ SNode processStatement(LabeledStatement x) {
    SNode statement = processStatementRefl(x.statement);
    if ((statement == null)) {
      return null;
    }
    if (SNodeOperations.isInstanceOf(statement, "jetbrains.mps.baseLanguage.structure.AbstractLoopStatement")) {
      SNode loopStatement = SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.AbstractLoopStatement");
      SPropertyOperations.set(loopStatement, "label", new String(x.label));
    } else
    if (SNodeOperations.isInstanceOf(statement, "jetbrains.mps.baseLanguage.structure.SwitchStatement")) {
      SNode switchStatement = SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.SwitchStatement");
      SPropertyOperations.set(switchStatement, "label", new String(x.label));
    }
    return statement;
  }

  /*package*/ SNode processStatement(SwitchStatement x) {
    SNode expression = processExpressionRefl(x.expression);
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.SwitchStatement", null);
    SLinkOperations.setTarget(result, "expression", expression, true);
    SLinkOperations.setTarget(result, "defaultBlock", SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StatementList", null), true);
    if (x.defaultCase != null) {
      addBlock(SLinkOperations.getTarget(result, "defaultBlock", true), x.defaultCase.sourceStart(), x.defaultCase.sourceEnd());
    }
    if (x.statements != null) {
      SNode currentSwitchCase = null;
      for (Statement stmt : x.statements) {
        if (stmt instanceof CaseStatement) {
          CaseStatement caseStatement = (CaseStatement) stmt;
          if (caseStatement.constantExpression == null) {
            currentSwitchCase = SLinkOperations.getTarget(result, "defaultBlock", true);
          } else {
            SNode switchCase = processCaseStatement((CaseStatement) stmt);
            if ((switchCase != null)) {
              ListSequence.fromList(SLinkOperations.getTargets(result, "case", true)).addElement(switchCase);
            }
            currentSwitchCase = ((switchCase == null) ?
              null :
              SLinkOperations.getTarget(switchCase, "body", true)
            );
          }
        } else
        if ((currentSwitchCase != null)) {
          ListSequence.fromList(SLinkOperations.getTargets(currentSwitchCase, "statement", true)).addElement(processStatementRefl(stmt));
        }
      }
    }
    return result;
  }

  /*package*/ SNode processStatement(SynchronizedStatement x) {
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.SynchronizedStatement", null);
    SNode block = processStatementRefl(x.block);
    SNode expr = processExpressionRefl(x.expression);
    SLinkOperations.setTarget(result, "expression", expr, true);
    SLinkOperations.setTarget(result, "block", getStatementListFromStatement(block, x.block), true);
    return result;
  }

  /*package*/ SNode processStatement(ThrowStatement x) {
    SNode toThrow = processExpressionRefl(x.exception);
    SNode throwStatement = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.ThrowStatement", null);
    SLinkOperations.setTarget(throwStatement, "throwable", toThrow, true);
    return throwStatement;
  }

  /*package*/ SNode processStatement(TryStatement x) {
    SNode tryBlock = processStatementRefl(x.tryBlock);
    List<SNode> catchArgs = new ArrayList<SNode>();
    List<SNode> catchBlocks = new ArrayList<SNode>();
    SNode finallyBlock = processStatementRefl(x.finallyBlock);
    if (x.catchBlocks != null) {
      for (int i = 0, c = x.catchArguments.length; i < c; ++i) {
        SNode local = SNodeOperations.cast(myTypesProvider.getRaw(x.catchArguments[i].binding), "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration");
        ListSequence.fromList(catchArgs).addElement(local);
      }
      for (int i = 0, c = x.catchBlocks.length; i < c; ++i) {
        ListSequence.fromList(catchBlocks).addElement(processStatementRefl(x.catchBlocks[i]));
      }
    }
    if ((finallyBlock != null)) {
      SNode tryStatement = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.TryStatement", null);
      for (int i = 0; i < catchBlocks.size(); i++) {
        SNode catchBlock = ListSequence.fromList(catchBlocks).getElement(i);
        SNode lvd = ListSequence.fromList(catchArgs).getElement(i);
        SNode catchClause = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.CatchClause", null);
        ListSequence.fromList(SLinkOperations.getTargets(tryStatement, "catchClause", true)).addElement(catchClause);
        SLinkOperations.setTarget(catchClause, "catchBody", getStatementListFromStatement(catchBlock, x.catchBlocks[i]), true);
        SLinkOperations.setTarget(catchClause, "throwable", lvd, true);
      }
      SLinkOperations.setTarget(tryStatement, "finallyBody", getStatementListFromStatement(finallyBlock, x.finallyBlock), true);
      SLinkOperations.setTarget(tryStatement, "body", getStatementListFromStatement(tryBlock, x.tryBlock), true);
      return tryStatement;
    } else {
      SNode tryCatchStatement = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.TryCatchStatement", null);
      for (int i = 0; i < catchBlocks.size(); i++) {
        SNode catchBlock = ListSequence.fromList(catchBlocks).getElement(i);
        SNode lvd = ListSequence.fromList(catchArgs).getElement(i);
        SNode catchClause = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.CatchClause", null);
        ListSequence.fromList(SLinkOperations.getTargets(tryCatchStatement, "catchClause", true)).addElement(catchClause);
        SLinkOperations.setTarget(catchClause, "catchBody", getStatementListFromStatement(catchBlock, x.catchBlocks[i]), true);
        SLinkOperations.setTarget(catchClause, "throwable", lvd, true);
      }
      SLinkOperations.setTarget(tryCatchStatement, "body", getStatementListFromStatement(tryBlock, x.tryBlock), true);
      return tryCatchStatement;
    }
  }

  /*package*/ SNode processStatement(WhileStatement x) {
    SNode loopTest = processExpressionRefl(x.condition);
    SNode loopBody = processStatementRefl(x.action);
    SNode result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.WhileStatement", null);
    SLinkOperations.setTarget(result, "condition", loopTest, true);
    SLinkOperations.setTarget(result, "body", getStatementListFromStatement(loopBody, x.action), true);
    return result;
  }

  /*package*/ SNode processStatement(TypeDeclaration x) {
    String text = "Conversion error: " + new String(x.binding.sourceName) + " - local types are not supported";
    LOG.error(text);
    return createCommentStatement(text);
  }

  private SNode createCommentStatement(String text) {
    return new JavaConverterTreeBuilder.QuotationClass_m30mvz_a0a0bd().createNode(text);
  }

  public SNode processType(TypeDeclaration x) {
    SNode classifier = SNodeOperations.cast(myTypesProvider.getRaw(x.binding), "jetbrains.mps.baseLanguage.structure.Classifier");
    if (x.binding.isAnnotationType()) {
      myCurrentTypeDeclaration = x;
      if (x.methods != null) {
        for (AbstractMethodDeclaration method : x.methods) {
          processAnnotationMethod((AnnotationMethodDeclaration) method);
        }
      }
      addClassifierAnnotations(classifier, x);
      addClassifierJavadoc(classifier, x.javadoc);
      myCurrentTypeDeclaration = null;
      return classifier;
    }
    myCurrentTypeDeclaration = x;
    myCurrentClass = classifier;
    try {
      if (x.fields != null) {
        for (FieldDeclaration fieldDeclaration : x.fields) {
          if (fieldDeclaration instanceof Initializer) {
            assert (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
            processInitializer((Initializer) fieldDeclaration, SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
          } else {
            processField(fieldDeclaration);
          }
        }
      }
      if (x.methods != null) {
        for (AbstractMethodDeclaration method : x.methods) {
          if (method.isConstructor()) {
            assert (SNodeOperations.isInstanceOf(myCurrentClass, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
            if (x.binding instanceof LocalTypeBinding) {
            } else {
              processConstructor((ConstructorDeclaration) method);
            }
          } else
          if (method.isClinit()) {
            continue;
          } else {
            processMethod(method);
          }
          addExceptionsToMethod(method);
        }
      }
      addClassifierAnnotations(classifier, x);
      addClassifierJavadoc(classifier, x.javadoc);
      myCurrentClass = null;
      myCurrentTypeDeclaration = null;
    } catch (Throwable e) {
      throw new JavaConverterException(e);
    }
    return classifier;
  }

  /*package*/ void addExceptionsToMethod(AbstractMethodDeclaration x) {
    MethodBinding b = x.binding;
    if (b == null) {
      return;
    }
    SNode method = SNodeOperations.cast(myTypesProvider.getRaw(b), "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
    for (ReferenceBinding referenceBinding : b.thrownExceptions) {
      SNode exceptionType = SNodeOperations.cast(myTypesProvider.createType(referenceBinding), "jetbrains.mps.baseLanguage.structure.ClassifierType");
      ListSequence.fromList(SLinkOperations.getTargets(method, "throwsItem", true)).addElement(exceptionType);
    }
  }

  /*package*/ void addMethodParametersAnnotations(AbstractMethodDeclaration x) {
    if (x.arguments != null) {
      for (Argument argument : x.arguments) {
        SNode parameterDeclaration = SNodeOperations.cast(myTypesProvider.getRaw(argument.binding), "jetbrains.mps.baseLanguage.structure.ParameterDeclaration");
        addVariableAnnotations(parameterDeclaration, argument);
      }
    }
  }

  /*package*/ void processAnnotationMethod(AnnotationMethodDeclaration x) {
    MethodBinding b = x.binding;
    SNode method = SNodeOperations.cast(myTypesProvider.getRaw(b), "jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration");
    try {
      myCurrentMethod = method;
      if (x.defaultValue != null) {
        SLinkOperations.setTarget(method, "defaultValue", processExpressionRefl(x.defaultValue), true);
      }
      addMethodAnnotations(method, x);
      addMethodJavadoc(method, x.javadoc);
      myCurrentMethod = null;
    } catch (Throwable t) {
      throw new JavaConverterException(t);
    }
  }

  /*package*/ void processMethod(AbstractMethodDeclaration x) {
    MethodBinding b = x.binding;
    SNode method = SNodeOperations.cast(myTypesProvider.getRaw(b), "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
    if ((method == null)) {
      return;
    }
    try {
      if (x.isNative()) {
        throw new JavaConverterException("Native methods not supported");
      }
      myCurrentMethod = method;
      SNode methodBody = SLinkOperations.getTarget(method, "body", true);
      if ((methodBody == null)) {
        methodBody = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StatementList", null);
        addBlock(methodBody, x.declarationSourceStart, x.declarationSourceEnd);
        SLinkOperations.setTarget(method, "body", methodBody, true);
      }
      for (SNode statement : processStatements(x.statements)) {
        ListSequence.fromList(SLinkOperations.getTargets(methodBody, "statement", true)).addElement(statement);
      }
      addMethodParametersAnnotations(x);
      addMethodAnnotations(method, x);
      addMethodJavadoc(method, x.javadoc);
      myCurrentMethod = null;
    } catch (Throwable e) {
      throw new JavaConverterException(e);
    }
  }

  /*package*/ void processConstructor(ConstructorDeclaration x) {
    SNode ctor = SNodeOperations.cast(myTypesProvider.getRaw(x.binding), "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration");
    try {
      myCurrentMethod = ctor;
      SNode superOrThisCall = null;
      ExplicitConstructorCall ctorCall = x.constructorCall;
      if (ctorCall != null) {
        superOrThisCall = processExpression(ctorCall);
      }
      SNode body = SLinkOperations.getTarget(ctor, "body", true);
      if ((body == null)) {
        body = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StatementList", null);
        addBlock(body, x.declarationSourceStart, x.declarationSourceEnd);
        SLinkOperations.setTarget(ctor, "body", body, true);
      }
      if ((superOrThisCall != null)) {
        ListSequence.fromList(SLinkOperations.getTargets(body, "statement", true)).addElement(superOrThisCall);
      }
      for (SNode statement : processStatements(x.statements)) {
        ListSequence.fromList(SLinkOperations.getTargets(body, "statement", true)).addElement(statement);
      }
      addMethodParametersAnnotations(x);
      addMethodAnnotations(ctor, x);
      addMethodJavadoc(ctor, x.javadoc);
      myCurrentMethod = null;
    } catch (Throwable e) {
      throw new JavaConverterException(e);
    }
  }

  /*package*/ void processInitializer(Initializer initializer, SNode classConcept) {
    SNode body;
    if (initializer.isStatic()) {
      SNode staticInitializer = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StaticInitializer", null);
      SLinkOperations.setTarget(classConcept, "classInitializer", staticInitializer, true);
      SLinkOperations.setTarget(staticInitializer, "statementList", SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StatementList", null), true);
      addBlock(SLinkOperations.getTarget(staticInitializer, "statementList", true), initializer.declarationSourceStart, initializer.declarationSourceEnd);
      body = SLinkOperations.getTarget(staticInitializer, "statementList", true);
    } else {
      SNode instanceInitializer = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.InstanceInitializer", null);
      SLinkOperations.setTarget(classConcept, "instanceInitializer", instanceInitializer, true);
      SLinkOperations.setTarget(instanceInitializer, "statementList", SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StatementList", null), true);
      addBlock(SLinkOperations.getTarget(instanceInitializer, "statementList", true), initializer.declarationSourceStart, initializer.declarationSourceEnd);
      body = SLinkOperations.getTarget(instanceInitializer, "statementList", true);
    }
    if (initializer.block != null && initializer.block.statements != null) {
      List<SNode> stmts = processStatements(initializer.block.statements);
      for (SNode statement : stmts) {
        ListSequence.fromList(SLinkOperations.getTargets(body, "statement", true)).addElement(statement);
      }
    }
  }

  /*package*/ void processField(FieldDeclaration declaration) {
    SNode adapter = myTypesProvider.getRaw(declaration.binding);
    if ((adapter == null)) {
      return;
    }
    if (SNodeOperations.isInstanceOf(adapter, "jetbrains.mps.baseLanguage.structure.FieldDeclaration") || SNodeOperations.isInstanceOf(adapter, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")) {
      SNode field = SNodeOperations.cast(adapter, "jetbrains.mps.baseLanguage.structure.VariableDeclaration");
      try {
        SNode initializer = null;
        if (declaration.initialization != null) {
          initializer = processExpressionRefl(declaration.initialization);
        }
        if (initializer != null) {
          SLinkOperations.setTarget(field, "initializer", initializer, true);
        }
        addVariableAnnotations(field, declaration);
        addFieldJavadoc(field, declaration.javadoc);
      } catch (Throwable e) {
        throw new JavaConverterException(e);
      }
    }

    if (SNodeOperations.isInstanceOf(adapter, "jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration")) {
      try {
        SNode enumConstant = SNodeOperations.cast(adapter, "jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration");
        assert (SNodeOperations.isInstanceOf(myCurrentClass, "jetbrains.mps.baseLanguage.structure.EnumClass"));
        AllocationExpression initializer = (AllocationExpression) declaration.initialization;
        MethodBinding constructorBinding;
        if (initializer instanceof QualifiedAllocationExpression) {
          TypeDeclaration anonymousEnumClass = ((QualifiedAllocationExpression) initializer).anonymousType;
          constructorBinding = ((ConstructorDeclaration) anonymousEnumClass.methods[0]).constructorCall.binding;
          SNode enumClassConstantBody = SNodeOperations.cast(myTypesProvider.getRaw(anonymousEnumClass.binding), "jetbrains.mps.baseLanguage.structure.EnumClass");
          for (SNode imd : SLinkOperations.getTargets(enumClassConstantBody, "method", true)) {
            SNodeOperations.detachNode(imd);
            ListSequence.fromList(SLinkOperations.getTargets(enumConstant, "method", true)).addElement(imd);
          }
          for (AbstractMethodDeclaration m : anonymousEnumClass.methods) {
            if (m instanceof ConstructorDeclaration) {
              continue;
            }
            processMethod(m);
          }
        } else {
          constructorBinding = initializer.binding;
        }
        SNode constructor = SNodeOperations.cast(myTypesProvider.getRaw(constructorBinding.original()), "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration");
        SLinkOperations.setTarget(enumConstant, "baseMethodDeclaration", constructor, false);
        Expression[] arguments = initializer.arguments;
        if (arguments != null) {
          for (Expression arg : arguments) {
            ListSequence.fromList(SLinkOperations.getTargets(enumConstant, "actualArgument", true)).addElement(processExpressionRefl(arg));
          }
        }
        addEnumConstAnnotations(enumConstant, declaration);
        addFieldJavadoc(enumConstant, declaration.javadoc);
      } catch (Throwable t) {
        throw new JavaConverterException(t);
      }
    }
  }

  private void addVariableAnnotations(SNode variableDeclaration, AbstractVariableDeclaration var) {
    if (var.annotations != null) {
      for (Annotation annotation : var.annotations) {
        addAnnotation(variableDeclaration, annotation);
      }
    }
  }

  private void addEnumConstAnnotations(SNode enumConst, FieldDeclaration field) {
    if (field.annotations != null) {
      for (Annotation annotation : field.annotations) {
        addAnnotation(enumConst, annotation);
      }
    }
  }

  private void addMethodAnnotations(SNode methodDeclaration, AbstractMethodDeclaration method) {
    if (method.annotations != null) {
      for (Annotation annotation : method.annotations) {
        addAnnotation(methodDeclaration, annotation);
      }
    }
  }

  private void addClassifierAnnotations(SNode classifier, TypeDeclaration typeDeclaration) {
    if (typeDeclaration.annotations != null) {
      for (Annotation annotation : typeDeclaration.annotations) {
        addAnnotation(classifier, annotation);
      }
    }
  }

  private void addAnnotation(SNode hasAnnotation, Annotation annotation) {
    SNode annotationInstance = SNodeOperations.cast(processExpressionRefl(annotation), "jetbrains.mps.baseLanguage.structure.AnnotationInstance");
    ListSequence.fromList(SLinkOperations.getTargets(hasAnnotation, "annotation", true)).addElement(annotationInstance);
  }

  private void addClassifierJavadoc(SNode node, Javadoc javadoc) {
    if (javadoc == null) {
      return;
    }
    AttributeOperations.createAndSetAttrbiute(node, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.ClassifierDocComment")), "jetbrains.mps.baseLanguage.javadoc.structure.ClassifierDocComment");
    constructJavadoc(AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.ClassifierDocComment"))), javadoc);
  }

  private void addFieldJavadoc(SNode node, Javadoc javadoc) {
    if (javadoc == null) {
      return;
    }
    if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.FieldDeclaration")) {
      AttributeOperations.createAndSetAttrbiute(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.FieldDeclaration"), new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment")), "jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment");
      constructJavadoc(AttributeOperations.getAttribute(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.FieldDeclaration"), new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment"))), javadoc);
    } else if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")) {
      AttributeOperations.createAndSetAttrbiute(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration"), new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment")), "jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment");
      constructJavadoc(AttributeOperations.getAttribute(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration"), new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment"))), javadoc);
    }
  }

  private void addMethodJavadoc(SNode node, Javadoc javadoc) {
    if (javadoc == null) {
      return;
    }
    AttributeOperations.createAndSetAttrbiute(node, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.MethodDocComment")), "jetbrains.mps.baseLanguage.javadoc.structure.MethodDocComment");
    constructJavadoc(AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.MethodDocComment"))), javadoc);
  }

  public void constructJavadoc(SNode doc, Javadoc javadoc) {
    CompilationUnitDeclaration cud = getCUD();
    char[] content = cud.compilationResult().getCompilationUnit().getContents();
    int[][] comments = cud.comments;
    int[] lineends = cud.compilationResult().lineSeparatorPositions;
    // find javadoc in comments 
    for (int[] comment : comments) {
      if (comment[0] == javadoc.sourceStart) {
        List<String> lines = CommentHelper.processJavadoc(CommentHelper.splitString(content, lineends, comment[0], comment[1] + 1));
        for (String text : ListSequence.fromList(lines)) {
          SNode commentLine = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.javadoc.structure.CommentLine", null);
          SPropertyOperations.set(SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(commentLine, "part", true)).getElement(0), "jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart"), "text", text);
          ListSequence.fromList(SLinkOperations.getTargets(doc, "body", true)).addElement(commentLine);
        }
        break;
      }
    }
  }

  public List<SNode> exec(ReferentsCreator referentsCreator, Map<String, SModel> modelMap, boolean isolated) {
    List<SNode> result = new ArrayList<SNode>();
    myTypesProvider = referentsCreator.getTypesProvider();
    myModelMap = modelMap;
    myCurrentClass = null;
    myCurrentMethod = null;
    myCurrentModel = null;
    myIsolated = isolated;
    for (TypeDeclaration type : referentsCreator.getClassifierTypeDecls()) {
      myCurrentModel = getModelByTypeDeclaration(type.binding);
      if (myCurrentModel != null) {
        SNode classifier = processType(type);
        if (referentsCreator.isTopLevelClassifier(type)) {
          if (!(myIsolated)) {
            SModelOperations.addRootNode(myCurrentModel, classifier);
          }
          result.add(classifier);
        }
      }
      myCurrentModel = null;
    }
    return result;
  }

  private CompilationUnitDeclaration getCUD() {
    return myCurrentTypeDeclaration.scope.referenceCompilationUnit();
  }

  private void addBlock(SNode node, int start, int end) {
    ListSequence.fromList(myBlocks).addElement(MultiTuple.<SNode,CompilationUnitDeclaration,Integer,Integer>from(node, getCUD(), Math.abs(start), Math.abs(end)));
  }

  private Tuples._4<SNode, CompilationUnitDeclaration, Integer, Integer> getBlock(final SNode node) {
    return ListSequence.fromList(myBlocks).findFirst(new IWhereFilter<Tuples._4<SNode, CompilationUnitDeclaration, Integer, Integer>>() {
      public boolean accept(Tuples._4<SNode, CompilationUnitDeclaration, Integer, Integer> it) {
        return it._0() == node;
      }
    });
  }

  public SModel getModelByTypeDeclaration(SourceTypeBinding typeBinding) {
    if (typeBinding instanceof NestedTypeBinding) {
      return getModelByTypeDeclaration(((NestedTypeBinding) typeBinding).enclosingType);
    }
    if (myIsolated) {
      return myModelMap.values().iterator().next();
    }
    String packageName = JavaCompiler.packageNameFromCompoundName(typeBinding.compoundName);
    SModel sModel = myModelMap.get(packageName);
    if (sModel == null) {
      LOG.error("can't find a model for Type Declaration " + new String(typeBinding.sourceName) + " : package name is " + packageName);
    }
    return sModel;
  }

  private SNode getStatementListFromStatement(SNode possibleBlock, Statement x) {
    SNode result;
    if (SNodeOperations.isInstanceOf(possibleBlock, "jetbrains.mps.baseLanguage.structure.BlockStatement")) {
      result = SLinkOperations.getTarget(SNodeOperations.cast(possibleBlock, "jetbrains.mps.baseLanguage.structure.BlockStatement"), "statements", true);
      SNodeOperations.detachNode(result);
    } else {
      result = SModelOperations.createNewNode(myCurrentModel, "jetbrains.mps.baseLanguage.structure.StatementList", null);
      addBlock(result, x.sourceStart(), x.sourceEnd());
      if ((possibleBlock != null)) {
        ListSequence.fromList(SLinkOperations.getTargets(result, "statement", true)).addElement(possibleBlock);
      }
    }
    return result;
  }

  public static class QuotationClass_m30mvz_a0a0bd {
    public QuotationClass_m30mvz_a0a0bd() {
    }

    public SNode createNode(Object parameter_5) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.SingleLineComment", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_3 = quotedNode_1;
        {
          quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.TextCommentPart", null, GlobalScope.getInstance(), false);
          SNode quotedNode1_4 = quotedNode_2;
          quotedNode1_4.setProperty("text", (String) parameter_5);
          quotedNode_1.addChild("commentPart", quotedNode1_4);
        }
        result = quotedNode1_3;
      }
      return result;
    }
  }
}
