package jetbrains.mps.internal.make.runtime.util;

/*Generated by MPS */

import jetbrains.mps.make.delta.IDelta;
import jetbrains.mps.logging.Logger;
import java.util.regex.Pattern;
import jetbrains.mps.vfs.IFile;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.make.delta.IDeltaVisitor;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.ArrayList;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.util.Arrays;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.regex.Matcher;
import java.io.File;

public class FilesDelta implements IDelta {
  private static Logger LOG = Logger.getLogger(FilesDelta.class);
  private static Pattern URL = Pattern.compile("[a-zA-Z]://(.*)");
  private static final char SLASH_CHAR = '/';
  private static final String SLASH = "/";

  private IFile rootDir;
  private Map<IFile, FilesDelta.Status> files = MapSequence.fromMap(new HashMap<IFile, FilesDelta.Status>());
  private String key;

  public FilesDelta(IFile dir) {
    this.rootDir = dir;
    this.key = "(IFile)" + asDir(straighten(urlToPath(dir.getAbsolutePath())));
  }

  private FilesDelta(FilesDelta copyFrom) {
    this.rootDir = copyFrom.rootDir;
    this.key = copyFrom.key;
    copy(copyFrom);
  }

  public void written(IFile file) {
    LOG.debug("Written " + file);
    MapSequence.fromMap(files).put(file, FilesDelta.Status.WRITTEN);
  }

  public void kept(IFile file) {
    LOG.debug("Kept " + file);
    MapSequence.fromMap(files).put(file, FilesDelta.Status.KEPT);
  }

  public void deleted(IFile file) {
    LOG.debug("Deleted " + file);
    MapSequence.fromMap(files).put(file, FilesDelta.Status.DELETED);
  }

  public boolean reconcile() {
    return acceptVisitor(new FilesDelta.Visitor() {
      @Override
      public boolean acceptDeleted(IFile file) {
        FilesDelta.LOG.debug("Reconciled: deleting " + file);
        return file.delete();
      }
    });
  }

  public boolean acceptVisitor(IDeltaVisitor visitor) {
    if (!(visitor instanceof FilesDelta.Visitor)) {
      return true;
    }
    return acceptFilesVisitor(((FilesDelta.Visitor) visitor));
  }

  public IDelta merge(IDelta toMerge) {
    if (!(toMerge instanceof FilesDelta)) {
      throw new IllegalArgumentException();
    }
    if (!(this.contains(toMerge))) {
      throw new IllegalArgumentException();
    }
    return new FilesDelta((FilesDelta) this).copy((FilesDelta) toMerge);
  }

  private boolean acceptFilesVisitor(final FilesDelta.Visitor visitor) {
    MapSequence.fromMap(files).visitAll(new IVisitor<IMapping<IFile, FilesDelta.Status>>() {
      public void visit(IMapping<IFile, FilesDelta.Status> m) {
        if (m.value() == FilesDelta.Status.KEPT && !(m.key().isDirectory())) {
          visitor.acceptKept(m.key());
        } else if (m.value() == FilesDelta.Status.WRITTEN) {
          visitor.acceptWritten(m.key());
        }
      }
    });
    ListSequence.fromList(this.collectFilesToDelete()).visitAll(new IVisitor<IFile>() {
      public void visit(IFile f) {
        visitor.acceptDeleted(f);
      }
    });
    return true;
  }

  private List<IFile> collectFilesToDelete() {
    String[] pathsToKeep = MapSequence.fromMap(files).where(new IWhereFilter<IMapping<IFile, FilesDelta.Status>>() {
      public boolean accept(IMapping<IFile, FilesDelta.Status> f) {
        return f.value() != FilesDelta.Status.DELETED;
      }
    }).select(new ISelector<IMapping<IFile, FilesDelta.Status>, String>() {
      public String select(IMapping<IFile, FilesDelta.Status> f) {
        String path = straighten(urlToPath(f.key().getAbsolutePath()));
        return (f.key().isDirectory() ?
          asDir(path) :
          path
        );
      }
    }).sort(new ISelector<String, Comparable<?>>() {
      public Comparable<?> select(String p) {
        return p;
      }
    }, true).toListSequence().toGenericArray(String.class);

    List<IFile> toDelete = ListSequence.fromList(new ArrayList<IFile>());
    Queue<IFile> dirs = QueueSequence.fromQueueAndArray(new LinkedList<IFile>(), rootDir);
    while (QueueSequence.fromQueue(dirs).isNotEmpty()) {
      IFile dir = QueueSequence.fromQueue(dirs).removeFirstElement();
      String dirpath = asDir(straighten(urlToPath(dir.getAbsolutePath())));
      int diridx = Arrays.binarySearch(pathsToKeep, dirpath);
      diridx = (diridx < 0 ?
        -1 - diridx :
        diridx
      );
      for (Tuples._2<IFile, String> fp : Sequence.fromIterable(((Iterable<IFile>) dir.getChildren())).select(new ISelector<IFile, Tuples._2<IFile, String>>() {
        public Tuples._2<IFile, String> select(IFile f) {
          return MultiTuple.<IFile,String>from(f, straighten(urlToPath(f.getAbsolutePath())));
        }
      }).sort(new ISelector<Tuples._2<IFile, String>, Comparable<?>>() {
        public Comparable<?> select(Tuples._2<IFile, String> t) {
          return t._1();
        }
      }, true)) {
        if (fp._0().isDirectory()) {
          int fidx = Arrays.binarySearch(pathsToKeep, asDir(fp._1()));
          fidx = (fidx < 0 ?
            -1 - fidx :
            fidx
          );
          if (fidx >= pathsToKeep.length || !(startsWith(pathsToKeep[fidx], fp._1()))) {
            ListSequence.fromList(toDelete).addElement(fp._0());
            if (fidx >= pathsToKeep.length) {
              break;
            }
          } else if (fidx < pathsToKeep.length) {
            QueueSequence.fromQueue(dirs).addLastElement(fp._0());
          }
        } else {
          int fidx = Arrays.binarySearch(pathsToKeep, fp._1());
          if (fidx < 0 && (diridx >= pathsToKeep.length || !(same(dirpath, pathsToKeep[diridx])))) {
            ListSequence.fromList(toDelete).addElement(fp._0());
          }
        }
      }
    }
    return toDelete;
  }

  private String urlToPath(String maybeUrl) {
    Matcher m = URL.matcher(maybeUrl);
    return (m.matches() ?
      m.group(1) :
      maybeUrl
    );
  }

  private String straighten(String path) {
    return path.replace(File.separatorChar, SLASH_CHAR);
  }

  private String asDir(String path) {
    return (path.endsWith(SLASH) ?
      path :
      path + SLASH
    );
  }

  private FilesDelta copy(FilesDelta that) {
    if (startsWith(this.key, that.key)) {
      this.key = that.key;
      this.rootDir = that.rootDir;
    } else if (!(startsWith(that.key, this.key))) {
      throw new IllegalArgumentException();
    }
    MapSequence.fromMap(files).putAll(that.files);
    return this;
  }

  public boolean contains(IDelta other) {
    if (!(other instanceof FilesDelta)) {
      return false;
    }
    FilesDelta that = (FilesDelta) other;
    if (that.key.equals(this.key)) {
      return true;
    }
    return startsWith(that.key, this.key);
  }

  private boolean startsWith(String path, String prefix) {
    return path.startsWith(prefix) && (path.length() == prefix.length() || prefix.endsWith(SLASH) || path.charAt(prefix.length()) == SLASH_CHAR);
  }

  private boolean same(String path1, String path2) {
    if (path1.equals(path2)) {
      return true;
    }
    if (path1.length() == path2.length()) {
      return false;
    }
    if (path1.length() > path2.length()) {
      {
        Tuples._2<String, String> _tmp_32m4sw_a0c0o = MultiTuple.<String,String>from(path2, path1);
        path1 = _tmp_32m4sw_a0c0o._0();
        path2 = _tmp_32m4sw_a0c0o._1();
      }
    }
    return path2.startsWith(path1) && path2.charAt(path1.length()) == SLASH_CHAR && (path2.length() - path1.length() == 1);
  }

  public static class Visitor implements IDeltaVisitor {
    public Visitor() {
    }

    public boolean acceptWritten(IFile file) {
      return true;
    }

    public boolean acceptKept(IFile file) {
      return true;
    }

    public boolean acceptDeleted(IFile file) {
      return true;
    }
  }

  public static   enum Status {
    WRITTEN(),
    KEPT(),
    DELETED();

    Status() {
    }
  }
}
