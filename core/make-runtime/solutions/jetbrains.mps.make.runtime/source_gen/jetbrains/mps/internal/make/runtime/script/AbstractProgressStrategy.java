package jetbrains.mps.internal.make.runtime.script;

/*Generated by MPS */

import jetbrains.mps.make.script.IProgress;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public abstract class AbstractProgressStrategy {
  private AbstractProgressStrategy.Work last;
  private IProgress current;

  public AbstractProgressStrategy(String total) {
    this.last = new AbstractProgressStrategy.Work(null, total, 1000, 1000);
    this.current = new AbstractProgressStrategy.CurrentProgress();
  }

  protected AbstractProgressStrategy.Work pushProgress(String name, int estimate, int total) {
    return this.last = new AbstractProgressStrategy.Work(last, name, estimate, total);
  }

  protected AbstractProgressStrategy.Work popProgress(AbstractProgressStrategy.Work wrk) {
    return this.last = (wrk.prev != null ?
      wrk.prev :
      wrk
    );
  }

  protected AbstractProgressStrategy.Work lastProgress() {
    return last;
  }

  protected abstract void begunWork(AbstractProgressStrategy.Work wrk);

  protected abstract void advancedWork(AbstractProgressStrategy.Work wrk);

  protected abstract void finishedWork(AbstractProgressStrategy.Work wrk);

  public IProgress currentProgress() {
    return current;
  }

  private static boolean eq_idfyc1_a0a0b0k0(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  public class Work implements IProgress {
    private AbstractProgressStrategy.Work prev;
    private String name;
    private String comment;
    private int estimate;
    private int total;
    private int done = 0;

    public Work(AbstractProgressStrategy.Work prev, String name, int estimate, int ofTotal) {
      this.prev = prev;
      this.name = name;
      this.estimate = estimate;
      this.total = ofTotal;
    }

    public void beginWork(String name, int estimate, int ofTotal) {
      if (estimate <= 0) {
        throw new IllegalArgumentException("invalid estimate value");
      }
      if (ofTotal < 0) {
        throw new IllegalArgumentException("invalid ofTotal value");
      }
      begunWork(pushProgress(name, estimate, ofTotal));
    }

    public void advanceWork(String name, int done) {
      advanceWork(name, done, null);
    }

    public void advanceWork(String name, int done, String comment) {
      if (done < 0) {
        throw new IllegalArgumentException("invalid done value");
      }
      matchingOrTotal(name).primDone(done, comment);
    }

    public void finishWork(String name) {
      AbstractProgressStrategy.Work wrk = matchingOrTotal(name);
      wrk.primDone(wrk.workLeft(), null);
      finishedWork(wrk);
      popProgress(wrk);
    }

    public int workLeft() {
      return Math.max(0, estimate - done);
    }

    public String name() {
      return name;
    }

    public String fullName() {
      List<String> names = this.namePath();
      return IterableUtils.join(ListSequence.fromList(names).reversedList(), "/");
    }

    public String namePrefix() {
      List<String> names = this.namePath();
      return IterableUtils.join(ListSequence.fromList(names).reversedList().cut(1), "/");
    }

    public double doneRatio() {
      return ((double) Math.min(this.estimate, this.done)) / this.estimate;
    }

    public String comment() {
      return comment;
    }

    public AbstractProgressStrategy.Work matchingOrTotal(String name) {
      AbstractProgressStrategy.Work wrk = this;
      while (wrk.prev != null) {
        if (eq_idfyc1_a0a0b0k0(wrk.name, name)) {
          return wrk;
        }
        wrk = wrk.prev;
      }
      return wrk;
    }

    private List<String> namePath() {
      List<String> names = ListSequence.fromList(new ArrayList<String>());
      AbstractProgressStrategy.Work wrk = this;
      while (wrk != null) {
        ListSequence.fromList(names).addElement(wrk.name);
        wrk = wrk.prev;
      }
      return names;
    }

    private void primDone(int primDone, String comment) {
      this.comment = comment;
      if (primDone > 0) {
        this.done += primDone;
        if (prev != null) {
          prev.primDone((int) Math.floor(((double) Math.min(primDone, estimate)) * total / estimate), null);
        }
      }
      advancedWork(this);
    }
  }

  public class CurrentProgress implements IProgress {
    public CurrentProgress() {
    }

    public void beginWork(String name, int estimate, int ofTotal) {
      lastProgress().beginWork(name, estimate, ofTotal);
    }

    public void finishWork(String name) {
      lastProgress().finishWork(name);
    }

    public void advanceWork(String name, int done) {
      lastProgress().advanceWork(name, done);
    }

    public void advanceWork(String name, int done, String comment) {
      lastProgress().advanceWork(name, done, comment);
    }

    public int workLeft() {
      return lastProgress().workLeft();
    }
  }
}
