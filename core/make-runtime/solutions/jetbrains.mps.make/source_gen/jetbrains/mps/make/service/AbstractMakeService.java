package jetbrains.mps.make.service;

/*Generated by MPS */

import jetbrains.mps.make.IMakeService;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.script.IScriptController;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.make.dependencies.ModulesClusterizer;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.make.script.ScriptBuilder;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.make.facet.IFacet;
import jetbrains.mps.make.facet.ITarget;

public abstract class AbstractMakeService implements IMakeService {
  public AbstractMakeService() {
  }

  protected abstract class AbstractInputProcessor {
    protected AbstractInputProcessor() {
    }

    protected final Future<IResult> processRawInput(final Iterable<? extends IResource> inputRes, final IScript defaultScript, IScriptController controller) {
      final Wrappers._T<Iterable<? extends Iterable<IResource>>> clInput = new Wrappers._T<Iterable<? extends Iterable<IResource>>>();
      final Wrappers._T<Iterable<Iterable<String>>> usedLangs = new Wrappers._T<Iterable<Iterable<String>>>();
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          final ModulesClusterizer mcr = new ModulesClusterizer();
          clInput.value = mcr.clusterize(Sequence.fromIterable(inputRes).select(new ISelector<IResource, IResource>() {
            public IResource select(IResource r) {
              return (IResource) r;
            }
          }));
          usedLangs.value = Sequence.fromIterable(clInput.value).select(new ISelector<Iterable<IResource>, Iterable<String>>() {
            public Iterable<String> select(Iterable<IResource> it) {
              return mcr.allUsedLangNamespaces(it);
            }
          }).toListSequence();
        }
      });

      Iterable<ScriptBuilder> scriptBuilders = Sequence.fromIterable(usedLangs.value).select(new ISelector<Iterable<String>, ScriptBuilder>() {
        public ScriptBuilder select(Iterable<String> langs) {
          final ScriptBuilder scb = new ScriptBuilder();
          Sequence.fromIterable(langs).visitAll(new IVisitor<String>() {
            public void visit(String ns) {
              LanguageRuntime lr = LanguageRegistry.getInstance().getLanguage(ns);
              Iterable<IFacet> fcts = lr.getFacetProvider().getDescriptor(null).getManifest().facets();
              scb.withFacetNames(Sequence.fromIterable(fcts).select(new ISelector<IFacet, IFacet.Name>() {
                public IFacet.Name select(IFacet fct) {
                  return fct.getName();
                }
              }));
            }
          });
          return scb.withFinalTarget(new ITarget.Name("jetbrains.mps.lang.core.Make.make"));
        }
      }).toListSequence();

      Iterable<IScript> scripts = ((defaultScript != null ?
        Sequence.fromIterable(scriptBuilders).select(new ISelector<ScriptBuilder, IScript>() {
          public IScript select(ScriptBuilder it) {
            return defaultScript;
          }
        }) :
        Sequence.fromIterable(scriptBuilders).select(new ISelector<ScriptBuilder, IScript>() {
          public IScript select(ScriptBuilder scb) {
            return scb.toScript();
          }
        })
      ));

      return processClusteredInput(clInput.value, scripts, controller);
    }

    protected abstract Future<IResult> processClusteredInput(Iterable<? extends Iterable<IResource>> clustRes, Iterable<IScript> scripts, IScriptController controller);
  }
}
