package jetbrains.mps.make.service;

/*Generated by MPS */

import com.intellij.openapi.progress.Task;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.logging.Logger;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicReference;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.make.script.IScriptController;
import jetbrains.mps.messages.IMessageHandler;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.PerformInBackgroundOption;
import com.intellij.openapi.progress.ProgressIndicator;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.CancellationException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.make.runtime.backports.ProgressIndicatorDelegate;
import java.util.Iterator;
import jetbrains.mps.messages.Message;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.InternalFlag;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class MakeTask extends Task.Backgroundable implements Future<IResult> {
  private static Logger LOG = Logger.getLogger(MakeTask.class);

  private CountDownLatch myLatch = new CountDownLatch(1);
  private AtomicReference<MakeTask.TaskState> myState = new AtomicReference<MakeTask.TaskState>(MakeTask.TaskState.NOT_STARTED);
  private final Iterable<IScript> myScripts;
  private final String myScrName;
  private final Iterable<? extends Iterable<IResource>> myClInput;
  private IResult myResult = null;
  private final IScriptController myController;
  private final IMessageHandler myMessageHandler;

  public MakeTask(@Nullable Project project, @NotNull String title, Iterable<IScript> scripts, String scrName, Iterable<? extends Iterable<IResource>> clInput, IScriptController ctl, IMessageHandler mh, PerformInBackgroundOption bgoption) {
    super(project, title, true, bgoption);
    this.myScripts = scripts;
    this.myScrName = scrName;
    this.myClInput = clInput;
    this.myController = ctl;
    this.myMessageHandler = mh;
  }

  public void run(@NotNull ProgressIndicator pi) {
    if (myState.compareAndSet(MakeTask.TaskState.NOT_STARTED, MakeTask.TaskState.RUNNING)) {
      try {
        doRun(pi);
      } finally {
        try {
          reconcile();
        } catch (RuntimeException ex) {
          LOG.debug("Unexpected exception", ex);
        }
      }
    }
  }

  @Override
  public void onCancel() {
    this.myResult = null;
  }

  public boolean cancel(boolean b) {
    return false;
  }

  public boolean isCancelled() {
    return myState.get() == MakeTask.TaskState.CANCELLED;
  }

  public boolean isDone() {
    return myState.get() != MakeTask.TaskState.NOT_STARTED && myState.get() != MakeTask.TaskState.RUNNING;
  }

  public IResult get() throws InterruptedException, ExecutionException {
    myLatch.await();
    if (myState.get() == MakeTask.TaskState.CANCELLED) {
      throw new CancellationException();
    }
    return myResult;
  }

  public IResult get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
    myLatch.await(timeout, unit);
    if (myState.get() == MakeTask.TaskState.CANCELLED) {
      throw new CancellationException();
    }
    return myResult;
  }

  protected void displayInfo(String info) {
  }

  protected void useProgressIndicator(ProgressIndicator pi) {
  }

  protected void aboutToStart() {
  }

  protected void done() {
  }

  private void doRun(ProgressIndicator pi) {
    aboutToStart();
    pi.pushState();
    final int clsize = Sequence.fromIterable(this.myClInput).count();
    if (clsize == 0) {
      return;
    }
    final double clfrac = (1.0 / clsize);
    final int[] idx = new int[]{0};
    useProgressIndicator(new ProgressIndicatorDelegate(pi) {
      @Override
      public void setFraction(double d) {
        getDelegate().setFraction((idx[0] + d) * clfrac);
      }

      @Override
      public void setText2(String string) {
      }
    });

    Iterator<IScript> scit = Sequence.fromIterable(myScripts).iterator();
    Iterator<? extends Iterable<IResource>> clit = Sequence.fromIterable(myClInput).iterator();
    while (scit.hasNext() && clit.hasNext()) {
      Iterable<IResource> cl = clit.next();
      IScript scr = scit.next();

      if (!(scr.isValid())) {
        String msg = myScrName + " failed";
        myMessageHandler.handle(new Message(MessageKind.ERROR, msg + ". Invalid script."));
        displayInfo(msg);
        this.myResult = new IResult.FAILURE(null);
        break;
      }

      if (InternalFlag.isInternalMode()) {
        myMessageHandler.handle(new Message(MessageKind.INFORMATION, "Modules cluster " + (idx[0] + 1) + "/" + clsize + " [" + IterableUtils.join(Sequence.fromIterable(cl).select(new ISelector<IResource, String>() {
          public String select(IResource r) {
            return ((IResource) r).describe();
          }
        }), ", ") + "]"));
      }

      pi.setText2((idx[0] + 1) + "/" + clsize + " " + IterableUtils.join(Sequence.fromIterable(cl).select(new ISelector<IResource, String>() {
        public String select(IResource r) {
          return ((IResource) r).describe();
        }
      }), ","));
      this.myResult = scr.execute(this.myController, cl);
      if (!(this.myResult.isSucessful()) || pi.isCanceled()) {
        break;
      }
      idx[0]++;
    }
    pi.popState();
    this.myState.set(MakeTask.TaskState.INDETERMINATE);
  }

  private void reconcile() {
    this.myState.set(MakeTask.TaskState.DONE);
    try {
      if (this.myResult == null) {
        this.myState.set(MakeTask.TaskState.CANCELLED);
        String msg = this.myScrName + " aborted";
        displayInfo(msg);
      } else if (!(this.myResult.isSucessful())) {
        String msg = this.myScrName + " failed";
        myMessageHandler.handle(new Message(MessageKind.ERROR, msg + ". See previous messages for details."));
        displayInfo(msg);
      } else {
        String msg = this.myScrName + " successful";
        displayInfo(msg);
      }

    } finally {
      myLatch.countDown();
      done();
    }
  }

  private static   enum TaskState {
    NOT_STARTED(),
    RUNNING(),
    DONE(),
    CANCELLED(),
    INDETERMINATE();

    TaskState() {
    }
  }
}
