package jetbrains.mps.refactoring.framework;

/*Generated by MPS */

import jetbrains.mps.smodel.NodeMemberAccessModifier;
import jetbrains.mps.logging.Logger;
import java.util.Map;
import jetbrains.mps.util.Pair;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Collection;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.refactoring.StructureModificationData;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.util.NameUtil;
import java.util.List;
import jetbrains.mps.smodel.LanguageHierarchyCache;

public class RefactoringNodeMembersAccessModifier implements NodeMemberAccessModifier {
  private static final Logger LOG = Logger.getLogger(RefactoringNodeMembersAccessModifier.class);

  private Map<Pair<String, String>, String> myChildrenRolesMap = new HashMap<Pair<String, String>, String>();
  private Map<Pair<String, String>, String> myReferencesRolesMap = new HashMap<Pair<String, String>, String>();
  private Map<Pair<String, String>, String> myPropertiesNamesMap = new HashMap<Pair<String, String>, String>();
  private Set<Pair<String, String>> myAbsentChildrenRoles = new HashSet<Pair<String, String>>();
  private Set<Pair<String, String>> myAbsentReferentRoles = new HashSet<Pair<String, String>>();
  private Set<Pair<String, String>> myAbsentPropertyNames = new HashSet<Pair<String, String>>();
  private Set<SModel> myModifiableModels = new HashSet<SModel>();
  private Set<String> myOldNames = SetSequence.fromSet(new HashSet<String>());

  public RefactoringNodeMembersAccessModifier() {
  }

  public void addModelsToModify(Collection<SModel> models) {
    LOG.assertCanRead();
    myModifiableModels.addAll(models);
  }

  public void addChildRoleChange(String conceptFQName, String oldRole, String newRole) {
    LOG.assertCanWrite();
    myChildrenRolesMap.put(new Pair<String, String>(conceptFQName, oldRole), newRole);
    SetSequence.fromSet(myOldNames).addElement(oldRole);
  }

  public void addReferentRoleChange(String conceptFQName, String oldRole, String newRole) {
    LOG.assertCanWrite();
    myReferencesRolesMap.put(new Pair<String, String>(conceptFQName, oldRole), newRole);
    SetSequence.fromSet(myOldNames).addElement(oldRole);
  }

  public void addPropertyNameChange(String conceptFQName, String oldName, String newName) {
    LOG.assertCanWrite();
    myPropertiesNamesMap.put(new Pair<String, String>(conceptFQName, oldName), newName);
    SetSequence.fromSet(myOldNames).addElement(oldName);
  }

  private String getNewFeatureRole_internal(@NotNull String conceptFQName, @NotNull String oldRole, StructureModificationData.ConceptFeatureKind conceptFeatureKind) {
    Map<Pair<String, String>, String> featuresMap;
    Set<Pair<String, String>> absentFeatureSet;
    switch (conceptFeatureKind) {
      case CHILD:
        featuresMap = myChildrenRolesMap;
        absentFeatureSet = myAbsentChildrenRoles;
        break;
      case REFERENCE:
        featuresMap = myReferencesRolesMap;
        absentFeatureSet = myAbsentReferentRoles;
        break;
      case PROPERTY:
        featuresMap = myPropertiesNamesMap;
        absentFeatureSet = myAbsentPropertyNames;
        break;
      default:
        return null;
    }
    Pair<String, String> stringPair = new Pair<String, String>(conceptFQName, oldRole);
    if (myAbsentChildrenRoles.contains(stringPair)) {
      return null;
    }
    String role = featuresMap.get(stringPair);
    if (role != null) {
      return role;
    }
    Language language = MPSModuleRepository.getInstance().getLanguage(NameUtil.namespaceFromConceptFQName(conceptFQName));
    if (language == null) {
      return null;
    }
    List<String> parentsNames = LanguageHierarchyCache.getParentsNames(conceptFQName);
    for (String parentFQName : parentsNames) {
      String newChildRole = getNewFeatureRole_internal(parentFQName, oldRole, conceptFeatureKind);
      if (newChildRole != null) {
        featuresMap.put(stringPair, newChildRole);
        return newChildRole;
      }
    }
    absentFeatureSet.add(stringPair);
    return null;
  }

  private boolean isModificationMode(SModel model, String oldName) {
    return myModifiableModels.contains(model) && SetSequence.fromSet(myOldNames).contains(oldName);
  }

  public String getNewChildRole(SModel model, String conceptFQName, String role) {
    if (isModificationMode(model, role)) {
      String newRole = getNewFeatureRole_internal(conceptFQName, role, StructureModificationData.ConceptFeatureKind.CHILD);
      if (newRole != null) {
        return newRole;
      }
    }
    return role;
  }

  public String getNewReferentRole(SModel model, String conceptFQName, String role) {
    if (isModificationMode(model, role)) {
      String newRole = getNewFeatureRole_internal(conceptFQName, role, StructureModificationData.ConceptFeatureKind.REFERENCE);
      if (newRole != null) {
        return newRole;
      }
    }
    return role;
  }

  public String getNewPropertyName(SModel model, String conceptFQName, String propertyName) {
    if (isModificationMode(model, propertyName)) {
      String newName = getNewFeatureRole_internal(conceptFQName, propertyName, StructureModificationData.ConceptFeatureKind.PROPERTY);
      if (newName != null) {
        return newName;
      }
    }
    return propertyName;
  }
}
