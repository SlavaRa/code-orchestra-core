package jetbrains.mps.editor.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import jetbrains.mps.nodeEditor.cells.TextLine;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.smodel.SNode;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import jetbrains.mps.nodeEditor.style.StyleAttributes;
import jetbrains.mps.nodeEditor.style.Padding;
import java.awt.event.KeyEvent;
import jetbrains.mps.nodeEditor.CellSide;
import com.intellij.util.ui.UIUtil;
import com.intellij.openapi.util.Computable;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.nodeEditor.EditorCellAction;
import jetbrains.mps.nodeEditor.CellActionType;
import jetbrains.mps.util.annotation.CodeOrchestraPatch;

public class EditorCell_Empty extends EditorCell_Basic {
  private boolean myCaretVisible = false;
  protected TextLine myTextLine;

  @CodeOrchestraPatch
  public EditorCell_Empty(EditorContext c, SNode node) {
    super(c, node);
    this.myTextLine = new TextLine("", this.getStyle(), false, c); // MMAD-26
    this.myTextLine.setCaretEnabled(true);
  }

  @Override
  public void paintContent(Graphics g, ParentSettings parentSettings) {
    this.myTextLine.setShowCaret(this.myCaretVisible && this.isWithinSelection() && this.getEditor().hasFocus());
    this.myTextLine.paint(g, this.myX + this.myGapLeft, this.myY);
  }

  @Override
  public void switchCaretVisible() {
    this.myCaretVisible = !(this.myCaretVisible);
  }

  @Override
  protected boolean isSelectionPainted() {
    return false;
  }

  @Override
  public int getAscent() {
    return this.myTextLine.getAscent();
  }

  @Override
  public int getDescent() {
    return this.myTextLine.getDescent();
  }

  @Override
  protected void relayoutImpl() {
    if (this.isPunctuationLayout()) {
      this.getStyle().set(StyleAttributes.PADDING_LEFT, new Padding(0.0));
      this.getStyle().set(StyleAttributes.PADDING_RIGHT, new Padding(0.0));
    }
    this.myTextLine.relayout();
    this.myHeight = this.myTextLine.getHeight();
    this.myWidth = this.myTextLine.getWidth();
  }

  @Override
  protected boolean doProcessKeyTyped(KeyEvent p0, boolean p1) {
    final EditorContext editorContext = this.getEditorContext();
    CellSide side = null;
    if (!(UIUtil.isReallyTypedEvent(p0))) {
      return false;
    }
    this.myCaretVisible = true;
    final String symbol = "" + p0.getKeyChar();
    if (this.isFirstCaretPosition()) {
      side = CellSide.LEFT;
    } else if (this.isLastCaretPosition()) {
      side = CellSide.RIGHT;
    }
    final CellSide fside = side;
    return editorContext.executeCommand(new Computable<Boolean>() {
      public Boolean compute() {
        if (fside == CellSide.LEFT) {
          return EditorCell_Empty.this.applyLeftTransform(editorContext, EditorCell_Empty.this, symbol);
        } else if (fside == CellSide.RIGHT) {
          return EditorCell_Empty.this.applyRightTransform(editorContext, EditorCell_Empty.this, symbol);
        } else {
          return true;
        }
      }
    });
  }

  @Override
  public boolean isBigCell() {
    return true;
  }

  private boolean isFirstPositionAllowed() {
    if (this.getStyle().getCurrent(StyleAttributes.FIRST_POSITION_ALLOWED) != null) {
      return this.getStyle().get(StyleAttributes.FIRST_POSITION_ALLOWED);
    }
    return !(this.getStyle().get(StyleAttributes.PUNCTUATION_LEFT));
  }

  private boolean isLastPositionAllowed() {
    if (this.getStyle().getCurrent(StyleAttributes.LAST_POSITION_ALLOWED) != null) {
      return this.getStyle().get(StyleAttributes.LAST_POSITION_ALLOWED);
    }
    return !(this.getStyle().get(StyleAttributes.PUNCTUATION_RIGHT));
  }

  private boolean applyLeftTransform(EditorContext editorContext, EditorCell cellForNewNode, String text) {
    EditorCellAction ltAction = cellForNewNode.getApplicableCellAction(CellActionType.LEFT_TRANSFORM);
    ltAction.execute(editorContext);
    cellForNewNode.getSTHintCell().changeText(text, null);
    cellForNewNode.getSTHintCell().end();
    return true;
  }

  private boolean applyRightTransform(EditorContext editorContext, EditorCell cellForNewNode, String text) {
    EditorCellAction ltAction = cellForNewNode.getApplicableCellAction(CellActionType.RIGHT_TRANSFORM);
    ltAction.execute(editorContext);
    cellForNewNode.getSTHintCell().changeText(text, null);
    cellForNewNode.getSTHintCell().end();
    return true;
  }

  @Override
  public boolean isLastCaretPosition() {
    return this.isLastPositionAllowed() && !(this.isFirstPositionAllowed());
  }

  @Override
  public boolean isFirstCaretPosition() {
    return this.isFirstPositionAllowed() && !(this.isLastPositionAllowed());
  }
}
