package jetbrains.mps.internal.collections.runtime.impl;

/*Generated by MPS */

import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISequence;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.ArrayList;

public class ComparingSequence<U> extends Sequence<U> implements Iterable<U> {
  private final ISequence<U> left;
  private final ISequence<U> right;
  private final ComparingSequence.Kind kind;

  public ComparingSequence(ISequence<U> left, ISequence<U> right, ComparingSequence.Kind kind) {
    if (left == null || right == null) {
      throw new NullPointerException();
    }
    this.left = left;
    this.right = right;
    this.kind = kind;
  }

  public Iterator<U> iterator() {
    return new ComparingSequence.ComparingIterator();
  }

  public static   enum Kind {
    UNION(),
    INTERSECTION(),
    SUBSTRACTION(),
    DISJUNCTION();

    Kind() {
    }
  }

  private class ComparingIterator implements Iterator<U> {
    private CardinalityMap<U> cardMap = new CardinalityMap<U>();
    private List<U> cache;
    private Iterator<U> leftIt;
    private Iterator<U> rightIt;
    private U next;
    private HasNextState hasNext = HasNextState.UNKNOWN;

    private ComparingIterator() {
    }

    public boolean hasNext() {
      if (leftIt == null && rightIt == null) {
        init();
      }
      if (hasNext.unknown()) {
        moveToNext();
      }
      return hasNext.hasNext();
    }

    public U next() {
      if (leftIt == null && rightIt == null) {
        init();
      }
      if (hasNext.unknown()) {
        moveToNext();
      }
      if (!((hasNext.hasNext()))) {
        throw new NoSuchElementException();
      }
      return this.clearNext();
    }

    public void remove() {
      throw new UnsupportedOperationException();
    }

    private void init() {
      switch (kind) {
        case SUBSTRACTION:
        case INTERSECTION:
          for (U o : right.toIterable()) {
            cardMap.postInc(o);
          }
          this.leftIt = left.toIterable().iterator();
          break;
        case UNION:
          this.leftIt = left.toIterable().iterator();
          this.rightIt = right.toIterable().iterator();
          break;
        case DISJUNCTION:
          cache = new ArrayList<U>();
          for (U o : right.toIterable()) {
            cardMap.postInc(o);
            cache.add(o);
          }
          this.leftIt = left.toIterable().iterator();
          this.rightIt = cache.iterator();
          break;
        default:
          break;
      }
    }

    private void destroy() {
      cardMap.clear();
      if (cache != null) {
        cache.clear();
      }
    }

    private void moveToNext() {
      this.next = null;
      this.hasNext = HasNextState.AT_END;
loop:
      do {
        switch (kind) {
          case SUBSTRACTION:
            if (leftIt.hasNext()) {
              U tmp = leftIt.next();
              if (cardMap.postDec(tmp) == 0) {
                setNext(tmp);
                break loop;
              }
            } else {
              break loop;
            }
            break;
          case INTERSECTION:
            if (leftIt.hasNext()) {
              U tmp = leftIt.next();
              if (cardMap.postDec(tmp) > 0) {
                setNext(tmp);
                break loop;
              }
            } else {
              break loop;
            }
            break;
          case UNION:
            if (leftIt.hasNext()) {
              U tmp = leftIt.next();
              cardMap.postInc(tmp);
              setNext(tmp);
              break loop;
            }
            if (rightIt.hasNext()) {
              U tmp = rightIt.next();
              if (cardMap.postDec(tmp) == 0) {
                setNext(tmp);
                break loop;
              }
            } else {
              break loop;
            }
            break;
          case DISJUNCTION:
            if (leftIt.hasNext()) {
              U tmp = leftIt.next();
              if (cardMap.postDec(tmp) == 0) {
                setNext(tmp);
                break loop;
              }
            } else
            if (rightIt.hasNext()) {
              U tmp = rightIt.next();
              if (cardMap.postDec(tmp) > 0) {
                setNext(tmp);
                break loop;
              }
            } else {
              break loop;
            }
            break;
          default:
            break;
        }
      } while (true);
      if (!((hasNext.hasNext()))) {
        destroy();
      }
    }

    private U clearNext() {
      U tmp = next;
      this.next = null;
      this.hasNext = HasNextState.UNKNOWN;
      return tmp;
    }

    private void setNext(U tmp) {
      this.next = tmp;
      this.hasNext = HasNextState.HAS_NEXT;
    }
  }
}
