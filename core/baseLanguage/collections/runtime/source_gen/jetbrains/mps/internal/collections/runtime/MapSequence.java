package jetbrains.mps.internal.collections.runtime;

/*Generated by MPS */

import java.util.Map;
import java.io.Serializable;
import java.util.Set;
import java.util.Collection;
import java.util.Iterator;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.impl.NullMapSequence;

public class MapSequence<U, V> extends Sequence<IMapping<U, V>> implements IMapSequence<U, V>, Map<U, V>, Serializable {
  private static final long serialVersionUID = 4362668497945620393L;

  private Map<U, V> map;

  protected MapSequence(Map<U, V> map) {
    this.map = map;
  }

  public void clear() {
    map.clear();
  }

  public boolean containsKey(Object key) {
    return map.containsKey(key);
  }

  public boolean containsValue(Object value) {
    return map.containsValue(value);
  }

  public Set<Map.Entry<U, V>> entrySet() {
    return map.entrySet();
  }

  public boolean equals(Object o) {
    return map.equals(o);
  }

  public V get(Object key) {
    return map.get(key);
  }

  public int hashCode() {
    return map.hashCode();
  }

  public boolean isEmpty() {
    return map.isEmpty();
  }

  public Set<U> keySet() {
    return map.keySet();
  }

  public V put(U key, V value) {
    return map.put(key, value);
  }

  public void putAll(Map<? extends U, ? extends V> m) {
    map.putAll(m);
  }

  public V remove(Object key) {
    return map.remove(key);
  }

  public int size() {
    return map.size();
  }

  public Collection<V> values() {
    return map.values();
  }

  @Override
  public boolean contains(IMapping<U, V> t) {
    V v = map.get(t.key());
    return eq(v, t.value());
  }

  @Override
  public int count() {
    return map.size();
  }

  @Override
  public ISequence<IMapping<U, V>> distinct() {
    return this;
  }

  @Override
  public boolean isNotEmpty() {
    return !((map.isEmpty()));
  }

  public Iterator<IMapping<U, V>> iterator() {
    return new MapSequence.MappingIterator();
  }

  public IMapSequence<U, V> putAll(IMapSequence<? extends U, ? extends V> map) {
    getMap().putAll(map);
    return this;
  }

  public V removeKey(U u) {
    return getMap().remove(u);
  }

  public Map<U, V> toMap() {
    return this;
  }

  @SuppressWarnings(value = "unchecked")
  public ISetSequence<IMapping<U, V>> mappingsSet() {
    return (ISetSequence<IMapping<U, V>>) new MapSequence.MappingsSetSequence();
  }

  protected Map<U, V> getMap() {
    return map;
  }

  private boolean eq(Object a, Object b) {
    return (a == b) || (((a != null) ?
      a.equals(b) :
      false
    ));
  }

  public static <P, Q> MapSequence.MapSequenceInitializer<P, Q> fromKeysArray(P... keys) {
    Map<P, Q> map = new HashMap<P, Q>();
    return new MapSequence.MapSequenceInitializer<P, Q>(new MapSequence<P, Q>(map), keys);
  }

  public static <P, Q> MapSequence.MapSequenceInitializer<P, Q> fromMapAndKeysArray(Map<P, Q> map, P... keys) {
    return new MapSequence.MapSequenceInitializer<P, Q>(new MapSequence<P, Q>(map), keys);
  }

  public static <P, Q> IMapSequence<P, Q> fromArray(IMapping<P, Q>... mappings) {
    Map<P, Q> map = new HashMap<P, Q>();
    for (IMapping<P, Q> mp : mappings) {
      map.put(mp.key(), mp.value());
    }
    return new MapSequence<P, Q>(map);
  }

  @SuppressWarnings(value = "unchecked")
  public static <P, Q> IMapSequence<P, Q> fromIterable(Iterable<IMapping<P, Q>> iterable) {
    if (iterable instanceof IMapSequence) {
      return (IMapSequence<P, Q>) iterable;
    }
    Map<P, Q> map = new HashMap<P, Q>();
    for (IMapping<P, Q> mpng : iterable) {
      map.put(mpng.key(), mpng.value());
    }
    return new MapSequence<P, Q>(map);
  }

  public static <P, Q> IMapSequence<P, Q> fromMap(Map<P, Q> map) {
    if (Sequence.USE_NULL_SEQUENCE) {
      if (map == null) {
        return NullMapSequence.<P,Q>instance();
      }
    }
    if (map instanceof IMapSequence) {
      return (IMapSequence<P, Q>) map;
    }
    return new MapSequence<P, Q>(map);
  }

  public static class MapSequenceInitializer<P, Q> {
    private final P[] keys;
    private final IMapSequence<P, Q> mapSeq;

    protected MapSequenceInitializer(IMapSequence<P, Q> mapSeq, P... keys) {
      this.mapSeq = mapSeq;
      this.keys = keys;
    }

    public IMapSequence<P, Q> withValues(Q... values) {
      for (int i = 0; i < keys.length && i < values.length; i++) {
        mapSeq.put(keys[i], values[i]);
      }
      return mapSeq;
    }
  }

  private class MappingIterator implements Iterator<IMapping<U, V>> {
    private Iterator<Map.Entry<U, V>> entriesIt;

    public MappingIterator() {
      this.entriesIt = entrySet().iterator();
    }

    public boolean hasNext() {
      return entriesIt.hasNext();
    }

    public IMapping<U, V> next() {
      return new MapSequence.EntryMapping<U, V>(entriesIt.next());
    }

    public void remove() {
      entriesIt.remove();
    }
  }

  private static class EntryMapping<F, S> implements IMapping<F, S> {
    private final Map.Entry<F, S> entry;

    public EntryMapping(Map.Entry<F, S> entry) {
      this.entry = entry;
    }

    public F key() {
      return entry.getKey();
    }

    public S value() {
      return entry.getValue();
    }

    public S value(S newValue) {
      return entry.setValue(newValue);
    }

    public Map.Entry<F, S> toEntry() {
      return entry;
    }

    @Override
    public int hashCode() {
      return entry.hashCode();
    }

    @SuppressWarnings(value = "unchecked")
    @Override
    public boolean equals(Object that) {
      if (that == null) {
        return false;
      }
      if (this.getClass() == that.getClass()) {
        return this.entry.equals(((MapSequence.EntryMapping<F, S>) that).entry);
      }
      if (that instanceof IMapping) {
        return eq(key(), ((IMapping) that).key()) && eq(value(), ((IMapping) that).value());
      }
      return false;
    }

    @Override
    public String toString() {
      return key() + "=" + value();
    }

    private boolean eq(Object a, Object b) {
      return (a == b) || (((a != null) ?
        a.equals(b) :
        false
      ));
    }
  }

  @SuppressWarnings(value = "unchecked")
  private class MappingsSetSequence extends Sequence implements ISetSequence, Set {
    private MappingsSetSequence() {
    }

    public Object addElement(Object t) {
      throw new UnsupportedOperationException();
    }

    public ISetSequence addSequence(ISequence seq) {
      throw new UnsupportedOperationException();
    }

    public Object removeElement(Object t) {
      if (map.entrySet().remove(((IMapping<U, V>) t).toEntry())) {
        return t;
      }
      return null;
    }

    public ISetSequence removeSequence(ISequence seq) {
      if (Sequence.USE_NULL_SEQUENCE) {
        if (seq == null) {
          return this;
        }
      }
      for (Object t : seq.toIterable()) {
        map.entrySet().remove(((IMapping<U, V>) t).toEntry());
      }
      return this;
    }

    public boolean contains(Object t) {
      return map.entrySet().contains(((IMapping<U, V>) t).toEntry());
    }

    public Object[] toGenericArray() {
      Object[] result = new Object[size()];
      Iterator<IMapping<U, V>> it = MapSequence.this.iterator();
      for (int i = 0; it.hasNext(); i++) {
        result[i] = it.next();
      }
      return result;
    }

    public Object[] toGenericArray(Class runtimeClass) {
      Object[] arr = (Object[]) ArrayUtils.newArrayInstance(runtimeClass, size());
      return toArray(arr);
    }

    public Set toSet() {
      return this;
    }

    public Iterator iterator() {
      return MapSequence.this.iterator();
    }

    public boolean add(Object o) {
      throw new UnsupportedOperationException();
    }

    public boolean addAll(Collection c) {
      throw new UnsupportedOperationException();
    }

    public void clear() {
      map.entrySet().clear();
    }

    public boolean containsAll(Collection c) {
      for (Iterator it = c.iterator(); it.hasNext();) {
        if (!(map.entrySet().contains((IMapping<U, V>) it.next()))) {
          return false;
        }
      }
      return true;
    }

    public boolean remove(Object o) {
      return map.entrySet().remove((IMapping<U, V>) o);
    }

    public boolean removeAll(Collection c) {
      boolean modified = false;
      for (Iterator it = iterator(); it.hasNext();) {
        if (c.contains(it.next())) {
          it.remove();
          modified = true;
        }
      }
      return modified;
    }

    public boolean retainAll(Collection c) {
      boolean modified = false;
      for (Iterator it = iterator(); it.hasNext();) {
        if (!(c.contains(it.next()))) {
          it.remove();
          modified = true;
        }
      }
      return modified;
    }

    public int size() {
      return map.entrySet().size();
    }

    public Object[] toArray() {
      return toGenericArray();
    }

    public Object[] toArray(Object[] arr) {
      int size = size();
      if (arr.length < size) {
        arr = (Object[]) ArrayUtils.newArrayInstance(arr.getClass().getComponentType(), size);
      }
      Iterator it = iterator();
      for (int i = 0; i < size; i++) {
        arr[i] = it.next();
      }
      if (arr.length > size) {
        arr[size] = null;
      }
      return arr;
    }
  }
}
