package jetbrains.mps.internal.collections.runtime;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.closures.runtime.AdapterClass;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.impl.FilteringSequence;
import jetbrains.mps.internal.collections.runtime.impl.NegateWhereFilter;
import jetbrains.mps.internal.collections.runtime.impl.TranslatingSequence;
import jetbrains.mps.internal.collections.runtime.impl.SelectingSequence;
import jetbrains.mps.internal.collections.runtime.impl.SortingSequence;
import java.util.Comparator;
import jetbrains.mps.internal.collections.runtime.impl.LimitedCardinalitySequence;
import jetbrains.mps.internal.collections.runtime.impl.PagingSequence;
import jetbrains.mps.internal.collections.runtime.impl.ConcatingSequence;
import jetbrains.mps.internal.collections.runtime.impl.NullSequence;
import jetbrains.mps.internal.collections.runtime.impl.ComparingSequence;
import jetbrains.mps.internal.collections.runtime.impl.ReversingSequence;
import jetbrains.mps.internal.collections.runtime.impl.EnumeratorIterator;
import jetbrains.mps.internal.collections.runtime.impl.NullSetSequence;
import jetbrains.mps.internal.collections.runtime.impl.BasicSequence;
import java.util.Arrays;
import java.util.Collections;

public abstract class Sequence<T> implements ISequence<T>, Iterable<T> {
  public static final boolean USE_NULL_SEQUENCE = true;
  public static final boolean IGNORE_NULL_VALUES = false;
  public static final boolean NULL_WHEN_EMPTY = true;
  public static final boolean NULL_ARRAY_IS_SINGLETON = true;
  protected static final Object[] ARRAY_WITH_NULL = new Object[]{null};

  public Sequence() {
  }

  public ISequence<T> where(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter) {
    return new FilteringSequence<T>(this, filter);
  }

  public T findFirst(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter) {
    return where(filter).first();
  }

  public T findLast(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter) {
    return where(filter).last();
  }

  public boolean any(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter) {
    return where(filter).isNotEmpty();
  }

  public boolean all(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter) {
    return where(new NegateWhereFilter<T>(filter)).isEmpty();
  }

  public <U> ISequence<U> translate(@AdapterClass(value = "ITranslator2") _FunctionTypes._return_P1_E0<? extends Iterable<U>, ? super T> translator) {
    return new TranslatingSequence<T, U>(this, translator);
  }

  public <U> ISequence<U> select(@AdapterClass(value = "ISelector") _FunctionTypes._return_P1_E0<? extends U, ? super T> selector) {
    return new SelectingSequence<T, U>(this, selector);
  }

  public ISequence<T> sort(@AdapterClass(value = "ISelector") _FunctionTypes._return_P1_E0<? extends Comparable<?>, ? super T> selector, boolean ascending) {
    return new SortingSequence<T>(this, new SelectComparator<T>(selector), ascending);
  }

  public ISequence<T> alsoSort(@AdapterClass(value = "ISelector") _FunctionTypes._return_P1_E0<? extends Comparable<?>, ? super T> selector, boolean ascending) {
    return sort(selector, ascending);
  }

  public ISequence<T> sort(Comparator<T> comparator, boolean ascending) {
    return new SortingSequence<T>(this, comparator, ascending);
  }

  public ISequence<T> distinct() {
    return new LimitedCardinalitySequence<T>(this, 1);
  }

  public void visitAll(@AdapterClass(value = "IVisitor") _FunctionTypes._void_P1_E0<? super T> visitor) {
    IterableUtils.visitAll(toIterable(), visitor);
  }

  public ISequence<T> take(int length) {
    return new PagingSequence<T>(this, PagingSequence.Page.TAKE, length);
  }

  public ISequence<T> skip(int length) {
    return new PagingSequence<T>(this, PagingSequence.Page.SKIP, length);
  }

  public ISequence<T> cut(int length) {
    return new PagingSequence<T>(this, PagingSequence.Page.CUT, length);
  }

  public ISequence<T> tail(int length) {
    return new PagingSequence<T>(this, PagingSequence.Page.TAIL, length);
  }

  public ISequence<T> page(int skip, int skipplustake) {
    int take = skipplustake - skip;
    return skip(skip).take(take);
  }

  public ISequence<T> concat(ISequence<T> that) {
    if (USE_NULL_SEQUENCE) {
      if (that == null) {
        return this;
      }
    }
    return new ConcatingSequence<T>(this, that);
  }

  public ISequence<T> intersect(ISequence<T> that) {
    if (USE_NULL_SEQUENCE) {
      if (that == null) {
        return NullSequence.instance();
      }
    }
    return new ComparingSequence<T>(this, that, ComparingSequence.Kind.INTERSECTION);
  }

  public ISequence<T> subtract(ISequence<T> that) {
    if (USE_NULL_SEQUENCE) {
      if (that == null) {
        return this;
      }
    }
    return new ComparingSequence<T>(this, that, ComparingSequence.Kind.SUBSTRACTION);
  }

  public ISequence<T> union(ISequence<T> that) {
    if (USE_NULL_SEQUENCE) {
      if (that == null) {
        return this;
      }
    }
    return new ComparingSequence<T>(this, that, ComparingSequence.Kind.UNION);
  }

  public ISequence<T> disjunction(ISequence<T> that) {
    if (USE_NULL_SEQUENCE) {
      if (that == null) {
        return this;
      }
    }
    return new ComparingSequence<T>(this, that, ComparingSequence.Kind.DISJUNCTION);
  }

  public ISequence<T> reverse() {
    return new ReversingSequence(this);
  }

  public boolean contains(T t) {
    return IterableUtils.contains(toIterable(), t);
  }

  public boolean containsSequence(ISequence<T> that) {
    if (USE_NULL_SEQUENCE) {
      if (that == null) {
        return false;
      }
    }
    return that.subtract(this).isEmpty();
  }

  public int indexOf(T t) {
    return IterableUtils.indexOf(toIterable(), t);
  }

  public int count() {
    return IterableUtils.count(toIterable());
  }

  public boolean isEmpty() {
    return IterableUtils.isEmpty(toIterable());
  }

  public boolean isNotEmpty() {
    return IterableUtils.isNotEmpty(toIterable());
  }

  public T first() {
    return IterableUtils.first(toIterable());
  }

  public T last() {
    return IterableUtils.last(toIterable());
  }

  public T reduceLeft(_FunctionTypes._return_P2_E0<? extends T, ? super T, ? super T> comb) {
    return IterableUtils.reduceLeft(this, comb);
  }

  public T reduceRight(_FunctionTypes._return_P2_E0<? extends T, ? super T, ? super T> comb) {
    return IterableUtils.reduceRight(this.reverse(), comb);
  }

  public <S> S foldLeft(S seed, _FunctionTypes._return_P2_E0<? extends S, ? super S, ? super T> comb) {
    return IterableUtils.foldLeft(this, seed, comb);
  }

  public <S> S foldRight(S seed, _FunctionTypes._return_P2_E0<? extends S, ? super T, ? super S> comb) {
    return IterableUtils.foldRight(this.reverse(), seed, comb);
  }

  public Iterable<T> toIterable() {
    return this;
  }

  public IListSequence<T> toListSequence() {
    return ListSequence.fromIterable(toIterable());
  }

  public T[] toGenericArray() {
    return toListSequence().toGenericArray();
  }

  public T[] toGenericArray(Class<T> runtimeClass) {
    return toListSequence().toGenericArray(runtimeClass);
  }

  public IEnumerator<T> enumerator() {
    return EnumeratorIterator.fromIterator(toIterable().iterator());
  }

  @Override
  public String toString() {
    Iterable<T> iterable = toIterable();
    if (iterable == null) {
      return "null";
    }
    StringBuilder sb = new StringBuilder("[");
    String sep = "";
    for (T t : iterable) {
      sb.append(sep).append(String.valueOf(t));
      sep = ", ";
    }
    sb.append("]");
    return sb.toString();
  }

  @SuppressWarnings(value = "unchecked")
  protected static <U> U[] nullSingletonArray() {
    return (U[]) ARRAY_WITH_NULL;
  }

  public static <U> ISequence<U> emptySequence() {
    return NullSetSequence.instance();
  }

  public static <U> ISequence<U> fromArray(U... array) {
    if (USE_NULL_SEQUENCE) {
      if (array == null) {
        return NullSequence.instance();
      }
    }
    return new BasicSequence<U>(Arrays.asList(array));
  }

  public static <U> ISequence<U> fromClosure(@AdapterClass(value = "ISequenceClosure") _FunctionTypes._return_P0_E0<? extends Iterable<U>> cls) {
    return Sequence.fromIterable(cls.invoke());
  }

  public static <U> ISequence<U> fromIterable(Iterable<U> iterable) {
    if (USE_NULL_SEQUENCE) {
      if (iterable == null) {
        return NullSequence.instance();
      }
    }
    if (iterable instanceof ISequence) {
      return (ISequence<U>) iterable;
    }
    return new BasicSequence<U>(iterable);
  }

  public static <U> ISequence<U> singleton(U value) {
    if (IGNORE_NULL_VALUES) {
      if (value == null) {
        return NullSequence.instance();
      }
    }
    return new BasicSequence<U>(Collections.singleton(value));
  }
}
