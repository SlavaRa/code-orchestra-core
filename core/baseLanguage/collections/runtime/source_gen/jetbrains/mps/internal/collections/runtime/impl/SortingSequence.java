package jetbrains.mps.internal.collections.runtime.impl;

/*Generated by MPS */

import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ISequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.SelectComparator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.ListIterator;

public class SortingSequence<U> extends Sequence<U> implements Iterable<U> {
  private final Sequence<U> input;
  private final Comparator<U> comparator;

  public SortingSequence(Sequence<U> input, Comparator<U> comparator, boolean ascending) {
    if (input == null || comparator == null) {
      throw new NullPointerException();
    }
    this.input = input;
    this.comparator = (ascending ?
      comparator :
      new SortingSequence.InversedComparator<U>(comparator)
    );
  }

  public SortingSequence(Sequence<U> input, Comparator<U> comparator) {
    if (input == null || comparator == null) {
      throw new NullPointerException();
    }
    this.input = input;
    this.comparator = comparator;
  }

  public Iterator<U> iterator() {
    List<U> sortedInput = inputSortedWithSelector();
    return new SortingSequence.UnmodifiableIterator<U>(sortedInput.listIterator());
  }

  @Override
  public ISequence<U> alsoSort(_FunctionTypes._return_P1_E0<? extends Comparable<?>, ? super U> selector, boolean ascending) {
    SelectComparator<U> selectComparator = new SelectComparator<U>(selector);
    return new SortingSequence<U>(input, new SortingSequence.CompoundComparator<U>(comparator, (ascending ?
      selectComparator :
      new SortingSequence.InversedComparator<U>(selectComparator)
    )));
  }

  @SuppressWarnings(value = "unchecked")
  private List<U> inputSortedWithSelector() {
    ArrayList<U> cache = new ArrayList<U>();
    for (U u : input) {
      cache.add(u);
    }
    U[] array = (U[]) cache.toArray();
    Arrays.sort(array, comparator);
    return Arrays.asList(array);
  }

  private static class UnmodifiableIterator<U> implements Iterator<U> {
    private final ListIterator<U> source;

    public UnmodifiableIterator(ListIterator<U> source) {
      this.source = source;
    }

    public boolean hasNext() {
      return source.hasNext();
    }

    public U next() {
      return source.next();
    }

    public void remove() {
      throw new UnsupportedOperationException();
    }
  }

  private static class InversedComparator<T> implements Comparator<T> {
    private final Comparator<T> primary;

    public InversedComparator(Comparator<T> primary) {
      this.primary = primary;
    }

    public int compare(T a, T b) {
      return -primary.compare(a, b);
    }
  }

  private static class CompoundComparator<T> implements Comparator<T> {
    private final Comparator<T> secondary;
    private final Comparator<T> primary;

    public CompoundComparator(Comparator<T> primary, Comparator<T> secondary) {
      this.primary = primary;
      this.secondary = secondary;
    }

    public int compare(T a, T b) {
      int c = primary.compare(a, b);
      return (c == 0 ?
        secondary.compare(a, b) :
        c
      );
    }
  }
}
