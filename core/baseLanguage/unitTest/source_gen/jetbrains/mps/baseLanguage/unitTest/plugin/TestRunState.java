package jetbrains.mps.baseLanguage.unitTest.plugin;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.util.Key;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.unitTest.runtime.TestEvent;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class TestRunState {
  private static final Object lock = new Object();

  private final List<String> myTestMethods = ListSequence.fromList(new ArrayList<String>());
  private Map<ITestNodeWrapper, List<ITestNodeWrapper>> myTestToMethodsMap = MapSequence.fromMap(new LinkedHashMap<ITestNodeWrapper, List<ITestNodeWrapper>>(16, (float) 0.75, false));
  private final Set<TestView> myViewsList = SetSequence.fromSet(new HashSet<TestView>());
  private final List<TestStateListener> myListeners = ListSequence.fromList(new ArrayList<TestStateListener>());
  private String myCurrentClass;
  private String myCurrentMethod;
  private String myCurrentToken;
  private String myLostTest;
  private String myLostMethod;
  private int myTotalTests = 0;
  private int myCompletedTests = 0;
  private int myDefectTests = 0;
  private boolean myIsTerminated;
  private String myAvailableText = null;
  private Key myKey = null;

  public TestRunState(Iterable<ITestNodeWrapper> testCases, Iterable<ITestNodeWrapper> testMethods, StatisticsTableModel statisticsModel) {
    this.initTestState(testCases, testMethods);
  }

  public TestRunState(List<ITestNodeWrapper> tests) {
    this.initTestState(ListSequence.fromList(tests).where(new IWhereFilter<ITestNodeWrapper>() {
      public boolean accept(ITestNodeWrapper it) {
        return it.isTestCase();
      }
    }), ListSequence.fromList(tests).where(new IWhereFilter<ITestNodeWrapper>() {
      public boolean accept(ITestNodeWrapper it) {
        return !(it.isTestCase());
      }
    }));
  }

  private void initTestState(final Iterable<ITestNodeWrapper> testCases, final Iterable<ITestNodeWrapper> testMethods) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        TestRunState.this.addTestCases(testCases);
        TestRunState.this.addTestMethods(testMethods);
        for (ITestNodeWrapper testCase : MapSequence.fromMap(TestRunState.this.myTestToMethodsMap).keySet()) {
          for (ITestNodeWrapper testMethod : MapSequence.fromMap(TestRunState.this.myTestToMethodsMap).get(testCase)) {
            ListSequence.fromList(TestRunState.this.myTestMethods).addElement(testCase.getFqName() + '.' + testMethod.getName());
          }
        }
      }
    });
    this.myTotalTests = ListSequence.fromList(this.myTestMethods).count();

    this.initView();
  }

  private void addTestCases(Iterable<ITestNodeWrapper> testCases) {
    for (ITestNodeWrapper testCase : Sequence.fromIterable(testCases)) {
      List<ITestNodeWrapper> testMethods = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
      MapSequence.fromMap(this.myTestToMethodsMap).put(testCase, testMethods);
      ListSequence.fromList(testMethods).addSequence(Sequence.fromIterable(testCase.getTestMethods()));
    }
  }

  private void addTestMethods(Iterable<ITestNodeWrapper> testMethods) {
    for (ITestNodeWrapper testMethod : Sequence.fromIterable(testMethods)) {
      ITestNodeWrapper testCase = testMethod.getTestCase();
      List<ITestNodeWrapper> curTestMethods = MapSequence.fromMap(this.myTestToMethodsMap).get(testCase);
      if (curTestMethods == null) {
        curTestMethods = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
        MapSequence.fromMap(this.myTestToMethodsMap).put(testCase, curTestMethods);
      }
      if (!(ListSequence.fromList(curTestMethods).contains(testMethod))) {
        ListSequence.fromList(curTestMethods).addElement(testMethod);
      }
    }
  }

  private void updateView() {
    for (TestView view : this.myViewsList) {
      view.update();
    }
  }

  private void initView() {
    for (TestView view : this.myViewsList) {
      view.init();
    }
  }

  public void addView(TestView testView) {
    SetSequence.fromSet(this.myViewsList).addElement(testView);
  }

  public void startTest(final TestEvent event) {
    ListSequence.fromList(this.myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestStart(event);
      }
    });
    this.startTest(event.getTestCaseName(), event.getTestMethodName());
  }

  public void endTest(final TestEvent event) {
    ListSequence.fromList(this.myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestEnd(event);
      }
    });
    this.endTest();
  }

  public void testError(final TestEvent event) {
    ListSequence.fromList(this.myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestError(event);
      }
    });
    this.defectTest();
  }

  public void testFailure(final TestEvent event) {
    ListSequence.fromList(this.myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestFailure(event);
      }
    });
    this.defectTest();
  }

  public void looseTest(final String className, final String testName) {
    ListSequence.fromList(this.myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onLooseTest(className, testName);
      }
    });
    this.looseTestInternal(className, testName);
  }

  private void startTest(String className, String methodName) {
    if (className.equals(this.myCurrentClass) && methodName.equals(this.myCurrentMethod)) {
      return;
    }
    synchronized (lock) {
      this.myCurrentClass = className;
      this.myCurrentMethod = methodName;
      this.updateView();
    }
  }

  private void endTest() {
    synchronized (lock) {
      this.myCompletedTests++;
      this.updateView();
      this.myCurrentClass = null;
      this.myCurrentMethod = null;
    }
  }

  private void defectTest() {
    synchronized (lock) {
      this.myDefectTests++;
      this.updateView();
    }
  }

  private void looseTestInternal(String test, String method) {
    synchronized (lock) {
      this.myLostTest = test;
      this.myLostMethod = method;
      this.myDefectTests++;
      this.myCompletedTests++;
      this.updateView();
      this.myLostTest = null;
      this.myLostMethod = null;
    }
  }

  public void terminate() {
    synchronized (lock) {
      this.myIsTerminated = true;
      this.updateView();
    }
  }

  public void outputText(String text, Key key) {
    synchronized (lock) {
      this.myAvailableText = text;
      this.myKey = key;
      this.updateView();
      this.myAvailableText = null;
      this.myKey = null;
    }
  }

  public void completeTestEvent(TestEvent event) {
    String token = event.getToken();
    if (token.equals(TestEvent.END_TEST_PREFIX) || token.equals(TestEvent.ERROR_TEST_SUFFIX) || token.equals(TestEvent.FAILURE_TEST_SUFFIX)) {
      String testClassName = event.getTestCaseName();
      String testMethodName = event.getTestMethodName();
      String key = testClassName + '.' + testMethodName;
      synchronized (this.myTestMethods) {
        if (ListSequence.fromList(this.myTestMethods).contains(key)) {
          ListSequence.fromList(this.myTestMethods).removeElement(key);
        }
      }
    }
  }

  public List<String> getUnusedMethods() {
    return this.myTestMethods;
  }

  public int getTotalTests() {
    return this.myTotalTests;
  }

  public int getDefectTests() {
    return this.myDefectTests;
  }

  public int getCompletedTests() {
    return this.myCompletedTests;
  }

  public String getCurrentClass() {
    return this.myCurrentClass;
  }

  public String getCurrentMethod() {
    return this.myCurrentMethod;
  }

  public void setToken(String token) {
    this.myCurrentToken = token;
  }

  public String getToken() {
    return this.myCurrentToken;
  }

  public String getLoseMethod() {
    return this.myLostMethod;
  }

  public String getLoseClass() {
    return this.myLostTest;
  }

  public boolean isTerminated() {
    return this.myIsTerminated;
  }

  public String getAvailableText() {
    return this.myAvailableText;
  }

  public Key getKey() {
    return this.myKey;
  }

  public void addListener(TestStateListener listener) {
    ListSequence.fromList(this.myListeners).addElement(listener);
  }

  public void removeListener(TestStateListener listener) {
    ListSequence.fromList(this.myListeners).removeElement(listener);
  }

  public Map<ITestNodeWrapper, List<ITestNodeWrapper>> getTestsMap() {
    return this.myTestToMethodsMap;
  }
}
