package jetbrains.mps.baseLanguage.unitTest.plugin;

/*Generated by MPS */

import javax.swing.table.TableModel;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import javax.swing.event.TableModelListener;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.baseLanguage.unitTest.runtime.TestEvent;
import org.jetbrains.annotations.Nullable;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import com.intellij.openapi.application.ApplicationManager;
import javax.swing.event.TableModelEvent;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class StatisticsTableModel implements TableModel {
  private static final List<String> TEST_COLUMNS = ListSequence.fromListAndArray(new ArrayList<String>(), "Test", "Time elapsed", "Usage Delta", "Usage Before", "Usage After", "Results");

  private final List<TableModelListener> myListeners = ListSequence.fromList(new ArrayList<TableModelListener>());
  private List<TestStatisticsRow> myRows;
  private List<TestStatisticsRow> myFilteredRows = ListSequence.fromList(new ArrayList<TestStatisticsRow>());
  protected String myFilterTestCase = null;
  protected String myFilterTestMethod = null;
  private final TestNameMap<TestCaseRow, TestMethodRow> myMap = new TestNameMap<TestCaseRow, TestMethodRow>();
  private final TestRunState myState;

  public StatisticsTableModel(final TestRunState state) {
    this.myState = state;
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        StatisticsTableModel.this.setTests(state.getTestsMap());
      }
    });
    this.myState.addListener(new TestStateListener() {
      public void onTestStart(TestEvent event) {
        TestMethodRow row = this.findRowForEvent(event);
        if (row != null) {
          row.setStartTime(event.getTime());
          row.setUsageBefore(event.getMemoryUsage());
          fireTableChanged();
        }
      }

      @Nullable
      private TestMethodRow findRowForEvent(TestEvent event) {
        return StatisticsTableModel.this.getRow(event.getTestCaseName(), event.getTestMethodName());
      }

      public void onTestEnd(TestEvent event) {
        TestMethodRow row = this.findRowForEvent(event);
        if (row != null) {
          row.setFinishTime(event.getTime());
          row.setUsageAfter(event.getMemoryUsage());
          if (row.getFailed() == 0 && row.getErrored() == 0) {
            row.setSucceed();
          }
          fireTableChanged();
        }
      }

      public void onTestError(TestEvent event) {
        TestMethodRow row = this.findRowForEvent(event);
        if (row != null) {
          row.setErrored();
          fireTableChanged();
        }
      }

      public void onTestFailure(TestEvent event) {
        TestMethodRow row = this.findRowForEvent(event);
        if (row != null) {
          row.setFailed();
          fireTableChanged();
        }
      }

      public void onLooseTest(String className, String methodName) {
        TestMethodRow row = StatisticsTableModel.this.getRow(className, methodName);
        if (row != null) {
          row.setErrored();
          fireTableChanged();
        }
      }
    });
  }

  private void setTests(Map<ITestNodeWrapper, List<ITestNodeWrapper>> tests) {
    this.myRows = ListSequence.fromList(new ArrayList<TestStatisticsRow>());
    TotalRow totalRow = new TotalRow();
    ListSequence.fromList(this.myRows).addElement(totalRow);
    this.myMap.clear();
    for (ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(tests).keySet())) {
      TestCaseRow testCaseRow = new TestCaseRow(testCase);
      totalRow.addRow(testCaseRow);
      ListSequence.fromList(this.myRows).addElement(testCaseRow);
      this.myMap.put(testCase, testCaseRow);
      for (ITestNodeWrapper testMethod : ListSequence.fromList(MapSequence.fromMap(tests).get(testCase))) {
        TestMethodRow testMethodRow = new TestMethodRow(testMethod);
        testCaseRow.addRow(testMethodRow);
        ListSequence.fromList(this.myRows).addElement(testMethodRow);
        this.myMap.put(testCase, testMethod, testMethodRow);
      }
    }
    this.filter();
  }

  public TestMethodRow getRow(String testCase, String testMethod) {
    return this.myMap.get(testCase, testMethod);
  }

  private void fireTableChanged() {
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        for (TableModelListener listener : ListSequence.fromList(StatisticsTableModel.this.myListeners)) {
          listener.tableChanged(new TableModelEvent(StatisticsTableModel.this));
        }
      }
    });
  }

  public int getRowCount() {
    return ListSequence.fromList(this.myFilteredRows).count();
  }

  public Object getValueAt(int rowIndex, int columnIndex) {
    return ListSequence.fromList(this.myFilteredRows).getElement(rowIndex);
  }

  public void setFilter(String testCase, String testMethod) {
    this.myFilterTestCase = testCase;
    this.myFilterTestMethod = testMethod;
    this.filter();
  }

  private void filter() {
    this.myFilteredRows = ListSequence.fromList(this.myRows).where(new IWhereFilter<TestStatisticsRow>() {
      public boolean accept(TestStatisticsRow it) {
        return it.matches(StatisticsTableModel.this.myFilterTestCase, StatisticsTableModel.this.myFilterTestMethod);
      }
    }).toListSequence();
    fireTableChanged();
  }

  public int getColumnCount() {
    return ListSequence.fromList(TEST_COLUMNS).count();
  }

  public String getColumnName(int columnIndex) {
    return ListSequence.fromList(TEST_COLUMNS).getElement(columnIndex);
  }

  public Class<?> getColumnClass(int columnIndex) {
    return TestStatisticsRow.class;
  }

  public boolean isCellEditable(int rowIndex, int columnIndex) {
    return false;
  }

  public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
  }

  public void addTableModelListener(TableModelListener listener) {
    ListSequence.fromList(this.myListeners).addElement(listener);
  }

  public void removeTableModelListener(TableModelListener listener) {
    ListSequence.fromList(this.myListeners).removeElement(listener);
  }
}
