package jetbrains.mps.baseLanguage.closures.generator.baseLanguage.template.helper;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Map;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.dataFlow.framework.Program;
import jetbrains.mps.lang.dataFlow.DataFlowManager;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.lang.dataFlow.framework.instructions.ReadInstruction;
import jetbrains.mps.lang.dataFlow.framework.instructions.WriteInstruction;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Iterator;

public class WrappersUtils {
  public static List<SNode> collectVariableDeclarationsToWrap2(SNode closure) {
    List<SNode> resVdecls = ListSequence.fromList(new ArrayList<SNode>());
    SNode wrpPrgNode = SNodeOperations.getAncestorWhereConceptInList(closure, new String[]{"jetbrains.mps.baseLanguage.structure.StatementList", "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"}, false, false);
    if ((wrpPrgNode != null)) {
      Map<SNode, Integer> clsMap = collectVariableUsages(SLinkOperations.getTarget(closure, "body", true));
      for (IMapping<SNode, Integer> m : SetSequence.fromSet(MapSequence.fromMap(clsMap).mappingsSet())) {
        ListSequence.fromList(resVdecls).addElement(SNodeOperations.cast(m.key(), "jetbrains.mps.baseLanguage.structure.VariableDeclaration"));
      }
      if (MapSequence.fromMap(clsMap).isNotEmpty()) {
        Map<SNode, Integer> wrpMap = collectVariableUsages(wrpPrgNode);
        for (IMapping<SNode, Integer> m : SetSequence.fromSet(MapSequence.fromMap(clsMap).mappingsSet())) {
          if (m.value() == 0) {
            if (!(MapSequence.fromMap(wrpMap).containsKey(m.key())) || MapSequence.fromMap(wrpMap).get(m.key()) <= 1) {
              ListSequence.fromList(resVdecls).removeElement(SNodeOperations.cast(m.key(), "jetbrains.mps.baseLanguage.structure.VariableDeclaration"));
            }
          }
        }
      }
    }
    return resVdecls;
  }

  public static Map<SNode, Integer> collectVariableUsages(SNode start) {
    Map<SNode, Integer> resMap = MapSequence.fromMap(new HashMap<SNode, Integer>());
    Program prg = DataFlowManager.getInstance().buildProgramFor(start);
    for (Instruction ins : prg.getInstructions()) {
      if (ins instanceof ReadInstruction) {
        ReadInstruction ri = ((ReadInstruction) ins);
        SNode var = (SNode) ri.getVariable();
        if (!(MapSequence.fromMap(resMap).containsKey(var))) {
          MapSequence.fromMap(resMap).put(var, 0);
        }
      } else if (ins instanceof WriteInstruction) {
        WriteInstruction wi = ((WriteInstruction) ins);
        SNode var = (SNode) wi.getVariable();
        int writes = (MapSequence.fromMap(resMap).containsKey(var) ?
          MapSequence.fromMap(resMap).get(var) :
          0
        );
        writes++;
        MapSequence.fromMap(resMap).put(var, writes);
      }
    }
    return resMap;
  }

  public static List<SNode> collectVariableDeclarationsToWrap(SNode closure) {
    List<SNode> vdecls = ListSequence.fromList(new ArrayList<SNode>());
    for (SNode desc : SNodeOperations.getDescendants(closure, null, false, new String[]{})) {
      if ((SNodeOperations.isInstanceOf(desc, "jetbrains.mps.baseLanguage.structure.LocalVariableReference") || SNodeOperations.isInstanceOf(desc, "jetbrains.mps.baseLanguage.structure.ParameterReference")) && closure == SNodeOperations.getAncestor(desc, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral", false, false)) {
        SNode vd = SLinkOperations.getTarget(SNodeOperations.cast(desc, "jetbrains.mps.baseLanguage.structure.VariableReference"), "variableDeclaration", false);
        if (closure != SNodeOperations.getAncestor(vd, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral", false, false)) {
          if (!(ListSequence.fromList(vdecls).contains(vd)) && !(SPropertyOperations.getBoolean(vd, "isFinal"))) {
            ListSequence.fromList(vdecls).addElement(vd);
          }
        }
      }
    }
with_decls:
    for (Iterator<SNode> it = ListSequence.fromList(vdecls).iterator(); it.hasNext();) {
      SNode vd = it.next();
      SNode sl = SNodeOperations.getAncestorWhereConceptInList(vd, new String[]{"jetbrains.mps.baseLanguage.structure.StatementList", "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"}, false, false);
      for (SNode desc : SNodeOperations.getDescendants(sl, null, false, new String[]{})) {
        if ((SNodeOperations.isInstanceOf(desc, "jetbrains.mps.baseLanguage.structure.LocalVariableReference") || SNodeOperations.isInstanceOf(desc, "jetbrains.mps.baseLanguage.structure.ParameterReference")) && SLinkOperations.getTarget(SNodeOperations.cast(desc, "jetbrains.mps.baseLanguage.structure.VariableReference"), "variableDeclaration", false) == vd) {
          if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(desc), "jetbrains.mps.baseLanguage.structure.BaseAssignmentExpression") && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(desc), "jetbrains.mps.baseLanguage.structure.BaseAssignmentExpression"), "lValue", true) == desc) {
            continue with_decls;
          } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(desc), "jetbrains.mps.baseLanguage.structure.PostfixIncrementExpression") && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(desc), "jetbrains.mps.baseLanguage.structure.PostfixIncrementExpression"), "expression", true) == desc) {
            continue with_decls;
          } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(desc), "jetbrains.mps.baseLanguage.structure.PrefixIncrementExpression") && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(desc), "jetbrains.mps.baseLanguage.structure.PrefixIncrementExpression"), "expression", true) == desc) {
            continue with_decls;
          } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(desc), "jetbrains.mps.baseLanguage.structure.PostfixDecrementExpression") && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(desc), "jetbrains.mps.baseLanguage.structure.PostfixDecrementExpression"), "expression", true) == desc) {
            continue with_decls;
          } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(desc), "jetbrains.mps.baseLanguage.structure.PrefixDecrementExpression") && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(desc), "jetbrains.mps.baseLanguage.structure.PrefixDecrementExpression"), "expression", true) == desc) {
            continue with_decls;
          }
        }
      }
      // didn't find any assignment with the var reference in the lvalue 
      it.remove();
    }
    return vdecls;
  }
}
