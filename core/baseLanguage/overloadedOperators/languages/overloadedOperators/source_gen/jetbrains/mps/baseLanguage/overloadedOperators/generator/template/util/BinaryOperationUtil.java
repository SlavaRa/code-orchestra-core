package jetbrains.mps.baseLanguage.overloadedOperators.generator.template.util;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.util.NameUtil;
import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.IMapping;

public class BinaryOperationUtil {
  public BinaryOperationUtil() {
  }

  public static boolean isOverloading(SNode node, SNode leftType, SNode rightType, SNode operator) {
    if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(leftType, SLinkOperations.getTarget(operator, "leftType", true)) && TypeChecker.getInstance().getSubtypingManager().isSubtype(rightType, SLinkOperations.getTarget(operator, "rightType", true)))) {
      return false;
    }
    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(operator, "operator", true), "jetbrains.mps.baseLanguage.overloadedOperators.structure.BinaryOperationReference")) {
      if (SNodeOperations.isInstanceOf(node, NameUtil.nodeFQName(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(operator, "operator", true), "jetbrains.mps.baseLanguage.overloadedOperators.structure.BinaryOperationReference"), "binaryOperation", false)))) {
        return true;
      }
    } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(operator, "operator", true), "jetbrains.mps.baseLanguage.overloadedOperators.structure.CustomOperator") && SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.overloadedOperators.structure.CustomOperatorUsage")) {
      if (SLinkOperations.getTarget(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.overloadedOperators.structure.CustomOperatorUsage"), "operator", false) == SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(operator, "operator", true), "jetbrains.mps.baseLanguage.overloadedOperators.structure.CustomOperator"), "declaration", false)) {
        return true;
      }
    }
    return false;
  }

  public static Map<SNode, Boolean> getOverloadedOperators(SNode node, SNode leftType, SNode rightType, List<SNode> operators) {
    Map<SNode, Boolean> result = MapSequence.fromMap(new HashMap<SNode, Boolean>());
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return result;
    }
    for (SNode operator : operators) {
      if (isOverloading(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), leftType, rightType, operator)) {
        MapSequence.fromMap(result).put(operator, false);
      }
      if (SPropertyOperations.getBoolean(operator, "commutative") && isOverloading(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), rightType, leftType, operator)) {
        MapSequence.fromMap(result).put(operator, true);
      }
    }
    return result;
  }

  public static boolean hasOverloadedOperators(SNode node, SNode leftType, SNode rightType, List<SNode> operators) {
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return false;
    }
    for (SNode operator : operators) {
      if (isOverloading(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), leftType, rightType, operator)) {
        return true;
      }
      if (SPropertyOperations.getBoolean(operator, "commutative") && isOverloading(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), rightType, leftType, operator)) {
        return true;
      }
    }
    return false;
  }

  public static boolean isSubTypeOperatorStraight(SNode subOperator, SNode superOperator) {
    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(SLinkOperations.getTarget(superOperator, "leftType", true), SLinkOperations.getTarget(subOperator, "leftType", true), false)) {
      return false;
    }
    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(SLinkOperations.getTarget(subOperator, "leftType", true), SLinkOperations.getTarget(superOperator, "leftType", true), false)) {
      return true;
    }
    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(SLinkOperations.getTarget(superOperator, "rightType", true), SLinkOperations.getTarget(subOperator, "rightType", true), false)) {
      return false;
    }
    return true;
  }

  public static boolean isReversedSubTypeOperator(SNode subOperator, SNode superOperator) {
    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(SLinkOperations.getTarget(superOperator, "rightType", true), SLinkOperations.getTarget(subOperator, "leftType", true), false)) {
      return false;
    }
    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(SLinkOperations.getTarget(subOperator, "leftType", true), SLinkOperations.getTarget(superOperator, "rightType", true), false)) {
      return true;
    }
    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(SLinkOperations.getTarget(superOperator, "leftType", true), SLinkOperations.getTarget(subOperator, "rightType", true), false)) {
      return false;
    }
    return true;
  }

  public static boolean isSubTypeOperator(SNode subOperator, SNode superOperator, boolean reversed) {
    if (!(reversed)) {
      return isSubTypeOperatorStraight(subOperator, superOperator);
    }
    return isReversedSubTypeOperator(subOperator, superOperator);
  }

  public static SNode getNearestOverloaded(SNode node, SNode leftType, SNode rightType, List<SNode> operators) {
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return null;
    }
    SNode result = (SNode) (node.getUserObject("operator"));
    if (result != null) {
      return result;
    }
    Map<SNode, Boolean> operatorMap = getOverloadedOperators(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), leftType, rightType, operators);
    if (MapSequence.fromMap(operatorMap).count() == 0) {
      return null;
    }
    result = MapSequence.fromMap(operatorMap).first().key();
    boolean resultReversed = MapSequence.fromMap(operatorMap).first().value();
    for (IMapping<SNode, Boolean> operatorEntry : MapSequence.fromMap(operatorMap)) {
      SNode operator = operatorEntry.key();
      boolean reversed = operatorEntry.value() != resultReversed;
      if (isSubTypeOperator(operator, result, reversed)) {
        result = operator;
        resultReversed = operatorEntry.value();
      }
    }
    node.putUserObject("operator", result);
    node.putUserObject("reversed", resultReversed);
    return result;
  }
}
