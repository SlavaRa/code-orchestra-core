package jetbrains.mps.baseLanguage.plugin;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cells.CellFinders;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptPropertyOperations;

public class ParenthesisUtil {
  public ParenthesisUtil() {
  }

  public static void addClosingParenthesis(@NotNull SNode expression, boolean opening, EditorContext context) {
    SNode newExpr = createParenthesis(expression, opening);
    selectNode(context, newExpr, !(opening));
  }

  public static SNode createParenthesis(@NotNull SNode expression, boolean opening) {
    SNode current = expression;
    SNode prev = expression;
    while (current != null && !(SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      prev = current;
      if (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(current), "jetbrains.mps.baseLanguage.structure.Expression"))) {
        break;
      }
      current = SNodeOperations.cast(SNodeOperations.getParent(current), "jetbrains.mps.baseLanguage.structure.Expression");
    }
    current = prev;
    // searching for binary operation 
    SNode binOp = getBinOp(current, opening);
    // special cases 
    if (binOp == null) {
      SNode parExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
      SNodeOperations.replaceWithAnother(current, parExpr);
      SLinkOperations.setTarget(parExpr, "expression", current, true);
      return parExpr;
    }
    boolean left = opening && SLinkOperations.getTarget(binOp, "leftExpression", true) == current;
    boolean right = !(opening) && SLinkOperations.getTarget(binOp, "rightExpression", true) == current;
    if (left || right) {
      SNode parExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(binOp), "jetbrains.mps.baseLanguage.structure.ParenthesizedExpression")) {
        SNodeOperations.replaceWithAnother(current, parExpr);
        SLinkOperations.setTarget(parExpr, "expression", current, true);
      } else {
        SNodeOperations.replaceWithAnother(binOp, parExpr);
        SLinkOperations.setTarget(parExpr, "expression", binOp, true);
      }
      return parExpr;
    }
    // rotate 
    SNode subtree = (opening ?
      SLinkOperations.getTarget(binOp, "leftExpression", true) :
      SLinkOperations.getTarget(binOp, "rightExpression", true)
    );
    SNode parExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
    SNodeOperations.replaceWithAnother(current, parExpr);
    SNodeOperations.replaceWithAnother(subtree, current);
    SNodeOperations.replaceWithAnother(binOp, subtree);
    SLinkOperations.setTarget(parExpr, "expression", binOp, true);
    return parExpr;
  }

  public static void moveParenthesisToTheRightOrLeft(SNode expr, EditorContext context, boolean toRight) {
    if (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(expr), "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return;
    }
    SNode binOp = getBinOp(expr, toRight);
    if (binOp == null) {
      return;
    }
    SNode sidemost = findRightmostOrLeftmostLeafExpression(SLinkOperations.getTarget(expr, "expression", true), toRight);
    SNode leaf = findRightmostOrLeftmostLeafExpression((toRight ?
      SLinkOperations.getTarget(binOp, "rightExpression", true) :
      SLinkOperations.getTarget(binOp, "leftExpression", true)
    ), !(toRight));
    SNode backsideSubtree = (toRight ?
      SLinkOperations.getTarget(binOp, "leftExpression", true) :
      SLinkOperations.getTarget(binOp, "rightExpression", true)
    );
    SNodeOperations.detachNode(backsideSubtree);
    SNodeOperations.replaceWithAnother(binOp, backsideSubtree);
    SNodeOperations.replaceWithAnother(sidemost, binOp);
    if (toRight) {
      SLinkOperations.setTarget(binOp, "leftExpression", sidemost, true);
    } else {
      SLinkOperations.setTarget(binOp, "rightExpression", sidemost, true);
    }
    SNode sideSubtree = (toRight ?
      SLinkOperations.getTarget(binOp, "rightExpression", true) :
      SLinkOperations.getTarget(binOp, "leftExpression", true)
    );
    SNodeOperations.detachNode(leaf);
    if (toRight) {
      SLinkOperations.setTarget(binOp, "rightExpression", leaf, true);
    } else {
      SLinkOperations.setTarget(binOp, "leftExpression", leaf, true);
    }
    if (sideSubtree != leaf) {
      SNode leafParentOperation = SNodeOperations.cast(sideSubtree, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
      SNode exprParent = SNodeOperations.getParent(expr);
      SNodeOperations.replaceWithAnother(expr, sideSubtree);
      if (toRight) {
        SLinkOperations.setTarget(leafParentOperation, "leftExpression", expr, true);
      } else {
        SLinkOperations.setTarget(leafParentOperation, "rightExpression", expr, true);
      }
      if (SNodeOperations.isInstanceOf(exprParent, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
        checkOperationWRTPriority(SNodeOperations.cast(exprParent, "jetbrains.mps.baseLanguage.structure.BinaryOperation"));
      }
    }
    SNode binOpCheck = (SNodeOperations.isInstanceOf(SNodeOperations.getParent(binOp), "jetbrains.mps.baseLanguage.structure.BinaryOperation") ?
      SNodeOperations.cast(SNodeOperations.getParent(binOp), "jetbrains.mps.baseLanguage.structure.BinaryOperation") :
      binOp
    );
    checkOperationWRTPriority(binOpCheck);
    selectNode(context, expr, toRight);
  }

  public static void moveParenthesisToTheLeftOrRightInside(SNode expr, EditorContext context, boolean toRight) {
    if (!(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(expr, "expression", true), "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return;
    }
    SNode sidemost = findRightmostOrLeftmostLeafExpression(SLinkOperations.getTarget(expr, "expression", true), !(toRight));
    SNode binOp = SNodeOperations.cast(SNodeOperations.getParent(sidemost), "jetbrains.mps.baseLanguage.structure.BinaryOperation");
    SNode sideExpr = (toRight ?
      SLinkOperations.getTarget(binOp, "rightExpression", true) :
      SLinkOperations.getTarget(binOp, "leftExpression", true)
    );
    SNodeOperations.detachNode(sideExpr);
    SNodeOperations.replaceWithAnother(binOp, sideExpr);
    SNodeOperations.replaceWithAnother(expr, binOp);
    if (toRight) {
      SLinkOperations.setTarget(binOp, "rightExpression", expr, true);
    } else {
      SLinkOperations.setTarget(binOp, "leftExpression", expr, true);
    }
    checkOperationWRTPriority(binOp);
    selectNode(context, expr, false);
  }

  public static void checkOperationWRTPriority(SNode binOp) {
    checkOperationChildWRTPriority(binOp, false);
    checkOperationChildWRTPriority(binOp, true);
    checkOpeartionParentWRTPriority(binOp);
  }

  private static void checkOperationChildWRTPriority(SNode node, boolean isRight) {
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return;
    }
    SNode binOp = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
    SNode sideExpr = (isRight ?
      SLinkOperations.getTarget(binOp, "rightExpression", true) :
      SLinkOperations.getTarget(binOp, "leftExpression", true)
    );
    if (SNodeOperations.isInstanceOf(sideExpr, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
      SNode sideChild = SNodeOperations.cast(sideExpr, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
      if (isBadPriority(sideChild, binOp, isRight)) {
        ParenthesisUtil.rotateTree(sideChild, binOp, isRight);
        checkOperationWRTPriority(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"));
      }
    }
  }

  private static void checkOpeartionParentWRTPriority(SNode node) {
    if (SNodeOperations.getParent(node) == null) {
      return;
    }
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
      SNode parent = SNodeOperations.cast(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.BinaryOperation");
      boolean isRight = false;
      if (SLinkOperations.getTarget(parent, "rightExpression", true) == node) {
        isRight = true;
      } else if (SLinkOperations.getTarget(parent, "leftExpression", true) == node) {
        isRight = false;
      }
      if (ParenthesisUtil.isBadPriority(node, parent, isRight)) {
        ParenthesisUtil.rotateTree(node, parent, isRight);
        checkOpeartionParentWRTPriority(node);
      }
    }
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.AbstractUnaryNumberOperation")) {
      SNode parent = SNodeOperations.cast(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.AbstractUnaryNumberOperation");
      SLinkOperations.setTarget(parent, "expression", SLinkOperations.getTarget(node, "leftExpression", true), true);
      SNodeOperations.replaceWithAnother(parent, node);
      SLinkOperations.setTarget(node, "leftExpression", parent, true);
    }
  }

  private static SNode findRightmostOrLeftmostLeafExpression(SNode root, boolean rightmost) {
    if (!(SNodeOperations.isInstanceOf(root, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return root;
    }
    SNode binOp = SNodeOperations.cast(root, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
    return findRightmostOrLeftmostLeafExpression((rightmost ?
      SLinkOperations.getTarget(binOp, "rightExpression", true) :
      SLinkOperations.getTarget(binOp, "leftExpression", true)
    ), rightmost);
  }

  private static SNode getBinOp(SNode expr, boolean toRight) {
    SNode parent = SNodeOperations.getParent(expr);
    if (!(SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return null;
    }
    SNode parentOp = SNodeOperations.cast(parent, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
    boolean right = toRight && SLinkOperations.getTarget(parentOp, "leftExpression", true) == expr;
    boolean left = !(toRight) && SLinkOperations.getTarget(parentOp, "rightExpression", true) == expr;
    if (right || left) {
      return parentOp;
    }
    return getBinOp(parentOp, toRight);
  }

  private static void selectNode(EditorContext context, SNode expr, boolean selectLastLeaf) {
    context.flushEvents();
    EditorComponent component = context.getNodeEditorComponent();
    EditorCell nodeCell = component.findNodeCell(expr);
    EditorCell cell = nodeCell.findChild((selectLastLeaf ?
      CellFinders.LAST_SELECTABLE_LEAF :
      CellFinders.FIRST_SELECTABLE_LEAF
    ));
    if (cell != null) {
      component.changeSelection(cell);
    }
  }

  public static void rotateTree(SNode child, SNode op, boolean isRight) {
    SNode backsideExpr = (isRight ?
      SLinkOperations.getTarget(child, "leftExpression", true) :
      SLinkOperations.getTarget(child, "rightExpression", true)
    );
    SNodeOperations.detachNode(child);
    SNodeOperations.replaceWithAnother(op, child);
    SNodeOperations.replaceWithAnother(backsideExpr, op);
    if (isRight) {
      SLinkOperations.setTarget(op, "rightExpression", backsideExpr, true);
    } else {
      SLinkOperations.setTarget(op, "leftExpression", backsideExpr, true);
    }
  }

  public static boolean isBadPriority(SNode child, SNode parent, boolean isRight) {
    return SConceptPropertyOperations.getInteger(child, "priority") < SConceptPropertyOperations.getInteger(parent, "priority") || (isRight && SConceptPropertyOperations.getInteger(child, "priority") == SConceptPropertyOperations.getInteger(parent, "priority"));
  }
}
