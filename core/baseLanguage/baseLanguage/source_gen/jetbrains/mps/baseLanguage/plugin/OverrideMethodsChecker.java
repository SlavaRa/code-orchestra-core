package jetbrains.mps.baseLanguage.plugin;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.EditorCheckerAdapter;
import java.util.Set;
import jetbrains.mps.nodeEditor.EditorMessage;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.index.ClassifierSuccessorsFinder;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.project.IndexNotReadyException;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Iterator;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.behavior.BaseMethodDeclaration_Behavior;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.event.SModelFileChangedEvent;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.lang.core.behavior.BaseConcept_Behavior;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;

public class OverrideMethodsChecker extends EditorCheckerAdapter {
  private static final int MAX_MESSAGE_NUMBER = 5;
  private static final String LF = "\n";
  private static final String TOOLTIP_INDENT = LF + "    ";

  private boolean myIndexWasNotReady;

  public OverrideMethodsChecker() {
  }

  public Set<EditorMessage> createMessages(SNode rootNode, List<SModelEvent> events, boolean wasCheckedOnce, EditorContext editorContext) {
    Iterable<SNode> classifiers = ListSequence.fromList(SNodeOperations.getDescendants(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.ClassConcept") || SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.Interface");
      }
    });
    this.myIndexWasNotReady = !(ClassifierSuccessorsFinder.isIndexReady(editorContext.getOperationContext().getProject()));
    if (Sequence.fromIterable(classifiers).isEmpty() || this.myIndexWasNotReady) {
      return Collections.<EditorMessage>emptySet();
    }
    Set<EditorMessage> result = SetSequence.fromSet(new HashSet<EditorMessage>());
    for (SNode containedClassifier : Sequence.fromIterable(classifiers)) {
      // each classifier here is instance of ClassConcept or Interface 
      try {
        collectOverridenMethods(containedClassifier, result);
      } catch (IndexNotReadyException indexNotReady) {
        // Catching IndexNotReadyException for now. In general suggestion of IDEA developers was to start using 
        // DaemonCodeAnalyzer for background highlighting processes execution 
        myIndexWasNotReady = true;
      }
      collectOverridingMethods(containedClassifier, result);
    }
    return result;
  }

  private void collectOverridingMethods(SNode container, Set<EditorMessage> messages) {
    OverridingMethodsFinder finder = new OverridingMethodsFinder(container);
    for (SNode overridingMethod : SetSequence.fromSet(finder.getOverridingMethods())) {
      StringBuffer tooltip = new StringBuffer();
      int messageCounter = 0;
      Set<Tuples._2<SNode, SNode>> overridenMethods = finder.getOverridenMethods(overridingMethod);
      boolean overrides = SPropertyOperations.getBoolean(overridingMethod, "isAbstract") || SetSequence.fromSet(overridenMethods).where(new IWhereFilter<Tuples._2<SNode, SNode>>() {
        public boolean accept(Tuples._2<SNode, SNode> it) {
          return !(SPropertyOperations.getBoolean(it._0(), "isAbstract"));
        }
      }).isNotEmpty();
      for (Iterator<Tuples._2<SNode, SNode>> it = SetSequence.fromSet(overridenMethods).iterator(); it.hasNext();) {
        SNode overridenClassifier = it.next()._1();
        tooltip.append((overrides ?
          "Overrides" :
          "Implements"
        ));
        tooltip.append(" method in '");
        tooltip.append(getClassifierPresentation(overridenClassifier));
        tooltip.append("'");
        if (it.hasNext()) {
          tooltip.append(LF);
          if (++messageCounter == MAX_MESSAGE_NUMBER) {
            tooltip.append("...");
            break;
          }
        }
      }
      SetSequence.fromSet(messages).addElement(new OverridingMethodEditorMessage(overridingMethod, this, tooltip.toString(), overrides));
    }
  }

  private void collectOverridenMethods(SNode container, Set<EditorMessage> messages) {
    List<SNode> derivedClassifiers = ClassifierSuccessorsFinder.getDerivedClassifiers(container, GlobalScope.getInstance());
    if (ListSequence.fromList(derivedClassifiers).isEmpty()) {
      return;
    }
    boolean isInterface = SNodeOperations.isInstanceOf(container, "jetbrains.mps.baseLanguage.structure.Interface");
    StringBuffer superClassifierTooltip = new StringBuffer();
    if (ListSequence.fromList(derivedClassifiers).count() > MAX_MESSAGE_NUMBER) {
      superClassifierTooltip.append((isInterface ?
        "Has implementations" :
        "Has subclasses"
      ));
    } else {
      superClassifierTooltip.append((isInterface ?
        "Is implemented by" :
        "Is subclassed by"
      ));
      for (SNode subClassifier : ListSequence.fromList(derivedClassifiers)) {
        superClassifierTooltip.append(TOOLTIP_INDENT);
        superClassifierTooltip.append(getClassifierPresentation(subClassifier));
        if (SNodeOperations.isInstanceOf(subClassifier, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
          for (SNode enumConstant : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(subClassifier, "jetbrains.mps.baseLanguage.structure.EnumClass"), "enumConstant", true))) {
            superClassifierTooltip.append(TOOLTIP_INDENT);
            superClassifierTooltip.append(getEnumConstantPresentation(enumConstant));
          }
        }
      }
    }
    SetSequence.fromSet(messages).addElement(new SubclassedClassifierEditorMessage(container, this, superClassifierTooltip.toString(), isInterface));

    Map<String, Set<SNode>> nameToMethodsMap = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
    for (SNode method : ListSequence.fromList(SLinkOperations.getTargets(container, "method", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return OverridingMethodsFinder.canBeOverriden(it);
      }
    })) {
      SetSequence.fromSet(OverridingMethodsFinder.safeGet(nameToMethodsMap, SPropertyOperations.getString(method, "name"))).addElement(method);
    }
    if (MapSequence.fromMap(nameToMethodsMap).isEmpty()) {
      return;
    }
    Map<SNode, Set<SNode>> overridenToOverridingMethodsMap = createOverridenToOverridingMethodsMap(nameToMethodsMap, derivedClassifiers);
    for (SNode overridenMethod : SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).keySet())) {
      if (SPropertyOperations.getBoolean(overridenMethod, "isFinal")) {
        continue;
      }
      boolean overriden = !(SPropertyOperations.getBoolean(overridenMethod, "isAbstract"));
      StringBuffer tooltip = new StringBuffer("Is ");
      tooltip.append((overriden ?
        "overriden" :
        "implemented"
      ));
      tooltip.append(" in");
      int messageCounter = 0;
      for (Iterator<SNode> it = SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).get(overridenMethod)).iterator(); it.hasNext();) {
        SNode overridingMethod = it.next();
        tooltip.append(TOOLTIP_INDENT);
        tooltip.append(getPresentation(SNodeOperations.getParent(overridingMethod)));
        if (++messageCounter == MAX_MESSAGE_NUMBER && it.hasNext()) {
          tooltip.append(TOOLTIP_INDENT);
          tooltip.append("...");
          break;
        }
      }
      SetSequence.fromSet(messages).addElement(new OverridenMethodEditorMessage(overridenMethod, this, tooltip.toString(), overriden));
    }
  }

  private Map<SNode, Set<SNode>> createOverridenToOverridingMethodsMap(Map<String, Set<SNode>> nameToMethodsMap, Iterable<SNode> derivedClassifiers) {
    Map<SNode, Set<SNode>> result = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (SNode derivedClassifier : Sequence.fromIterable(derivedClassifiers)) {
      for (final SNode derivedClassifierMethod : Sequence.fromIterable(OverridingMethodsFinder.getInstanceMethods(derivedClassifier)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return OverridingMethodsFinder.canOverride(it);
        }
      })) {
        Set<SNode> similarMethods = MapSequence.fromMap(nameToMethodsMap).get(SPropertyOperations.getString(derivedClassifierMethod, "name"));
        if (similarMethods == null) {
          continue;
        }
        SNode overridenMethod = SetSequence.fromSet(similarMethods).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(it, derivedClassifierMethod);
          }
        });
        if (overridenMethod != null) {
          Set<SNode> overridingMethods = OverridingMethodsFinder.safeGet(result, overridenMethod);
          SetSequence.fromSet(overridingMethods).addElement(derivedClassifierMethod);
          if (SetSequence.fromSet(overridingMethods).count() > MAX_MESSAGE_NUMBER) {
            SetSequence.fromSet(similarMethods).removeElement(overridenMethod);
            if (SetSequence.fromSet(similarMethods).isEmpty()) {
              MapSequence.fromMap(nameToMethodsMap).removeKey(SPropertyOperations.getString(derivedClassifierMethod, "name"));
              if (MapSequence.fromMap(nameToMethodsMap).isEmpty()) {
                return result;
              }
            }
          }
        }
      }
    }
    return result;
  }

  @Override
  public boolean hasDramaticalEvent(List<SModelEvent> events) {
    if (this.myIndexWasNotReady) {
      return true;
    }
    for (SModelEvent event : ListSequence.fromList(events)) {
      if (event instanceof SModelRootEvent || event instanceof SModelFileChangedEvent) {
        return true;
      }
      if (event instanceof SModelChildEvent) {
        SModelChildEvent childEvent = (SModelChildEvent) event;
        SNode child = childEvent.getChild();
        String childRole = childEvent.getChildRole();
        // Class or Interface was added/removed 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.Interface") || SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.ClassConcept") || SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.AnonymousClass") || SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.AnonymousClassCreator")) {
          return true;
        }
        // method was added/removed from containing Classifier 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration") && SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Classifier", "method"), "role").equals(childRole)) {
          return true;
        }
        // one of extendedInterface/superclass/implementedInterface child elements was added/removed 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.ClassifierType") && (SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Interface", "extendedInterface"), "role").equals(childRole) || SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept", "superclass"), "role").equals(childRole) || SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept", "implementedInterface"), "role").equals(childRole))) {
          return true;
        }
        // parameter was added/removed 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration") && SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration", "parameter"), "role").equals(childRole)) {
          return true;
        }
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.Type") && isParameterType(child)) {
          return true;
        }
      }
      if (event instanceof SModelReferenceEvent) {
        SModelReferenceEvent referenceEvent = (SModelReferenceEvent) event;
        SReference reference = referenceEvent.getReference();
        SNode sourceNode = reference.getSourceNode();
        String referenceRole = reference.getRole();
        if (SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassifierType", "classifier"), "role").equals(referenceRole) && SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.ClassifierType") && (SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), "jetbrains.mps.baseLanguage.structure.Classifier"))) {
          return true;
        }
        if (SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.AnonymousClass", "classifier"), "role").equals(referenceRole) && SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
          return true;
        }
        if (SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.Type") && isParameterType(sourceNode)) {
          return true;
        }
      }
      if (event instanceof SModelPropertyEvent) {
        SModelPropertyEvent propertyEvent = (SModelPropertyEvent) event;
        SNode node = propertyEvent.getNode();
        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) {
          return true;
        }
      }
    }
    return false;
  }

  private String getPresentation(SNode node) {
    if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      return getClassifierPresentation(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier"));
    }
    if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration")) {
      return getEnumConstantPresentation(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration"));
    }
    return BaseConcept_Behavior.call_getPresentation_1213877396640(node);
  }

  private String getClassifierPresentation(SNode classifier) {
    return INamedConcept_Behavior.call_getFqName_1213877404258(classifier);
  }

  private String getEnumConstantPresentation(SNode enumConstantDeclaration) {
    return INamedConcept_Behavior.call_getFqName_1213877404258(enumConstantDeclaration);
  }

  private static boolean isParameterType(SNode type) {
    SNode parent = SNodeOperations.getParent(type);
    if (SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration")) {
      return true;
    }
    if (SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.Type")) {
      return isParameterType(parent);
    }
    return false;
  }
}
