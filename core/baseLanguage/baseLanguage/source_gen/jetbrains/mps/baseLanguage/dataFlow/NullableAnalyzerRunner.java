package jetbrains.mps.baseLanguage.dataFlow;

/*Generated by MPS */

import jetbrains.mps.analyzers.runtime.framework.CustomAnalyzerRunner;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.dataFlow.MPSProgramBuilder;
import jetbrains.mps.lang.dataFlow.DataFlowManager;
import jetbrains.mps.lang.dataFlow.framework.DataFlowAnalyzer;
import jetbrains.mps.lang.dataFlow.framework.Program;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.lang.dataFlow.framework.ProgramState;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.analyzers.runtime.framework.GeneratedInstruction;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.dataFlow.framework.instructions.WriteInstruction;
import jetbrains.mps.lang.dataFlow.framework.AnalysisDirection;

public class NullableAnalyzerRunner extends CustomAnalyzerRunner<Map<SNode, NullableState>> {
  private SNode myNode;

  public NullableAnalyzerRunner(SNode node) {
    super(null, null);
    myNode = node;
    myProgram = new MPSProgramBuilder(DataFlowManager.getInstance()).buildProgram(myNode);
    prepareProgram();
    myAnalyzer = new NullableAnalyzerRunner.NullableAnalyzer();
  }

  private void prepareProgram() {
    NullableAnalyzerRules.getInstance().apply(myNode, myProgram);
  }

  public static class NullableAnalyzer implements DataFlowAnalyzer<Map<SNode, NullableState>> {
    public NullableAnalyzer() {
    }

    public Map<SNode, NullableState> initial(Program program) {
      Map<SNode, NullableState> result = new HashMap<SNode, NullableState>();
      return result;
    }

    public Map<SNode, NullableState> merge(Program program, List<Map<SNode, NullableState>> input) {
      Map<SNode, NullableState> result = new HashMap<SNode, NullableState>();
      for (Map<SNode, NullableState> inputElement : input) {
        for (Map.Entry<SNode, NullableState> entry : inputElement.entrySet()) {
          SNode expr = entry.getKey();
          NullableState value = entry.getValue();
          NullableState resValue = result.get(expr);
          if (resValue == null) {
            resValue = NullableState.NOT_INIT;
          }
          result.put(expr, resValue.merge(value));
        }
      }
      return result;
    }

    public Map<SNode, NullableState> fun(Map<SNode, NullableState> input, ProgramState state) {
      Map<SNode, NullableState> result = input;
      Instruction instruction = state.getInstruction();
      NullableState nullableState = NullableState.UNKNOWN;
      if (instruction instanceof GeneratedInstruction) {
        SNode node = (SNode) (((GeneratedInstruction) instruction).getParameter());
        if (instruction instanceof notNullInstruction) {
          nullableState = NullableState.NOTNULL;
        }
        if (instruction instanceof nullableInstruction) {
          nullableState = NullableState.NULLABLE;
        }
        if (instruction instanceof nullInstruction) {
          nullableState = NullableState.NULL;
        }
        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.VariableReference")) {
          node = SLinkOperations.getTarget(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.VariableReference"), "variableDeclaration", false);
        }
        if (node != null) {
          result.put((SNode) node, nullableState);
        }
      }
      if (instruction instanceof WriteInstruction) {
        WriteInstruction write = (WriteInstruction) instruction;
        SNode value = (SNode) write.getValue();
        if (SNodeOperations.isInstanceOf(value, "jetbrains.mps.baseLanguage.structure.VariableReference")) {
          value = SLinkOperations.getTarget(SNodeOperations.cast(value, "jetbrains.mps.baseLanguage.structure.VariableReference"), "variableDeclaration", false);
        }
        NullableState valueState = result.get(value);
        if (valueState == null) {
          valueState = NullableState.UNKNOWN;
        }
        result.put((SNode) write.getVariable(), valueState);
      }
      return result;
    }

    public AnalysisDirection getDirection() {
      return AnalysisDirection.FORWARD;
    }
  }
}
