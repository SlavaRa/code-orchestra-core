package jetbrains.mps.baseLanguage.util.plugin.refactorings;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class BasicMoveRefactoring {
  protected final SNode myMoving;
  protected final SNode myDestination;
  protected SNode myReplacing = null;
  protected SearchResults<SNode> myUsages = new SearchResults<SNode>();
  private boolean myIsChangingModel = false;

  public BasicMoveRefactoring(SNode moving, SNode destination) {
    this.myMoving = moving;
    this.myDestination = destination;
  }

  public void setUssages(SearchResults<SNode> usages) {
    this.myUsages = usages;
  }

  public SearchResults<SNode> getUsages() {
    return this.myUsages;
  }

  public void doRefactoring() {
    this.setIsChangingModel();
    this.correctMoving();
    this.createCopy();
    MoveRefactoringUtils.fixImportsFromNode(this.myReplacing);
    for (SearchResult<SNode> result : ListSequence.fromList(this.myUsages.getSearchResults())) {
      this.replaceSingleUsage(result.getObject());
    }
    this.deleteOld();
  }

  public void replaceSingleUsage(SNode usage) {
    if (this.myIsChangingModel) {
      MoveRefactoringUtils.addNodeModelImportIfNeed(usage, this.myDestination);
    }
  }

  protected void createCopy() {
    this.myReplacing = SNodeOperations.copyNode(this.myMoving);
    MoveRefactoringUtils.addNodeAtLink(this.myDestination, this.myReplacing);
  }

  protected void deleteOld() {
    SNodeOperations.detachNode(this.myMoving);
  }

  protected void correctMoving() {
  }

  private void setIsChangingModel() {
    this.myIsChangingModel = (SNodeOperations.getModel(this.myDestination) != SNodeOperations.getModel(this.myMoving));
  }
}
