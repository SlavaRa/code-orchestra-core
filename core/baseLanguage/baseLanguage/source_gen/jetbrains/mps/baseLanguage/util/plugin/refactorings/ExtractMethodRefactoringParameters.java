package jetbrains.mps.baseLanguage.util.plugin.refactorings;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.search.ClassifierAndSuperClassifiersScope;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Iterator;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.pattern.util.MatchingUtil;

public class ExtractMethodRefactoringParameters extends MethodModel {
  private ExtractMethodRefactoringAnalyzer myAnalyzer;
  private List<SNode> myNodesToRefactor;
  private VisibilityLevel myVisibility = VisibilityLevel.PRIVATE;
  private List<MethodParameter> myParameters = ListSequence.fromList(new ArrayList<MethodParameter>());

  public ExtractMethodRefactoringParameters(List<SNode> nodes) {
    this.myNodesToRefactor = nodes;
    this.myAnalyzer = new ExtractMethodRefactoringAnalyzer(nodes);
    for (MethodParameter inputVariable : ListSequence.fromList(this.myAnalyzer.getInputVariables())) {
      ListSequence.fromList(this.myParameters).addElement(inputVariable);
    }
  }

  public List<SNode> getNodesToRefactor() {
    return this.myNodesToRefactor;
  }

  public SNode getContainerMethod() {
    return this.myAnalyzer.getExtractMethodReafactoringProcessor().getContainerMethod();
  }

  public VisibilityLevel getVisibilityLevel() {
    return this.myVisibility;
  }

  public void setVisibilityLevel(VisibilityLevel level) {
    this.myVisibility = level;
  }

  public List<MethodParameter> getParameters() {
    return this.myParameters;
  }

  public List<String> getParametersNames() {
    List<String> result = ListSequence.fromList(new ArrayList<String>());
    for (MethodParameter param : ListSequence.fromList(this.myParameters)) {
      ListSequence.fromList(result).addElement(param.getTypeName() + " " + param.getName());
    }
    return result;
  }

  public SNode getOverridingMethodClass() {
    String name = this.getName();
    SNode classifier = this.myAnalyzer.getClassifier();
    if (classifier != null) {
      ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope(classifier);
      List<SNode> methods = scope.getMethodsByName(name);
      for (SNode method : methods) {
        boolean good = this.isParametersMatch(method);
        if (good) {
          return SNodeOperations.getAncestor(method, "jetbrains.mps.baseLanguage.structure.Classifier", false, false);
        }
      }
    }
    return null;
  }

  public ExtractMethodRefactoringAnalyzer getAnalyzer() {
    return this.myAnalyzer;
  }

  private boolean isParametersMatch(SNode method) {
    Iterator<SNode> parameters = ListSequence.fromList(SLinkOperations.getTargets(method, "parameter", true)).iterator();
    for (MethodParameter p1 : this.myParameters) {
      if (p1.isSelected()) {
        if (!(parameters.hasNext())) {
          return false;
        }
        SNode p2 = parameters.next();
        if (!(MatchingUtil.matchNodes(p1.getType(), SLinkOperations.getTarget(p2, "type", true)))) {
          return false;
        }
      }
    }
    if (parameters.hasNext()) {
      return false;
    }
    return true;
  }
}
