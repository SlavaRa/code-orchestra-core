package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.IScope;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import org.jetbrains.annotations.NotNull;
import java.util.HashMap;
import jetbrains.mps.smodel.search.ISearchScope;
import jetbrains.mps.smodel.search.ModelAndImportedModelsScope;
import java.util.ArrayList;
import jetbrains.mps.util.Condition;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class AllSubclassifiersScope extends AbstractClassifiersScope {
  private final SModel model;
  private final IScope scope;
  private Map<SNode, Boolean> visitedClassifiersMap = null;
  private final SNode rootClassifier;
  private List<SNode> foundClassifiers;

  public AllSubclassifiersScope(SNode classifier, SModel model, int constraint, IScope scope) {
    super(constraint);
    this.rootClassifier = classifier;
    this.model = model;
    this.scope = scope;
  }

  @Override
  @NotNull
  public List<SNode> getClassifiers() {
    this.init();
    return this.foundClassifiers;
  }

  @SuppressWarnings(value = {"unchecked"})
  private void init() {
    if (this.foundClassifiers == null) {
      this.visitedClassifiersMap = new HashMap<SNode, Boolean>();
      this.visitedClassifiersMap.put(this.rootClassifier, true);
      ISearchScope searchScope = new ModelAndImportedModelsScope(this.model, false, this.scope);
      this.foundClassifiers = new ArrayList<SNode>(searchScope.getNodes(new Condition<SNode>() {
        public boolean met(SNode node) {
          return SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Classifier") && AllSubclassifiersScope.this.checkSubclassifier(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier"));
        }
      }));
      this.visitedClassifiersMap.clear();
    }
  }

  private boolean checkSubclassifier(SNode cls) {
    if (this.visitedClassifiersMap.containsKey(cls)) {
      return this.visitedClassifiersMap.get(cls);
    }
    boolean result = false;
    if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      SNode extendedClass = BaseLanguageUtil.getSuperclass(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
      if (extendedClass != null && this.checkSubclassifier(extendedClass)) {
        result = true;
      }
      if (!(result)) {
        for (SNode iface : ListSequence.fromList(SLinkOperations.getTargets((SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "implementedInterface", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SLinkOperations.getTarget(it, "classifier", false) != null);
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, "classifier", false);
          }
        })) {
          if (this.checkSubclassifier(iface)) {
            result = true;
            break;
          }
        }
      }
    } else
    if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface")) {
      for (SNode iface : ListSequence.fromList(SLinkOperations.getTargets((SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.Interface")), "extendedInterface", true)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return (SLinkOperations.getTarget(it, "classifier", false) != null);
        }
      }).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return SLinkOperations.getTarget(it, "classifier", false);
        }
      })) {
        if (this.checkSubclassifier(iface)) {
          result = true;
          break;
        }
      }
    }
    this.visitedClassifiersMap.put(cls, result);
    return result;
  }
}
