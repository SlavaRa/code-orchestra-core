package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import jetbrains.mps.smodel.search.IReferenceInfoResolver;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.Map;

/*package*/ class InstanceMethodReferenceInfoResolver implements IReferenceInfoResolver {
  private SNode myInstanceType;
  private List<SNode> myActualArguments;
  private ClassifierAndSuperClassifiersScope mySearchScope;

  public InstanceMethodReferenceInfoResolver(ClassifierAndSuperClassifiersScope searchScope, SNode instanceType, List<SNode> actualArguments) {
    this.myInstanceType = instanceType;
    this.myActualArguments = actualArguments;
    this.mySearchScope = searchScope;
  }

  public SNode resolve(String referenceInfo, SModelReference targetModelReference) {
    if (referenceInfo == null) {
      return null;
    }
    List<SNode> methods = this.mySearchScope.getMethodsByName(referenceInfo);
    if (methods.isEmpty()) {
      return null;
    }
    if (methods.size() == 1) {
      return ListSequence.fromList(methods).first();
    }
    methods = MethodResolveUtil.selectByParmCount(methods, this.myActualArguments);
    if (methods.size() == 1) {
      return ListSequence.fromList(methods).first();
    }
    SNode classifier = SLinkOperations.getTarget(this.myInstanceType, "classifier", false);
    List<SNode> typeParameters = SLinkOperations.getTargets(this.myInstanceType, "parameter", true);
    Map<SNode, SNode> typeByTypeVar = MethodResolveUtil.getTypesByTypeVars(classifier, typeParameters);
    return MethodResolveUtil.chooseByParameterType(methods, this.myActualArguments, typeByTypeVar);
  }
}
