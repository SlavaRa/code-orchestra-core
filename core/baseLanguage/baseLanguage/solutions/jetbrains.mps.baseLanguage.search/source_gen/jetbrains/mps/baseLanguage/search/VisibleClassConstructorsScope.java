package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.IScope;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.search.IReferenceInfoResolver;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;

public class VisibleClassConstructorsScope extends VisibleClassifiersScope {
  @Deprecated
  public VisibleClassConstructorsScope(SModel model, IScope scope) {
    super(model, IClassifiersSearchScope.CONSTRUCTOR, scope);
  }

  public VisibleClassConstructorsScope(@NotNull SNode contextNode, IScope scope) {
    super(contextNode, IClassifiersSearchScope.CONSTRUCTOR, scope);
  }

  @NotNull
  public List<SNode> getClassifiers() {
    List<SNode> list = super.getClassifiers();
    List<SNode> result = new ArrayList<SNode>();
    for (SNode classifier : list) {
      if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.Interface")) {
        continue;
      }
      if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept") && SPropertyOperations.getBoolean((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "abstractClass")) {
        continue;
      }
      result.add(classifier);
    }
    return result;
  }

  public IReferenceInfoResolver getReferenceInfoResolver(SNode referenceNode, SNode targetConcept) {
    if (SModelUtil.isAssignableConcept(NameUtil.nodeFQName(targetConcept), "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration")) {
      if (SNodeOperations.isInstanceOf(referenceNode, "jetbrains.mps.baseLanguage.structure.ClassCreator")) {
        SNode classCreator = SNodeOperations.cast(referenceNode, "jetbrains.mps.baseLanguage.structure.ClassCreator");
        return new VisibleClassConstructorsScope.ConstructorDeclarationReferenceInfoResolver(SLinkOperations.getTargets(classCreator, "actualArgument", true), SLinkOperations.getTargets(classCreator, "typeParameter", true), getModel(), getScope());
      }
    }
    return super.getReferenceInfoResolver(referenceNode, targetConcept);
  }

  private static class ConstructorDeclarationReferenceInfoResolver extends ReachableClassifiersScope.ClassifierReferenceInfoResolver {
    private List<SNode> myActualArgs;
    private List<SNode> myTypeParms;

    /*package*/ ConstructorDeclarationReferenceInfoResolver(List<SNode> actualArgs, List<SNode> typeParms, SModel model, IScope scope) {
      super(model, scope);
      myActualArgs = actualArgs;
      myTypeParms = typeParms;
    }

    public SNode resolve(String referenceInfo, @Nullable SModelReference targetModelReference) {
      SNode classifier_ = super.resolve(referenceInfo, targetModelReference);
      if (classifier_ == null) {
        return null;
      }
      SNode classifier = SNodeOperations.cast(classifier_, "jetbrains.mps.baseLanguage.structure.Classifier");
      if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        List<SNode> constructors = SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "constructor", true);
        if (constructors.size() == 1) {
          return ListSequence.fromList(constructors).first();
        } else
        if (constructors.size() > 1) {
          constructors = (List<SNode>) MethodResolveUtil.selectByParmCount(constructors, myActualArgs);
          if (constructors.size() == 1) {
            return ListSequence.fromList(constructors).first();
          } else {
            Iterator<SNode> typeParms = (Iterator<SNode>) myTypeParms.iterator();
            Iterator<SNode> typeVars = (Iterator<SNode>) SLinkOperations.getTargets(classifier, "typeVariableDeclaration", true).iterator();
            Map<SNode, SNode> typeByTypeVar = new HashMap<SNode, SNode>();
            while (typeParms.hasNext() && typeVars.hasNext()) {
              typeByTypeVar.put(typeVars.next(), typeParms.next());
            }
            return MethodResolveUtil.chooseByParameterType(constructors, myActualArgs, typeByTypeVar);
          }
        }
      }
      return null;
    }
  }
}
