package jetbrains.mps.baseLanguage.index;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import com.intellij.openapi.project.DumbService;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.IScope;
import java.util.Set;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import com.intellij.util.indexing.FileBasedIndex;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.intellij.psi.search.GlobalSearchScope;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.module.Module;

public class ClassifierSuccessorsFinder {
  public ClassifierSuccessorsFinder() {
  }

  public static boolean isIndexReady(Project project) {
    return !(DumbService.getInstance(project).isDumb());
  }

  public static List<SNode> getDerivedClassifiers(SNode classifier, IScope scope) {
    Set<VirtualFile> unModifiedModelFiles = SetSequence.fromSet(new HashSet<VirtualFile>());
    List<SNode> modifiedClasses = ListSequence.fromList(new ArrayList<SNode>());
    List<SNode> modifiedInterfaces = ListSequence.fromList(new ArrayList<SNode>());
    for (SModelDescriptor md : scope.getModelDescriptors()) {
      if (!((md instanceof EditableSModelDescriptor))) {
        continue;
      }
      EditableSModelDescriptor emd = (EditableSModelDescriptor) md;
      IFile modelFile = emd.getModelFile();
      if (modelFile == null) {
        continue;
      }
      if (emd.isChanged()) {
        SModel sModel = md.getSModel();
        for (SNode sNode : ListSequence.fromList(SModelOperations.getNodes(sModel, null))) {
          if (SNodeOperations.isInstanceOf(sNode, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
            ListSequence.fromList(modifiedClasses).addElement(SNodeOperations.cast(sNode, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
          } else if (SNodeOperations.isInstanceOf(sNode, "jetbrains.mps.baseLanguage.structure.Interface")) {
            ListSequence.fromList(modifiedInterfaces).addElement(SNodeOperations.cast(sNode, "jetbrains.mps.baseLanguage.structure.Interface"));
          }
        }
      } else {
        SetSequence.fromSet(unModifiedModelFiles).addElement(VirtualFileUtils.getVirtualFile(modelFile));
      }
    }
    List<SNode> result = new ArrayList<SNode>();
    Queue<SNode> queue = QueueSequence.fromQueue(new LinkedList<SNode>());
    QueueSequence.fromQueue(queue).addLastElement(classifier);
    ClassifierSuccessorsFinder.ValueProcessor valueProcessor = new ClassifierSuccessorsFinder.ValueProcessor(result, queue);
    ClassifierSuccessorsFinder.ModifiedsuccessorFinder modifiedSuccessorFinder = new ClassifierSuccessorsFinder.ModifiedsuccessorFinder(modifiedClasses, modifiedInterfaces, result, queue);
    ClassifierSuccessorsFinder.SearchScope unModifiedFilesSearchScope = new ClassifierSuccessorsFinder.SearchScope(unModifiedModelFiles);
    while (!(QueueSequence.fromQueue(queue).isEmpty())) {
      SNode nextClassifier = QueueSequence.fromQueue(queue).removeFirstElement();
      FileBasedIndex.getInstance().processValues(ClassifierSuccessorsIndexer.NAME, new GlobalSNodeId(nextClassifier), null, valueProcessor, unModifiedFilesSearchScope);
      modifiedSuccessorFinder.process(nextClassifier);
    }
    return result;
  }

  private static class ModifiedsuccessorFinder {
    private List<SNode> myModifiedClasses;
    private List<SNode> myModifiedInterfaces;
    private Queue<SNode> myClassifiersQueue;
    private List<SNode> myResult;
    private Set<SNode> myProcessedNodes = SetSequence.fromSet(new HashSet<SNode>());
    private Map<SNode, List<SNode>> mySuccessorsMap = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());
    private boolean myInterfacesMapped;
    private boolean myClassesMapped;

    /*package*/ ModifiedsuccessorFinder(List<SNode> modifiedClasses, List<SNode> modifiedInterfaces, List<SNode> result, Queue<SNode> classifiersQueue) {
      myModifiedClasses = modifiedClasses;
      myModifiedInterfaces = modifiedInterfaces;
      myClassifiersQueue = classifiersQueue;
      myResult = result;
    }

    public void process(SNode superClassifier) {
      if (SetSequence.fromSet(myProcessedNodes).contains(superClassifier)) {
        return;
      }
      SetSequence.fromSet(myProcessedNodes).addElement(superClassifier);
      if (SNodeOperations.isInstanceOf(superClassifier, "jetbrains.mps.baseLanguage.structure.Interface")) {
        mapInterfaces();
        mapClasses();
      } else if (SNodeOperations.isInstanceOf(superClassifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        mapClasses();
      } else {
        return;
      }
      List<SNode> successors = MapSequence.fromMap(mySuccessorsMap).get(superClassifier);
      if (successors != null) {
        for (SNode successor : ListSequence.fromList(successors)) {
          ListSequence.fromList(myResult).addElement(successor);
          QueueSequence.fromQueue(myClassifiersQueue).addLastElement(successor);
        }
      }
    }

    private void mapClasses() {
      if (myClassesMapped) {
        return;
      }
      myClassesMapped = true;
      for (SNode aClass : ListSequence.fromList(myModifiedClasses)) {
        SNode superClass = SLinkOperations.getTarget(aClass, "superclass", true);
        if (superClass != null) {
          safeMap(SLinkOperations.getTarget(superClass, "classifier", false), aClass);
        }
        if (SNodeOperations.isInstanceOf(aClass, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
          safeMap(SLinkOperations.getTarget(SNodeOperations.cast(aClass, "jetbrains.mps.baseLanguage.structure.AnonymousClass"), "classifier", false), aClass);
        }
        for (SNode implementedInterface : ListSequence.fromList(SLinkOperations.getTargets(aClass, "implementedInterface", true))) {
          safeMap(SLinkOperations.getTarget(implementedInterface, "classifier", false), aClass);
        }
      }
    }

    private void mapInterfaces() {
      if (myInterfacesMapped) {
        return;
      }
      myInterfacesMapped = true;
      for (SNode anInterface : ListSequence.fromList(myModifiedInterfaces)) {
        for (SNode extendedInterface : ListSequence.fromList(SLinkOperations.getTargets(anInterface, "extendedInterface", true))) {
          safeMap(SLinkOperations.getTarget(extendedInterface, "classifier", false), anInterface);
        }
      }
    }

    private void safeMap(SNode predecessor, SNode successor) {
      if (predecessor == null) {
        return;
      }
      List<SNode> successors = MapSequence.fromMap(mySuccessorsMap).get(predecessor);
      if (successors == null) {
        successors = new ArrayList<SNode>();
        MapSequence.fromMap(mySuccessorsMap).put(predecessor, successors);
      }
      ListSequence.fromList(successors).addElement(successor);
    }
  }

  private static class ValueProcessor implements FileBasedIndex.ValueProcessor<List<GlobalSNodeId>> {
    private List<SNode> myResult;
    private Queue<SNode> myQueue;
    private Set<GlobalSNodeId> myProcessedNodes = SetSequence.fromSet(new HashSet<GlobalSNodeId>());

    /*package*/ ValueProcessor(List<SNode> result, Queue<SNode> queue) {
      myResult = result;
      myQueue = queue;
    }

    @Override
    public boolean process(VirtualFile file, List<GlobalSNodeId> successors) {
      for (GlobalSNodeId sNodeId : successors) {
        if (SetSequence.fromSet(myProcessedNodes).contains(sNodeId)) {
          continue;
        }
        SetSequence.fromSet(myProcessedNodes).addElement(sNodeId);
        SNode node = sNodeId.getNode();
        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Classifier")) {
          SNode classifier = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier");
          ListSequence.fromList(myResult).addElement(classifier);
          QueueSequence.fromQueue(myQueue).addLastElement(classifier);
        }
      }
      return true;
    }
  }

  private static class SearchScope extends GlobalSearchScope {
    private Set<VirtualFile> myFilesInScope;

    /*package*/ SearchScope(Set<VirtualFile> notModifiedModelFiles) {
      super(null);
      myFilesInScope = notModifiedModelFiles;
    }

    @Override
    public boolean contains(VirtualFile file) {
      return SetSequence.fromSet(myFilesInScope).contains(file);
    }

    @Override
    public int compare(VirtualFile file1, VirtualFile file2) {
      return file1.getPath().compareTo(file2.getPath());
    }

    @Override
    public boolean isSearchInModuleContent(@NotNull Module aModule) {
      return true;
    }

    @Override
    public boolean isSearchInLibraries() {
      return false;
    }
  }
}
