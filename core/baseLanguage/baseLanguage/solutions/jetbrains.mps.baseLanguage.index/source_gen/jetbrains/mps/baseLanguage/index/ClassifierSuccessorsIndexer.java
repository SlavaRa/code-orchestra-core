package jetbrains.mps.baseLanguage.index;

/*Generated by MPS */

import com.intellij.util.indexing.FileBasedIndexExtension;
import java.util.List;
import com.intellij.util.indexing.ID;
import com.intellij.util.indexing.FileBasedIndex;
import com.intellij.util.io.KeyDescriptor;
import com.intellij.util.io.DataExternalizer;
import com.intellij.util.indexing.DataIndexer;
import com.intellij.util.indexing.FileContent;
import com.intellij.openapi.vfs.VirtualFile;
import codeOrchestra.actionscript.index.IODataIndexer;
import codeOrchestra.actionscript.index.IndexIOProcessor;
import codeOrchestra.actionscript.index.IndexIOProcessorException;
import jetbrains.mps.fileTypes.MPSFileTypeFactory;
import jetbrains.mps.util.annotation.CodeOrchestraPatch;
import org.jetbrains.annotations.NotNull;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.workbench.actions.goTo.index.BaseSNodeDescriptorIndex;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.SReference;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

import java.util.ArrayList;

public class ClassifierSuccessorsIndexer extends FileBasedIndexExtension<GlobalSNodeId, List<GlobalSNodeId>> {
  // RE-3949
  @CodeOrchestraPatch
  public static final String INDEX_NAME = "jetbrains.mps.ClassifierSuccessorsIndexer";
  public static final ID<GlobalSNodeId, List<GlobalSNodeId>> NAME = ID.create(INDEX_NAME);

  private FileBasedIndex.InputFilter myInputFilter = new ClassifierSuccessorsIndexer.InputFilter();
  private KeyDescriptor<GlobalSNodeId> myKeyDescriptor = new GlobalSNodeIdDescriptor();
  private DataExternalizer<List<GlobalSNodeId>> myDataExternalizer = new ListExternalizer(myKeyDescriptor);
  private DataIndexer<GlobalSNodeId, List<GlobalSNodeId>, FileContent> myIndexer = new ClassifierSuccessorsIndexer.Indexer();

  public ClassifierSuccessorsIndexer() {
  }

  public ID<GlobalSNodeId, List<GlobalSNodeId>> getName() {
    return NAME;
  }

  public int getVersion() {
    return 3;
  }

  public boolean dependsOnFileContent() {
    return true;
  }

  public FileBasedIndex.InputFilter getInputFilter() {
    return myInputFilter;
  }

  public KeyDescriptor<GlobalSNodeId> getKeyDescriptor() {
    return myKeyDescriptor;
  }

  public DataExternalizer<List<GlobalSNodeId>> getValueExternalizer() {
    return myDataExternalizer;
  }

  public DataIndexer<GlobalSNodeId, List<GlobalSNodeId>, FileContent> getIndexer() {
    return myIndexer;
  }

  private static class InputFilter implements FileBasedIndex.InputFilter {
    private InputFilter() {
    }

    public boolean acceptInput(VirtualFile file) {
      return MPSFileTypeFactory.MODEL_FILE_TYPE.equals(file.getFileType());
    }
  }

  // RE-3949
  @CodeOrchestraPatch
  private static class Indexer extends IODataIndexer<GlobalSNodeId, List<GlobalSNodeId>> {
    private Indexer() {
    }

    @NotNull
    public Map<GlobalSNodeId, List<GlobalSNodeId>> mapInternal(final FileContent inputData) {
      final Map<GlobalSNodeId, List<GlobalSNodeId>> result = MapSequence.fromMap(new HashMap<GlobalSNodeId, List<GlobalSNodeId>>());
      ModelAccess.instance().runIndexing(new Runnable() {
        public void run() {
          SModel sModel = BaseSNodeDescriptorIndex.doModelParsing(inputData);
          for (final SNode nextNode : sModel.nodes()) {
            if (isInstanceOfClassConcept(nextNode)) {
              SNode classNode = (SNode) nextNode;
              if (SLinkOperations.getTarget(classNode, "superclass", true) != null) {
                safeMap(SLinkOperations.getTarget(classNode, "superclass", true), classNode);
              }
              for (SNode implementedInterface : ListSequence.fromList(SLinkOperations.getTargets(classNode, "implementedInterface", true))) {
                safeMap(implementedInterface, classNode);
              }
              if (isInstanceOfAnonymousClassConcept(classNode)) {
                safeMap(classNode.getReference(SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.AnonymousClass", "classifier"), "role")), classNode);
              }
            } else if (isInstanceOfInterfaceConcept(nextNode)) {
              SNode interfaceNode = (SNode) nextNode;
              for (SNode extendedInterface : ListSequence.fromList(SLinkOperations.getTargets(interfaceNode, "extendedInterface", true))) {
                safeMap(extendedInterface, interfaceNode);
              }
            }
          }
        }

        private void safeMap(SNode classifierType, SNode node) {
          safeMap(classifierType.getReference(SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassifierType", "classifier"), "role")), node);
        }

        private void safeMap(SReference reference, SNode node) {
          GlobalSNodeId key = GlobalSNodeId.createSNodeId(reference);
          if (key == null) {
            return;
          }
          List<GlobalSNodeId> successors = MapSequence.fromMap(result).get(key);
          if (successors == null) {
            successors = ListSequence.fromList(new ArrayList<GlobalSNodeId>());
            MapSequence.fromMap(result).put(key, successors);
          }
          ListSequence.fromList(successors).addElement(new GlobalSNodeId(node));
        }

        private boolean isInstanceOfClassConcept(SNode node) {
          String conceptFQName = node.getConceptFqName();
          return "jetbrains.mps.baseLanguage.structure.ClassConcept".equals(conceptFQName) || "jetbrains.mps.baseLanguage.structure.AnonymousClass".equals(conceptFQName) || "jetbrains.mps.baseLanguage.structure.EnumClass".equals(conceptFQName) || "jetbrains.mps.baseLanguageInternal.structure.ExtractStaticInnerClassConcept".equals(conceptFQName) || "jetbrains.mps.baseLanguage.unitTest.structure.BTestCase".equals(conceptFQName);
        }

        private boolean isInstanceOfAnonymousClassConcept(SNode node) {
          return "jetbrains.mps.baseLanguage.structure.AnonymousClass".equals(node.getConceptFqName());
        }

        private boolean isInstanceOfInterfaceConcept(SNode node) {
          String conceptFQName = node.getConceptFqName();
          return "jetbrains.mps.baseLanguage.structure.Interface".equals(conceptFQName) || "jetbrains.mps.baseLanguage.structure.Annotation".equals(conceptFQName);
        }
      });
      return result;
    }

    @Override
    protected IndexIOProcessor<GlobalSNodeId, List<GlobalSNodeId>> getIndexIOProcessor() {
      // TODO: This class duplicates same class in ASClassifierSuccessorsIndexer except GlobalSNodeId type
      return new IndexIOProcessor<GlobalSNodeId, List<GlobalSNodeId>>() {
        @Override
        public String serialize(Map<GlobalSNodeId, List<GlobalSNodeId>> globalSNodeIdListMap) {
          StringBuilder builder = new StringBuilder();
          for (GlobalSNodeId key : globalSNodeIdListMap.keySet()) {
            builder.append("\t<item>\n\t\t<key>\n");
            appendGlobalSNodeIdData(builder, key);
            builder.append("\t\t</key>\n");
            for (GlobalSNodeId value : globalSNodeIdListMap.get(key)) {
              builder.append("\t\t<val>\n");
              appendGlobalSNodeIdData(builder, value);
              builder.append("\t\t</val>\n");
            }
            builder
              .append("\t</item>\n");
          }
          return builder.toString();
        }

        private void appendGlobalSNodeIdData(StringBuilder builder, GlobalSNodeId sNodeId) {
          builder
            .append("\t\t\t<ref>")
            .append(sNodeId.getModelReference())
            .append("</ref>\n\t\t\t<id>")
            .append(sNodeId.getNodeId())
            .append("</id>\n");
        }

        @Override
        public Map<GlobalSNodeId, List<GlobalSNodeId>> load(List<Element> elementList, FileContent inputData) throws IndexIOProcessorException {
          Map<GlobalSNodeId, List<GlobalSNodeId>> result = new HashMap<GlobalSNodeId, List<GlobalSNodeId>>();

          for (Element element : elementList) {
            GlobalSNodeId keyID = null;
            List<GlobalSNodeId> valueIDs = new ArrayList<GlobalSNodeId>();

            for (int i = 0; i < element.getChildNodes().getLength(); i++) {
              Node node = element.getChildNodes().item(i);
              if (node instanceof Element) {
                Element keyOrValue = (Element) node;
                if ("key".equals(keyOrValue.getTagName())) {
                  keyID = getSNodeId(keyOrValue);
                }
                if ("val".equals(keyOrValue.getTagName())) {
                  valueIDs.add(getSNodeId(keyOrValue));
                }
              }
            }

            if (keyID == null || valueIDs.isEmpty()) {
              throw new IndexIOProcessorException();
            }

            result.put(keyID, valueIDs);
          }

          return result;
        }

        private GlobalSNodeId getSNodeId(Element element) throws IndexIOProcessorException {
          String modelReference = null;
          String nodeId = null;
          for (int i = 0; i < element.getChildNodes().getLength(); i++) {
            Node node = element.getChildNodes().item(i);
            if (node instanceof Element) {
              Element refOrId = (Element) node;
              if ("ref".equals(refOrId.getTagName())) {
                modelReference = refOrId.getTextContent();
              }
              if ("id".equals(refOrId.getTagName())) {
                nodeId = refOrId.getTextContent();
              }
            }
          }

          if (modelReference == null || nodeId ==null) {
            throw new IndexIOProcessorException();
          }

          return new GlobalSNodeId(modelReference, nodeId);
        }
      };
    }

    @Override
    protected String getIndexName() {
      return INDEX_NAME;
    }
  }
}
