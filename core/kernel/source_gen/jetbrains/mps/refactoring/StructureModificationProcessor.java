package jetbrains.mps.refactoring;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class StructureModificationProcessor {
  protected static Log log = LogFactory.getLog(StructureModificationProcessor.class);

  private ModelLinkMap myModelMap;
  private SModel myModel;

  public StructureModificationProcessor(ModelLinkMap modelMap, SModel model) {
    myModelMap = modelMap;
    myModel = model;
  }

  private boolean playRefactoring(@NotNull StructureModification data) {
    boolean result = data.apply(myModelMap);
    for (IMapping<SModelReference, Integer> entry : MapSequence.fromMap(data.getDependencies())) {
      // also adds implicit import if necessary 
      myModel.updateImportedModelUsedVersion(entry.key(), entry.value() + 1);
    }
    return result;
  }

  private boolean playModelRefactorings(EditableSModelDescriptor model, int usedVersion) {
    int modelVersion = model.getVersion();
    if (modelVersion > usedVersion) {
      boolean played = false;
      for (StructureModification data : ListSequence.fromList(model.getStructureModificationLog().getHistory())) {
        if (MapSequence.fromMap(data.getDependencies()).get(model.getSModelReference()) < usedVersion) {
          continue;
        }
        played |= playRefactoring(data);
      }
      return played;
    } else if (modelVersion < usedVersion) {
      /*
        {
          if (log.isErrorEnabled()) {
            log.error("Model version mismatch for import " + model.getSModelReference().getSModelFqName() + " in model " + myModel.getSModelFqName());
          }
        }
        {
          if (log.isErrorEnabled()) {
            log.error("Used version = " + usedVersion + ", current version = " + modelVersion);
          }
        }
        // <node> 
        // <node> 
      */
      return false;
    } else {
      return false;
    }
  }

  public boolean updateModelOnLoad() {
    // should be called in loading state 
    if (!(refactoringsPlaybackEnabled() && SModelStereotype.isUserModel(myModel))) {
      return false;
    }
    boolean result = false;
    // todo: calculate the order of refactorings to play and use it 
    boolean played;
    do {
      played = false;
      for (SModel.ImportElement importElement : ListSequence.fromList(SModelOperations.getAllImportElements(myModel))) {
        EditableSModelDescriptor usedModel = as_etzqsh_a0a0a1a5a2(SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference()), EditableSModelDescriptor.class);
        if (usedModel != null && playModelRefactorings(usedModel, importElement.getUsedVersion())) {
          result = played = true;
        }
      }
    } while (played);
    return result;
  }

  public static void addToLog(@NotNull final StructureModification data) {
    // add all missed dependencies with current version 
    for (StructureModification.Entry entry : ListSequence.fromList(data.getData())) {
      Sequence.fromIterable(entry.getDependentModels()).visitAll(new IVisitor<SModelReference>() {
        public void visit(SModelReference it) {
          data.addDependencyModel(it);
        }
      });
    }
    // add modification to all dependent models 
    for (IMapping<SModelReference, Integer> dependency : MapSequence.fromMap(data.getDependencies())) {
      EditableSModelDescriptor model = (EditableSModelDescriptor) SModelRepository.getInstance().getModelDescriptor(dependency.key());
      StructureModificationLog modificationLog = model.getStructureModificationLog();
      modificationLog.addStructureModification(data);
      model.setVersion(dependency.value() + 1);
      model.saveStructureModificationLog(modificationLog);
      model.setChanged(true);
    }
  }

  public static boolean hasRefactoringsToPlay(@NotNull SModel model) {
    if (refactoringsPlaybackEnabled() && SModelStereotype.isUserModel(model)) {
      for (SModel.ImportElement importElement : ListSequence.fromList(SModelOperations.getAllImportElements(model))) {
        EditableSModelDescriptor usedModel = as_etzqsh_a0a0a0a0a1(SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference()), EditableSModelDescriptor.class);
        if (usedModel != null && importElement.getUsedVersion() < usedModel.getVersion()) {
          return true;
        }
      }
    }
    return false;
  }

  public static boolean refactoringsPlaybackEnabled() {
    return !("false".equals(System.getProperty("mps.playRefactorings")));
  }

  private static <T> T as_etzqsh_a0a0a0a0a1(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }

  private static <T> T as_etzqsh_a0a0a1a5a2(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }
}
