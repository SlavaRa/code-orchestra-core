package jetbrains.mps.lang.smodel.generator.smodelAdapter;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.INodeAdapter;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.smodel.SModelUtil_new;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.util.Condition;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.search.ISearchScope;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.search.SModelSearchUtil;
import jetbrains.mps.smodel.constraints.SearchScopeStatus;
import jetbrains.mps.smodel.constraints.ModelConstraintsUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.smodel.SReference;

public class SNodeOperations {
  private static final Logger LOG = Logger.getLogger(SNodeOperations.class);
  private static boolean ourCastsEnabled = !(("true".equals(System.getProperty("mps.disableNodeCastExceptions"))));

  public SNodeOperations() {
  }

  public static INodeAdapter getAdapter(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getAdapter();
  }

  public static SNode copyNode(SNode node) {
    if (node == null) {
      return null;
    }
    return CopyUtil.copy(node);
  }

  public static SNode getContainingRoot(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getContainingRoot();
  }

  @Deprecated
  public static SNode getParent(SNode node, String parentConceptFqName, boolean inclusion, boolean root) {
    // use node.getParent() 
    return SNodeOperations.getAncestor(node, parentConceptFqName, inclusion, root);
  }

  public static SNode getParent(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getParent();
  }

  public static SNode getAncestor(SNode node, String ancestorConceptFqName, boolean inclusion, boolean root) {
    return SNodeOperations.getAncestor(node, ancestorConceptFqName, inclusion, root, false);
  }

  public static SNode getAncestor(SNode node, String ancestorConceptFqName, boolean inclusion, boolean root, boolean sameMetaLevel) {
    if (node == null) {
      return null;
    }
    int metaLevel = (sameMetaLevel ?
      SModelUtil_new.getMetaLevel(node) :
      0
    );

    // look up for certain concept 
    if (root) {
      SNode rootParent = node.getContainingRoot();
      if (rootParent != null && SNodeOperations.nullSafeInstanceOf(rootParent, ancestorConceptFqName)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(rootParent) == metaLevel) {
          return rootParent;
        }
      }
      return null;
    }

    // look-up parent of required type 
    SNode outputNode;
    if (inclusion) {
      outputNode = node;
    } else {
      outputNode = node.getParent();
    }
    if (outputNode == null) {
      return null;
    }
    if (SNodeOperations.nullSafeInstanceOf(outputNode, ancestorConceptFqName)) {
      if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
        return outputNode;
      }
    }
    while ((outputNode = outputNode.getParent()) != null) {
      if (SNodeOperations.nullSafeInstanceOf(outputNode, ancestorConceptFqName)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
          break;
        }
      }
    }
    return outputNode;
  }

  private static boolean nullSafeInstanceOf(SNode node, String conceptFQName) {
    if (conceptFQName == null) {
      return true;
    }
    return node.isInstanceOfConcept(conceptFQName);
  }

  public static SNode getAncestorWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion, boolean root) {
    return SNodeOperations.getAncestorWhereConceptInList(node, ancestorConceptFqNames, inclusion, root, false);
  }

  public static SNode getAncestorWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion, boolean root, boolean sameMetaLevel) {
    if (node == null) {
      return null;
    }
    int metaLevel = (sameMetaLevel ?
      SModelUtil_new.getMetaLevel(node) :
      0
    );
    if (ancestorConceptFqNames.length == 0) {
      return null;
    }
    if (root) {
      SNode rootParent = node.getContainingRoot();
      if (SNodeOperations._isInstanceOf(rootParent, ancestorConceptFqNames)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(rootParent) == metaLevel) {
          return rootParent;
        }
      }
      return null;
    }

    // look-up parent of required type 
    SNode outputNode;
    if (inclusion) {
      outputNode = node;
    } else {
      outputNode = node.getParent();
    }
    if (outputNode == null) {
      return null;
    }
    if (SNodeOperations._isInstanceOf(outputNode, ancestorConceptFqNames)) {
      if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
        return outputNode;
      }
    }
    while ((outputNode = outputNode.getParent()) != null) {
      if (SNodeOperations._isInstanceOf(outputNode, ancestorConceptFqNames)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
          return outputNode;
        }
      }
    }
    return outputNode;
  }

  public static List<SNode> getAncestors(SNode node, String ancestorConceptFqName, boolean inclusion) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null) {
      return result;
    }
    if (!(inclusion)) {
      node = node.getParent();
    }
    while (node != null) {
      if (ancestorConceptFqName == null || node.isInstanceOfConcept(ancestorConceptFqName)) {
        result.add(node);
      }
      node = node.getParent();
    }
    return result;
  }

  public static List<SNode> getAncestorsWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion) {
    if (node == null) {
      new ArrayList<SNode>();
    }
    List<SNode> result = new ArrayList<SNode>();
    if (!(inclusion) && node != null) {
      node = node.getParent();
    }
    while (node != null) {
      if (SNodeOperations._isInstanceOf(node, ancestorConceptFqNames)) {
        result.add(node);
      }
      node = node.getParent();
    }
    return result;
  }

  public static List<SNode> getDescendants(SNode node, final String childConceptFqName, boolean inclusion) {
    return SNodeOperations.getDescendants(node, childConceptFqName, inclusion, new String[0]);
  }

  public static List<SNode> getDescendants(SNode node, final String childConceptFqName, boolean inclusion, final String[] stopConceptFqNames) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null) {
      return result;
    }

    if (childConceptFqName == null) {
      result = (List<SNode>) node.getDescendants();
      if (inclusion) {
        result.add(0, node);
      }
      return result;
    }

    if (inclusion) {
      if (node.isInstanceOfConcept(childConceptFqName)) {
        result.add(node);
      }
    }
    Condition<SNode> stopCondition = (stopConceptFqNames.length == 0 ?
      Condition.FALSE_CONDITION :
      new Condition<SNode>() {
        public boolean met(SNode node) {
          return SNodeOperations._isInstanceOf(node, stopConceptFqNames);
        }
      }
    );
    SNodeOperations._populateListOfDescendants(result, node, new Condition<SNode>() {
      public boolean met(SNode node) {
        return node.isInstanceOfConcept(childConceptFqName);
      }
    }, stopCondition);
    return result;
  }

  public static List<SNode> getDescendantsWhereConceptInList(SNode node, final String[] descendantConceptFqNames, boolean inclusion) {
    return SNodeOperations.getDescendantsWhereConceptInList(node, descendantConceptFqNames, inclusion, new String[0]);
  }

  public static List<SNode> getDescendantsWhereConceptInList(SNode node, final String[] descendantConceptFqNames, boolean inclusion, final String[] stopConceptFqNames) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null || descendantConceptFqNames.length == 0) {
      return result;
    }

    if (inclusion) {
      if (SNodeOperations._isInstanceOf(node, descendantConceptFqNames)) {
        result.add(node);
      }
    }
    Condition<SNode> stopCondition = (stopConceptFqNames.length == 0 ?
      Condition.FALSE_CONDITION :
      new Condition<SNode>() {
        public boolean met(SNode node) {
          return SNodeOperations._isInstanceOf(node, stopConceptFqNames);
        }
      }
    );
    SNodeOperations._populateListOfDescendants(result, node, new Condition<SNode>() {
      public boolean met(SNode node) {
        return SNodeOperations._isInstanceOf(node, descendantConceptFqNames);
      }
    }, stopCondition);
    return result;
  }

  private static void _populateListOfDescendants(List<SNode> list, SNode node, Condition<SNode> condition, Condition<SNode> stopCondition) {
    for (SNode child : node.getChildrenIterable()) {
      if (condition.met(child)) {
        list.add(child);
      }
      if (stopCondition == null || !(stopCondition.met(child))) {
        SNodeOperations._populateListOfDescendants(list, child, condition, stopCondition);
      }
    }
  }

  private static boolean _isInstanceOf(SNode node, String[] conceptFqNames) {
    for (String conceptFqName : conceptFqNames) {
      if (conceptFqName == null) {
        continue;
      }
      if (node.isInstanceOfConcept(conceptFqName)) {
        return true;
      }
    }
    return false;
  }

  public static List<SNode> getChildren(SNode node) {
    if (node == null) {
      return new ArrayList<SNode>();
    }
    return node.getChildren();
  }

  public static List<SNode> getChildren(SNode node, SNode linkDeclaration) {
    if (node == null || linkDeclaration == null) {
      return new ArrayList<SNode>(0);
    }
    linkDeclaration = SModelUtil.getGenuineLinkDeclaration(linkDeclaration);
    return SLinkOperations.getTargets(node, SPropertyOperations.getString(linkDeclaration, "role"), true);
  }

  public static SModel getModel(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getModel();
  }

  public static boolean isInstanceOf(SNode node, String conceptFQName) {
    if (node == null) {
      return false;
    }
    if (conceptFQName == null) {
      return false;
    }
    return node.isInstanceOfConcept(conceptFQName);
  }

  public static SNode getNextSibling(SNode node) {
    if (node == null || node.getParent() == null) {
      return null;
    }
    return node.getParent().getNextChild(node);
  }

  public static SNode getPrevSibling(SNode node) {
    if (node == null || node.getParent() == null) {
      return null;
    }
    return node.getParent().getPrevChild(node);
  }

  public static List<SNode> getPrevSiblings(SNode node, boolean inclusion) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null) {
      return result;
    }
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    String role = node.getRole_();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        if (inclusion) {
          result.add(child);
        }
        break;
      }
      result.add(child);
    }
    return result;
  }

  public static List<SNode> getNextSiblings(SNode node, boolean inclusion) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null) {
      return result;
    }
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    if (inclusion) {
      result.add(node);
    }
    boolean childFound = false;
    String role = node.getRole_();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        childFound = true;
      } else
      if (childFound) {
        result.add(child);
      }
    }
    return result;
  }

  public static List<SNode> getAllSiblings(SNode node, boolean inclusion) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null) {
      return result;
    }
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    String role = node.getRole_();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        if (inclusion) {
          result.add(child);
        }
      } else {
        result.add(child);
      }
    }
    return result;
  }

  public static SNode insertNewNextSiblingChild(SNode node, String conceptFQName) {
    if (node == null || node.getParent() == null) {
      return null;
    }
    SNode parent = node.getParent();
    SNode newChild = SModelOperations.createNewNode(node.getModel(), conceptFQName);
    if (newChild == null) {
      return null;
    }
    String role = node.getRole_();
    assert parent != null && role != null;
    parent.insertChild(node, role, newChild);
    return newChild;
  }

  public static SNode insertNewPrevSiblingChild(SNode node, String conceptFqName) {
    if (node == null) {
      return null;
    }
    SNode parent = node.getParent();
    if (parent == null) {
      return null;
    }
    SNode newChild = SModelOperations.createNewNode(node.getModel(), conceptFqName);
    if (newChild == null) {
      return null;
    }
    String role = node.getRole_();
    assert role != null;
    parent.insertChild(node, role, newChild, true);
    return newChild;
  }

  public static SNode insertNextSiblingChild(SNode node, SNode siblingNode) {
    if (node == null) {
      return null;
    }
    SNode nodeParent = node.getParent();
    if (nodeParent == null || siblingNode == null || node == siblingNode) {
      return siblingNode;
    }
    SNode parent = siblingNode.getParent();
    if (parent != null) {
      parent.removeChild(siblingNode);
    }
    String role = node.getRole_();
    assert role != null;
    nodeParent.insertChild(node, role, siblingNode, false);
    return siblingNode;
  }

  public static SNode insertPrevSiblingChild(SNode node, SNode siblingNode) {
    if (node == null) {
      return null;
    }
    SNode nodeParent = node.getParent();
    if (nodeParent == null || siblingNode == null || node == siblingNode) {
      return siblingNode;
    }
    SNode siblingParent = siblingNode.getParent();
    if (siblingParent != null) {
      siblingParent.removeChild(siblingNode);
    }
    String role = node.getRole_();
    assert role != null;
    nodeParent.insertChild(node, role, siblingNode, true);
    return siblingNode;
  }

  public static SNode replaceWithNewChild(SNode oldChild, String conceptFqName) {
    assert oldChild != null : "can't replace node. node is NULL";
    SNode oldChildParent = oldChild.getParent();
    if (oldChildParent == null && !(oldChild.isRoot())) {
      return null;
    }
    SModel model = oldChild.getModel();
    SNode newChild = SModelOperations.createNewNode(model, conceptFqName);
    if (newChild == null) {
      return null;
    }
    if (oldChildParent == null) {
      model.addRoot(newChild);
      model.removeRoot(oldChild);
    } else {
      oldChildParent.replaceChild(oldChild, newChild);
    }
    SNodeOperations.copyAllAttributes(oldChild, newChild);
    return newChild;
  }

  private static void copyAllAttributes(SNode oldChild, SNode newChild) {
    for (SNode attribute : AttributeOperations.getAllAttributes(oldChild)) {
      if (SNodeOperations.isInstanceOf(attribute, "jetbrains.mps.lang.core.structure.PropertyAttribute")) {
        String propertyName = AttributeOperations.getPropertyName(SNodeOperations.cast(attribute, "jetbrains.mps.lang.core.structure.PropertyAttribute"));
        if ((((SNode) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(SNodeOperations.getConceptDeclaration(newChild), "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"), "call_findPropertyDeclaration_1219835742593", new Class[]{SNode.class, String.class}, propertyName)) == null)) {
          // no such property in new child : don't copy the attribute 
          LOG.error("couldn't copy attribute " + attribute.getConceptShortName() + " for property '" + propertyName + "' : so such property in concept " + newChild.getConceptShortName(), newChild);
          continue;
        }
      }
      if (SNodeOperations.isInstanceOf(attribute, "jetbrains.mps.lang.core.structure.LinkAttribute")) {
        String linkRole = AttributeOperations.getLinkRole(SNodeOperations.cast(attribute, "jetbrains.mps.lang.core.structure.LinkAttribute"));
        if ((((SNode) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(SNodeOperations.getConceptDeclaration(newChild), "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"), "call_findLinkDeclaration_1213877394467", new Class[]{SNode.class, String.class}, linkRole)) == null)) {
          // no such link in new child : don't copy the attribute 
          LOG.error("couldn't copy attribute " + attribute.getConceptShortName() + " for link '" + linkRole + "' : so such link in concept " + newChild.getConceptShortName(), newChild);
          continue;
        }
      }

      newChild.addChild(SNodeOperations.getContainingLinkRole(attribute), SNodeOperations.copyNode(attribute));
    }
  }

  public static SNode replaceWithAnother(SNode node, SNode anotherNode) {
    assert node != null : "can't replace node. node is NULL";
    SNode nodeParent = node.getParent();
    if (nodeParent == null) {
      if (node.isRoot()) {
        SModel model = node.getModel();
        node.delete();
        model.addRoot(anotherNode);
      } else {
        return anotherNode;
      }
    }
    if (anotherNode != null) {
      SNode anotherNodeParent = anotherNode.getParent();
      if (anotherNodeParent != null) {
        anotherNodeParent.removeChild(anotherNode);
      }
      nodeParent.replaceChild(node, anotherNode);
    } else {
      nodeParent.removeChild(node);
    }
    return anotherNode;
  }

  public static void deleteNode(SNode node) {
    if (node != null && !(node.isDeleted())) {
      node.delete();
    }
  }

  public static SNode detachNode(SNode node) {
    if (node != null && node.isRegistered()) {
      SNode parent = node.getParent();
      if (parent != null) {
        parent.removeChild(node);
      } else {
        node.getModel().removeRoot(node);
      }
    }
    return node;
  }

  public static boolean hasRole(SNode node, String conceptOfParentFqName, String role) {
    if (node == null || node.getParent() == null || conceptOfParentFqName == null || conceptOfParentFqName.length() == 0 || role == null || role.length() == 0) {
      return false;
    }
    SNode expectedConcept = SModelUtil.findConceptDeclaration(conceptOfParentFqName, GlobalScope.getInstance());
    if (expectedConcept == null) {
      return false;
    }
    SNode nodeParent = node.getParent();
    assert nodeParent != null;
    SNode conceptOfParent = (SNode) nodeParent.getConceptDeclarationNode();
    if (!(SModelUtil.isAssignableConcept(conceptOfParent, expectedConcept))) {
      return false;
    }
    return role.equals(node.getRole_());
  }

  public static SNode getConceptDeclaration(SNode node) {
    return (node == null ?
      null :
      node.getConceptDeclarationNode()
    );
  }

  public static int getIndexInParent(SNode node) {
    if (node == null || node.getParent() == null) {
      return -1;
    }
    return node.getParent().getIndexOfChild(node);
  }

  public static List<SNode> getAllAttributes(SNode node) {
    return AttributeOperations.getAllAttributes(node);
  }

  public static boolean isAttribute(SNode node) {
    return AttributeOperations.isAttribute(node);
  }

  public static SNode getNode(String modelUID, String nodeID) {
    return new SNodePointer(modelUID, nodeID).getNode();
  }

  public static ISearchScope getReferentSearchScope(SNode referenceNode, String referenceRole, IOperationContext context) {
    if (referenceNode == null) {
      return null;
    }
    SNode referenceNodeConcept = referenceNode.getConceptDeclarationNode();
    SNode referenceLinkDecl = SNodeOperations.cast(SModelSearchUtil.findLinkDeclaration(referenceNodeConcept, referenceRole), "jetbrains.mps.lang.structure.structure.LinkDeclaration");
    if (referenceLinkDecl == null) {
      return null;
    }
    String genuineRole = SModelUtil.getGenuineLinkRole(referenceLinkDecl);
    SearchScopeStatus status = ModelConstraintsUtil.getSearchScope(referenceNode.getParent(), referenceNode, referenceNodeConcept, genuineRole, context);
    if (status.isOk()) {
      return status.getSearchScope();
    }
    return null;
  }

  public static SNode cast(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(node, castTo))) {
      // hack, remove? 
      if (!("jetbrains.mps.lang.typesystem.structure.RuntimeTypeVariable".equals(node.getConceptFqName()))) {
        if (ourCastsEnabled) {
          throw new NodeCastException("Can't cast " + node.getConceptFqName() + " to " + castTo);
        } else {
          LOG.warning("Can't cast " + node.getConceptFqName() + " to " + castTo);
        }
      }
    }
    return node;
  }

  public static SNode as(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(node, castTo))) {
      return null;
    }
    return node;
  }

  public static SNode castConcept(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SModelUtil.isAssignableConcept(NameUtil.nodeFQName(node), castTo))) {
      if (ourCastsEnabled) {
        throw new NodeCastException("Can't cast " + NameUtil.nodeFQName(node) + " to " + castTo);
      } else {
        LOG.warning("Can't cast " + NameUtil.nodeFQName(node) + " to " + castTo);
      }
    }
    return node;
  }

  public static SNode asConcept(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SModelUtil.isAssignableConcept(NameUtil.nodeFQName(node), castTo))) {
      return null;
    }
    return node;
  }

  public static SNode getContainingLinkDeclaration(SNode childNode) {
    if (childNode == null) {
      return null;
    }
    return childNode.getRoleLink();
  }

  public static String getContainingLinkRole(SNode childNode) {
    if (childNode == null) {
      return null;
    }
    return childNode.getRole_();
  }

  public static List<SReference> getReferences(SNode node) {
    if (node == null) {
      return new ArrayList<SReference>(0);
    }
    return node.getReferences();
  }

  public static SReference getReference(SNode node, SNode linkDeclaration) {
    if (node == null || linkDeclaration == null) {
      return null;
    }
    linkDeclaration = SModelUtil.getGenuineLinkDeclaration(linkDeclaration);
    return node.getReference(SPropertyOperations.getString(linkDeclaration, "role"));
  }
}
