package jetbrains.mps.debug.evaluation;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import com.sun.jdi.Value;
import com.sun.jdi.ArrayReference;
import org.jetbrains.annotations.NotNull;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.ClassType;
import com.sun.jdi.Method;
import java.util.List;
import jetbrains.mps.debug.evaluation.proxies.MirrorUtil;
import com.sun.jdi.InvocationException;
import com.sun.jdi.InvalidTypeException;
import com.sun.jdi.ClassNotLoadedException;
import com.sun.jdi.IncompatibleThreadStateException;
import com.sun.jdi.Field;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.VirtualMachine;
import org.jetbrains.annotations.Nullable;
import com.sun.jdi.Type;
import com.sun.jdi.ArrayType;
import com.sun.jdi.InterfaceType;
import jetbrains.mps.debug.evaluation.proxies.IValueProxy;
import com.sun.jdi.StackFrame;
import com.sun.jdi.LocalVariable;
import com.sun.jdi.AbsentInformationException;
import jetbrains.mps.debug.evaluation.proxies.IObjectValueProxy;
import jetbrains.mps.debug.evaluation.proxies.IterableProxy;
import jetbrains.mps.debug.evaluation.proxies.IArrayValueProxy;
import jetbrains.mps.debug.evaluation.proxies.IterableArrayProxy;
import com.sun.jdi.ClassObjectReference;
import jetbrains.mps.debug.evaluation.proxies.PrimitiveValueProxy;
import com.sun.jdi.PrimitiveValue;
import com.sun.jdi.BooleanValue;
import com.sun.jdi.ShortValue;
import com.sun.jdi.ByteValue;
import com.sun.jdi.CharValue;
import com.sun.jdi.DoubleValue;
import com.sun.jdi.FloatValue;
import com.sun.jdi.IntegerValue;
import com.sun.jdi.LongValue;

public class EvaluationUtils {
  protected static Log log = LogFactory.getLog(EvaluationUtils.class);

  public EvaluationUtils() {
  }

  public static Value getElementAt(ArrayReference array, int index) {
    return array.getValue(index);
  }

  private static Value invokeStaticInternal(String className, String methodName, String jniSignature, @NotNull final ThreadReference threadReference, Object... args) throws EvaluationException {
    final ClassType referenceType = (ClassType) EvaluationUtils.findClassType(className, threadReference.virtualMachine());
    final Method method = EvaluationUtils.findMethod(referenceType, methodName, jniSignature);
    final List<Value> argValues = MirrorUtil.getValues(threadReference, args);
    return EvaluationUtils.handleInvocationExceptions(new EvaluationUtils.ThreadInvocatable<Value>(threadReference) {
      @Override
      public Value invoke() throws InvocationException, InvalidTypeException, ClassNotLoadedException, IncompatibleThreadStateException {
        return referenceType.invokeMethod(threadReference, method, argValues, 0);
      }
    });
  }

  private static Value getStaticFieldValueInternal(String className, String fieldName, @NotNull final ThreadReference threadReference) throws InvalidEvaluatedExpressionException {
    ClassType referenceType = (ClassType) EvaluationUtils.findClassType(className, threadReference.virtualMachine());
    Field field = EvaluationUtils.findField(referenceType, fieldName);
    assert field.isStatic();
    return referenceType.getValue(field);
  }

  private static Value invokeConstructorInternal(String className, String jniSignature, @NotNull final ThreadReference threadReference, Object... args) throws EvaluationException {
    // TODO duplication in code 
    final ClassType referenceType = (ClassType) EvaluationUtils.findClassType(className, threadReference.virtualMachine());
    final Method constructor = EvaluationUtils.findConstructor(referenceType, jniSignature);
    final List<Value> argValues = MirrorUtil.getValues(threadReference, args);
    return EvaluationUtils.handleInvocationExceptions(new EvaluationUtils.ThreadInvocatable<Value>(threadReference) {
      @Override
      public Value invoke() throws InvocationException, InvalidTypeException, ClassNotLoadedException, IncompatibleThreadStateException {
        return referenceType.newInstance(threadReference, constructor, argValues, 0);
      }
    });
  }

  @NotNull
  public static Field findField(ClassType referenceType, String fieldName) throws InvalidEvaluatedExpressionException {
    Field field = referenceType.fieldByName(fieldName);
    if (field == null) {
      throw new InvalidEvaluatedExpressionException("Could not find field " + fieldName + " in " + referenceType.name() + ".");
    }
    return field;
  }

  public static List<Field> findFields(ClassType referenceType) {
    return referenceType.fields();
  }

  @NotNull
  public static Method findConstructor(ClassType referenceType, String jniSignature) throws InvalidEvaluatedExpressionException {
    List<Method> methods = referenceType.methodsByName("<init>", jniSignature);
    if (methods.size() == 0) {
      throw new InvalidEvaluatedExpressionException("Could not find constructor  with signature " + jniSignature + " in " + referenceType.name() + ".");
    }
    Method constructor = null;
    for (Method m : methods) {
      if (m.isConstructor()) {
        constructor = m;
        break;
      }
    }
    if (constructor == null) {
      throw new InvalidEvaluatedExpressionException("Could not find constructor  with signature " + jniSignature + " in " + referenceType.name() + ".");
    }
    return constructor;
  }

  @NotNull
  public static Method findMethod(ClassType referenceType, String methodsName, String jniSignature) throws InvalidEvaluatedExpressionException {
    List<Method> methods = referenceType.methodsByName(methodsName, jniSignature);
    if (methods.size() == 0) {
      throw new InvalidEvaluatedExpressionException("Could not find method " + methodsName + " with signature " + jniSignature + " in " + referenceType.name() + ".");
    }
    return methods.get(0);
  }

  @NotNull
  public static ReferenceType findClassType(String className, VirtualMachine virtualMachine) throws InvalidEvaluatedExpressionException {
    ReferenceType classType = EvaluationUtils.findClassTypeSilently(className, virtualMachine);
    if (classType == null) {
      throw new InvalidEvaluatedExpressionException("Could not find class " + className + ".");
    }
    return classType;
  }

  @Nullable
  public static ReferenceType findClassTypeSilently(String className, VirtualMachine virtualMachine) throws InvalidEvaluatedExpressionException {
    // apparently, classesByName works for both dot and slash (ie for java.lang.String and for java/lang/String) 
    // even for java.lang/String 
    List<ReferenceType> classes = virtualMachine.classesByName(className);
    if (classes.size() == 0) {
      return null;
    }
    return classes.get(0);
  }

  public static boolean isInstanceOf(final Type what, final String jniSignature, final VirtualMachine machine) throws EvaluationException {
    if (jniSignature.equals("Ljava/lang/Object;")) {
      return true;
    }
    if (what.signature().equals(jniSignature)) {
      return true;
    }
    return EvaluationUtils.handleInvocationExceptions(new EvaluationUtils.Invocatable<Boolean>() {
      @Override
      public Boolean invoke() throws InvocationException, InvalidTypeException, ClassNotLoadedException, IncompatibleThreadStateException, EvaluationException {
        if (jniSignature.startsWith("[")) {
          if (!((what instanceof ArrayType))) {
            return false;
          }
          return EvaluationUtils.isInstanceOf(((ArrayType) what).componentType(), jniSignature.substring(1), machine);
        } else
        if (jniSignature.startsWith("L")) {
          if (!((what instanceof ClassType))) {
            return false;
          }
          ReferenceType type = EvaluationUtils.findClassTypeSilently(jniSignature.substring(1, jniSignature.length() - 1), machine);
          if (type == null) {
            return false;
          }
          ClassType whatClassType = (ClassType) what;
          if (type instanceof InterfaceType) {
            return whatClassType.allInterfaces().contains((InterfaceType) type);
          }
          do {
            if (type.equals(whatClassType)) {
              return true;
            }
            whatClassType = whatClassType.superclass();
          } while (whatClassType != null);
          return false;
        }
        return false;
      }
    });
  }

  @NotNull
  public static IValueProxy getValue(String varName, StackFrame stackFrame, ThreadReference reference) throws EvaluationException {
    assert stackFrame != null;
    LocalVariable localVariable;
    try {
      localVariable = stackFrame.visibleVariableByName(varName);
    } catch (AbsentInformationException ex) {
      throw new EvaluationException(ex);
    }
    if (localVariable == null) {
      throw new EvaluationException("variable not found: " + varName);
    }
    Value v = stackFrame.getValue(localVariable);
    return MirrorUtil.getValueProxy(v, reference);
  }

  @NotNull
  public static <T extends IValueProxy> Iterable<T> toIterable(IObjectValueProxy valueProxy) {
    return new IterableProxy<T>(valueProxy);
  }

  @NotNull
  public static <T extends IValueProxy> Iterable<T> toIterableFromArray(IArrayValueProxy valueProxy) {
    return new IterableArrayProxy<T>(valueProxy);
  }

  @NotNull
  public static IValueProxy invokeStatic(String className, String name, String jniSignature, ThreadReference threadReference, Object... args) throws EvaluationException {
    return MirrorUtil.getValueProxy(EvaluationUtils.invokeStaticInternal(className, name, jniSignature, threadReference, args), threadReference);
  }

  @NotNull
  public static IValueProxy getStaticFieldValue(String className, String fieldName, ThreadReference threadReference) throws InvalidEvaluatedExpressionException {
    return MirrorUtil.getValueProxy(EvaluationUtils.getStaticFieldValueInternal(className, fieldName, threadReference), threadReference);
  }

  @NotNull
  public static IObjectValueProxy invokeConstructor(String className, String jniSignature, ThreadReference threadReference, Object... args) throws EvaluationException {
    return (IObjectValueProxy) MirrorUtil.getValueProxy(EvaluationUtils.invokeConstructorInternal(className, jniSignature, threadReference, args), threadReference);
  }

  public static IArrayValueProxy createArray(String className, ThreadReference threadReference, int size) throws EvaluationException {
    List<ReferenceType> referenceTypes = threadReference.virtualMachine().classesByName(className + "[");
    if (referenceTypes.isEmpty()) {
      throw new EvaluationException("Could not find type " + className + "[]");
    }
    ArrayType arrayType = null;
    for (ReferenceType referenceType : referenceTypes) {
      if (referenceType instanceof ArrayType) {
        arrayType = (ArrayType) referenceType;
        break;
      }
    }
    if (arrayType == null) {
      throw new EvaluationException("Could not find type " + className + "[]");
    }
    ArrayReference arrayReference = arrayType.newInstance(size);
    return (IArrayValueProxy) MirrorUtil.getValueProxy(arrayReference, threadReference);
  }

  public static IArrayValueProxy createArrayFromValues(String className, ThreadReference threadReference, Object... args) throws EvaluationException {
    IArrayValueProxy array = EvaluationUtils.createArray(className, threadReference, args.length);
    List<Value> values = MirrorUtil.getValues(threadReference, args);
    for (int i = 0; i < values.size(); i++) {
      array.setElement(values.get(i), i);
    }
    return array;
  }

  @NotNull
  public static IValueProxy getClassValue(String className, ThreadReference threadReference) throws InvalidEvaluatedExpressionException {
    ClassType referenceType = (ClassType) EvaluationUtils.findClassType(className, threadReference.virtualMachine());
    ClassObjectReference classObject = referenceType.classObject();
    return MirrorUtil.getValueProxy(classObject, threadReference);
  }

  @NotNull
  public static IObjectValueProxy box(PrimitiveValueProxy primitiveValueProxy, ThreadReference threadReference) throws EvaluationException {
    PrimitiveValue primitiveValue = primitiveValueProxy.getPrimitiveValue();
    if (primitiveValue instanceof BooleanValue) {
      return (IObjectValueProxy) EvaluationUtils.invokeStatic(Boolean.class.getName(), "valueOf", "(Z)Ljava/lang/Boolean;", threadReference, primitiveValue.booleanValue());
    }
    if (primitiveValue instanceof ShortValue) {
      return (IObjectValueProxy) EvaluationUtils.invokeStatic(Short.class.getName(), "valueOf", "(S)Ljava/lang/Short;", threadReference, primitiveValue.shortValue());
    }
    if (primitiveValue instanceof ByteValue) {
      return (IObjectValueProxy) EvaluationUtils.invokeStatic(Byte.class.getName(), "valueOf", "(B)Ljava/lang/Byte;", threadReference, primitiveValue.byteValue());
    }
    if (primitiveValue instanceof CharValue) {
      return (IObjectValueProxy) EvaluationUtils.invokeStatic(Character.class.getName(), "valueOf", "(C)Ljava/lang/Character;", threadReference, primitiveValue.charValue());
    }
    if (primitiveValue instanceof DoubleValue) {
      return (IObjectValueProxy) EvaluationUtils.invokeStatic(Double.class.getName(), "valueOf", "(D)Ljava/lang/Double;", threadReference, primitiveValue.doubleValue());
    }
    if (primitiveValue instanceof FloatValue) {
      return (IObjectValueProxy) EvaluationUtils.invokeStatic(Float.class.getName(), "valueOf", "(F)Ljava/lang/Float;", threadReference, primitiveValue.floatValue());
    }
    if (primitiveValue instanceof IntegerValue) {
      return (IObjectValueProxy) EvaluationUtils.invokeStatic(Integer.class.getName(), "valueOf", "(I)Ljava/lang/Integer;", threadReference, primitiveValue.intValue());
    }
    if (primitiveValue instanceof LongValue) {
      return (IObjectValueProxy) EvaluationUtils.invokeStatic(Long.class.getName(), "valueOf", "(J)Ljava/lang/Long;", threadReference, primitiveValue.longValue());
    }
    throw new UnsupportedOperationException("Cant box " + primitiveValue);
  }

  public static PrimitiveValueProxy unbox(IObjectValueProxy valueProxy) throws EvaluationException {
    Type type = valueProxy.getJDIValue().type();
    if (type.name().equals(Boolean.class.getName())) {
      return (PrimitiveValueProxy) valueProxy.invokeMethod("booleanValue", "()Z");
    }
    if (type.name().equals(Short.class.getName())) {
      return (PrimitiveValueProxy) valueProxy.invokeMethod("shortValue", "()S");
    }
    if (type.name().equals(Byte.class.getName())) {
      return (PrimitiveValueProxy) valueProxy.invokeMethod("byteValue", "()B");
    }
    if (type.name().equals(Character.class.getName())) {
      return (PrimitiveValueProxy) valueProxy.invokeMethod("charValue", "()C");
    }
    if (type.name().equals(Double.class.getName())) {
      return (PrimitiveValueProxy) valueProxy.invokeMethod("doubleValue", "()D");
    }
    if (type.name().equals(Float.class.getName())) {
      return (PrimitiveValueProxy) valueProxy.invokeMethod("floatValue", "()F");
    }
    if (type.name().equals(Integer.class.getName())) {
      return (PrimitiveValueProxy) valueProxy.invokeMethod("intValue", "()I");
    }
    if (type.name().equals(Long.class.getName())) {
      return (PrimitiveValueProxy) valueProxy.invokeMethod("longValue", "()J");
    }
    throw new UnsupportedOperationException("Cant unbox value of type" + type);
  }

  /**
   * Do something and convert jdi exceptions to evaluation exception
   * 
   * @param invocatable what to invoke
   * @param T result
   * @throws EvaluationException wrapper of the original exception
   * @return result
   */
  public static <T> T handleInvocationExceptions(EvaluationUtils.Invocatable<T> invocatable) throws EvaluationException {
    try {
      return invocatable.invoke();
    } catch (InvocationException e) {
      if (invocatable instanceof EvaluationUtils.ThreadInvocatable) {
        throw new TargetVMEvaluationException(e, ((EvaluationUtils.ThreadInvocatable) invocatable).getCurrentThreadReference());
      } else {
        throw new TargetVMEvaluationException(e);
      }
    } catch (IllegalArgumentException e) {
      throw new InvalidEvaluatedExpressionException(e);
    } catch (InvalidTypeException e) {
      throw new InvalidEvaluatedExpressionException(e);
    } catch (RuntimeException e) {
      if (e.getClass().getName().startsWith("com.sun.jdi")) {
        throw new JdiRuntimeExceptionEvaluationException(e);
      }
      throw new EvaluationRuntimeException(e);
    } catch (Throwable t) {
      throw new EvaluationException(t);
    }
  }

  /**
   * When we need to call something from ui which throws evaluation exception.
   * For example when we update the tree.
   * 
   * @param invocatable the action to invoke
   * @param failure value to return in case of failure
   * @param T result
   * @return result
   */
  public static <T> T consumeEvaluationException(EvaluationUtils.EvaluationInvocatable<T> invocatable, T failure) {
    try {
      return invocatable.invoke();
    } catch (InvalidEvaluatedExpressionException e) {
      if (log.isWarnEnabled()) {
        log.warn("", e);
      }
    } catch (InvocationTargetEvaluationException e) {
      if (log.isWarnEnabled()) {
        log.warn("", e);
      }
    } catch (TargetVMEvaluationException e) {
      if (log.isWarnEnabled()) {
        log.warn("", e);
      }
    } catch (JdiRuntimeExceptionEvaluationException e) {
      if (log.isInfoEnabled()) {
        log.info("", e);
      }
    } catch (EvaluationException e) {
      // some unknown exception -- better inform about it 
      if (log.isErrorEnabled()) {
        log.error("", e);
      }
    }
    return failure;
  }

  public 
  /**
   * Something that can throw one of jdi exceptions or EvaluationException
   * 
   * @param T result
   */
static interface Invocatable<T> {
    public T invoke() throws InvocationException, InvalidTypeException, ClassNotLoadedException, IncompatibleThreadStateException, EvaluationException;
  }

  public 
  /**
   * Something that can throw EvaluationException
   * 
   * @param T result
   */
static interface EvaluationInvocatable<T> {
    public T invoke() throws EvaluationException;
  }


  /**
   * Some action which also has information about thread reference where it happenes.
   * 
   * @param T result
   */
  public static abstract class ThreadInvocatable<T> implements EvaluationUtils.Invocatable<T> {
    private final ThreadReference myThreadReference;

    public ThreadInvocatable(ThreadReference threadReference) {
      myThreadReference = threadReference;
    }

    public ThreadReference getCurrentThreadReference() {
      return myThreadReference;
    }
  }
}
