package jetbrains.mps.testbench.junit.runners;

/*Generated by MPS */

import org.junit.runners.Suite;
import java.util.ArrayList;
import org.junit.runner.Runner;
import java.util.Collections;
import java.util.List;
import org.junit.runners.model.TestClass;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.Parameterized;
import java.lang.reflect.Modifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;
import org.junit.runner.notification.RunNotifier;

public class FilepathParameterized extends Suite {
  private final ArrayList<Runner> runners = new ArrayList<Runner>();

  public FilepathParameterized(Class<?> klass) throws Throwable {
    super(klass, Collections.<Runner>emptyList());
    List<Object[]> parametersList = getParametersList(getTestClass());
    for (int i = 0; i < parametersList.size(); i++) {
      FilepathParameterized.TestClassRunnerForParameters runner = new FilepathParameterized.TestClassRunnerForParameters(getTestClass().getJavaClass(), parametersList, i);
      runners.add(runner);
    }
  }

  @Override
  protected List<Runner> getChildren() {
    return runners;
  }

  @SuppressWarnings("unchecked")
  private List<Object[]> getParametersList(TestClass klass) throws Throwable {
    return (List<Object[]>) getParametersMethod(klass).invokeExplosively(null);
  }

  private FrameworkMethod getParametersMethod(TestClass testClass) throws Exception {
    List<FrameworkMethod> methods = testClass.getAnnotatedMethods(Parameterized.Parameters.class);
    for (FrameworkMethod each : methods) {
      int modifiers = each.getMethod().getModifiers();
      if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers)) {
        return each;
      }
    }
    throw new Exception("No public static parameters method on class " + testClass.getName());
  }

  private class TestClassRunnerForParameters extends BlockJUnit4ClassRunner {
    private final int fParameterSetNumber;
    private final List<Object[]> fParameterList;

    /*package*/ TestClassRunnerForParameters(Class<?> type, List<Object[]> parameterList, int i) throws InitializationError {
      super(type);
      fParameterList = parameterList;
      fParameterSetNumber = i;
    }

    @Override
    public Object createTest() throws Exception {
      return getTestClass().getOnlyConstructor().newInstance(computeParams());
    }

    private Object[] computeParams() throws Exception {
      try {
        return fParameterList.get(fParameterSetNumber);
      } catch (ClassCastException e) {
        throw new Exception(String.format("%s.%s() must return a Collection of arrays.", getTestClass().getName(), getParametersMethod(getTestClass()).getName()));
      }
    }

    @Override
    protected String getName() {
      Object firstArg = fParameterList.get(fParameterSetNumber)[0];
      if (firstArg instanceof String) {
        return (String) firstArg;
      }
      String fname = String.valueOf(firstArg);
      fname = fname.replaceAll("\\.\\w*$", "");
      fname = fname.replaceAll("^.*\\/", "");
      fname = fname.replaceAll("\\.", "_");
      return String.format("%s", fname);
    }

    @Override
    protected String testName(final FrameworkMethod method) {
      return String.format("%s (%s)", method.getName(), fParameterList.get(fParameterSetNumber)[0]);
    }

    @Override
    protected void validateConstructor(List<Throwable> errors) {
      validateOnlyOneConstructor(errors);
    }

    @Override
    protected Statement classBlock(RunNotifier notifier) {
      return childrenInvoker(notifier);
    }
  }
}
