package jetbrains.mps.ide.datatransfer;

/*Generated by MPS */

import com.intellij.util.containers.ArrayListSet;
import codeOrchestra.utils.ModuleReferenceUtils;
import jetbrains.mps.util.annotation.CodeOrchestraPatch;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.*;

import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.datatransfer.PasteNodeData;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.project.IModule;
import jetbrains.mps.datatransfer.CopyPasteManager;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.SModelId;
import jetbrains.mps.smodel.SModelOperations;
import com.intellij.ide.CopyPasteManagerEx;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import java.awt.datatransfer.DataFlavor;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.workbench.dialogs.project.utildialogs.addmodelimport.AddRequiredModelImportsDialog;
import com.intellij.openapi.util.Computable;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class CopyPasteUtil {
  private static CopyPasteUtil.IDataConverter myDataConverter = null;
  protected static Log log = LogFactory.getLog(CopyPasteUtil.class);

  public CopyPasteUtil() {
  }

  private static void processImportsAndLanguages(Set<SModelReference> necessaryImports, Set<ModuleReference> necessaryLanguages, Map<SNode, SNode> sourceNodesToNewNodes, Set<SReference> allReferences) {
    necessaryImports.clear();
    necessaryLanguages.clear();
    Set<SNode> sourceNodes = sourceNodesToNewNodes.keySet();
    for (SNode node : sourceNodes) {
      necessaryLanguages.add(node.getConceptLanguage().update());
    }
    for (SReference ref : allReferences) {
      if (sourceNodesToNewNodes.get(ref.getTargetNode()) == null) {
        SModelReference targetModelReference = ref.getTargetSModelReference();
        if (targetModelReference != null) {
          necessaryImports.add(targetModelReference.update());
        }
      }
    }
  }

  public static PasteNodeData createNodeDataIn(List<SNode> sourceNodes, Map<SNode, Set<SNode>> sourceNodesAndAttributes) {
    if (sourceNodes.isEmpty()) {
      return PasteNodeData.emptyPasteNodeData(null, null);
    }
    SModel model = sourceNodes.get(0).getModel();
    IModule module = model.getModelDescriptor().getModule();
    List<SNode> result = new ArrayList<SNode>();
    model.setLoading(true);
    Map<SNode, SNode> sourceNodesToNewNodes = new HashMap<SNode, SNode>();
    Set<SReference> allReferences = new HashSet<SReference>();
    for (SNode sourceNode : sourceNodes) {
      assert sourceNode.getModel() == model;
      SNode targetNode = CopyPasteUtil.copyNode_internal(sourceNode, sourceNodesAndAttributes, sourceNodesToNewNodes, allReferences);
      result.add(targetNode);
    }
    HashSet<SModelReference> necessaryModels = new HashSet<SModelReference>();
    HashSet<ModuleReference> necessaryLanguages = new HashSet<ModuleReference>();
    SModel fakeModel = CopyPasteUtil.copyModelProperties(model);
    CopyPasteUtil.processImportsAndLanguages(necessaryModels, necessaryLanguages, sourceNodesToNewNodes, allReferences);
    for (SNode copiedNode : result) {
      copiedNode.changeModel(fakeModel);
    }
    CopyPasteUtil.processReferencesIn(sourceNodesToNewNodes, allReferences);
    Map<SNode, SNode> newNodesToSourceNodes = new HashMap<SNode, SNode>();
    for (Map.Entry<SNode, SNode> entry : sourceNodesToNewNodes.entrySet()) {
      newNodesToSourceNodes.put(entry.getValue(), entry.getKey());
    }
    for (SNode newNode : result) {
      CopyPasteManager.getInstance().preProcessNode(newNode, newNodesToSourceNodes);
    }
    model.setLoading(false);
    return new PasteNodeData(result, null, module, fakeModel, necessaryLanguages, necessaryModels);
  }

  public static PasteNodeData createNodeDataOut(List<SNode> sourceNodes, IModule sourceModule, SModel model, SModel modelProperties, Set<ModuleReference> necessaryLanguages, Set<SModelReference> necessaryModels) {
    if (sourceNodes.isEmpty()) {
      return PasteNodeData.emptyPasteNodeData(null, null);
    }
    List<SNode> result = new ArrayList<SNode>();
    model.setLoading(true);
    Set<SReference> referencesRequireResolve = new HashSet<SReference>();
    Map<SNode, SNode> sourceNodesToNewNodes = new HashMap<SNode, SNode>();
    Set<SReference> allReferences = new HashSet<SReference>();
    SModel originalModel = sourceNodes.get(0).getModel();
    originalModel.setLoading(true);
    for (SNode sourceNode : sourceNodes) {
      assert sourceNode.getModel() == originalModel;
      SNode nodeToPaste = CopyPasteUtil.copyNode_internal(sourceNode, null, sourceNodesToNewNodes, allReferences);
      result.add(nodeToPaste);
    }
    SNode firstNodeToPaste = result.get(0);
    SModel fakeModel = firstNodeToPaste.getModel();
    fakeModel.setLoading(true);
    for (SNode nodeToPaste : result) {
      nodeToPaste.changeModel(model);
    }
    CopyPasteUtil.processReferencesOut(sourceNodesToNewNodes, allReferences, referencesRequireResolve);
    model.setLoading(false);
    originalModel.setLoading(false);
    fakeModel.setLoading(false);
    return new PasteNodeData(result, referencesRequireResolve, sourceModule, modelProperties, necessaryLanguages, necessaryModels);
  }

  private static SNode copyNode_internal(SNode sourceNode, @Nullable Map<SNode, Set<SNode>> nodesAndAttributes, Map<SNode, SNode> sourceNodesToNewNodes, Set<SReference> allReferences) {
    SNode targetNode = new SNode(sourceNode.getModel(), sourceNode.getConceptFqName());
    targetNode.setId(SNodeId.fromString(sourceNode.getSNodeId().toString()));
    targetNode.putProperties(sourceNode);
    sourceNodesToNewNodes.put(sourceNode, targetNode);
    List<SReference> references = sourceNode.getReferences();
    for (SReference reference : references) {
      allReferences.add(reference);
    }
    List<SNode> children = sourceNode.getChildren();
    for (SNode sourceChild : children) {
      if (nodesAndAttributes != null) {
        if (AttributeOperations.isAttribute(sourceChild)) {
          Set<SNode> nodes = nodesAndAttributes.get(sourceNode);
          if (nodes != null && !(nodes.contains(sourceChild))) {
            continue;
          }
        }
      }
      SNode targetChild = CopyPasteUtil.copyNode_internal(sourceChild, nodesAndAttributes, sourceNodesToNewNodes, allReferences);
      String role = sourceChild.getRole_();
      assert role != null;
      targetNode.addChild(role, targetChild);
    }
    return targetNode;
  }

  private static void processReferencesIn(Map<SNode, SNode> sourceNodesToNewNodes, Set<SReference> allReferences) {
    for (SReference sourceReference : allReferences) {
      SNode oldSourceNode = sourceReference.getSourceNode();
      SNode newSourceNode = sourceNodesToNewNodes.get(oldSourceNode);
      SNode oldTargetNode = sourceReference.getTargetNode();
      SNode newTargetNode = sourceNodesToNewNodes.get(oldTargetNode);
      SReference newReference;
      if (newTargetNode != null) {
        newReference = SReference.create(sourceReference.getRole(), newSourceNode, newTargetNode);
      } else {
        if (oldTargetNode != null) {
          newReference = SReference.create(sourceReference.getRole(), newSourceNode, oldTargetNode.getModel().getSModelReference(), oldTargetNode.getSNodeId());
        } else
        if (sourceReference.getResolveInfo() != null) {
          newReference = new StaticReference(sourceReference.getRole(), newSourceNode, null, null, sourceReference.getResolveInfo());
        } else {
          continue;
        }
      }
      newSourceNode.addReference(newReference);
    }
  }

  private static void processReferencesOut(Map<SNode, SNode> sourceNodesToNewNodes, Set<SReference> allReferences, Set<SReference> referencesRequireResolve) {
    for (SReference sourceReference : allReferences) {
      SNode oldSourceNode = sourceReference.getSourceNode();
      SNode newSourceNode = sourceNodesToNewNodes.get(oldSourceNode);
      SNode oldTargetNode = sourceReference.getTargetNode();
      SNode newTargetNode = sourceNodesToNewNodes.get(oldTargetNode);
      SReference newReference;
      if (newTargetNode != null) {
        newReference = SReference.create(sourceReference.getRole(), newSourceNode, newTargetNode);
      } else {
        if (SNodeOperations.isInstanceOf(newSourceNode, "jetbrains.mps.baseLanguage.structure.IMethodCall") && oldTargetNode != null) {
          newReference = SReference.create(sourceReference.getRole(), newSourceNode, oldTargetNode);
        } else {
          String resolveInfo = (oldTargetNode == null ?
            sourceReference.getResolveInfo() :
            oldTargetNode.getName()
          );
          if (resolveInfo != null) {
            if (oldTargetNode != null && !(oldTargetNode.isDisposed()) && oldTargetNode.getModel() != null) {
              newReference = new StaticReference(sourceReference.getRole(), newSourceNode, oldTargetNode.getModel().getSModelReference(), oldTargetNode.getSNodeId(), resolveInfo);
            } else {
              newReference = new StaticReference(sourceReference.getRole(), newSourceNode, null, null, resolveInfo);
            }
            referencesRequireResolve.add(newReference);
          } else
          if (oldTargetNode != null) {
            newReference = SReference.create(sourceReference.getRole(), newSourceNode, oldTargetNode);
          } else {
            continue;
          }
        }
      }
      newSourceNode.addReference(newReference);
    }
  }

  private static SModel copyModelProperties(SModel model) {
    SModelReference modelReference = model.getSModelReference();
    SModelFqName fqName = new SModelFqName(modelReference.getLongName(), SModelStereotype.INTERNAL_COPY);
    SModel newModel = new SModel(new SModelReference(fqName, SModelId.generate()));
    for (ModuleReference language : model.importedLanguages()) {
      newModel.addLanguage(language);
    }
    for (SModelReference importedModel : SModelOperations.getImportedModelUIDs(model)) {
      newModel.addModelImport(importedModel, false);
    }
    for (ModuleReference devKit : model.importedDevkits()) {
      newModel.addDevKit(devKit);
    }
    return newModel;
  }

  public static void copyTextToClipboard(String text) {
    CopyPasteManagerEx.getInstanceEx().setContents(new StringSelection(text));
  }

  public static void copyNodesAndTextToClipboard(List<SNode> nodes, String text) {
    setClipboardContents(new SNodeTransferable(nodes, text));
  }

  public static void copyNodesAndTextToClipboard(List<SNode> nodes, Map<SNode, Set<SNode>> nodesAndAttributes, String text) {
    setClipboardContents(new SNodeTransferable(nodes, text, nodesAndAttributes));
  }

  /**
   * A workaround for the following problem with CopyPasteManagerEx:
   * 
   *          if stringContent of one of existing Transferable instances stored inside CopyPasteManagerEx.myDatas
   * collection is equals to the stringContent of Transferable we are trying to "push" there (used as a parameter
   * of this method) then existing element will "float up" inside CopyPasteManagerEx.myDatas collection and will
   * be used next on next paste operation instead of passed Transferable.
   * 
   * In case of MPS precondition that string equality of clipboard ontent meant actual equality of passed Trabsferables
   * (SNodeTransferables) is generally wrong, so we have to work around this logic by deleting all exiting Transferables
   * to avoid possible collisions between copied elements preventing user from copying actual node under mouse in editor.
   */
  private static void setClipboardContents(Transferable content) {
    try {
      String stringContent = getStringContent(content);
      if (stringContent != null) {
        for (Transferable existingContent : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
          if (stringContent.equals(getStringContent(existingContent))) {
            CopyPasteManagerEx.getInstanceEx().removeContent(existingContent);
          }
        }
      }
    } catch (UnsupportedFlavorException e) {
    } catch (IOException ex) {
    }
    CopyPasteManagerEx.getInstanceEx().setContents(content);
  }

  private static String getStringContent(Transferable content) throws UnsupportedFlavorException, IOException {
    return (String) content.getTransferData(DataFlavor.stringFlavor);
  }

  public static void copyNodesToClipboard(List<SNode> nodes) {
    StringBuilder stringBuilder = new StringBuilder();
    int i = 1;
    int size = nodes.size();
    for (SNode node : nodes) {
      stringBuilder.append(node.getDebugText());
      if (i < size) {
        stringBuilder.append("\n");
      }
      i++;
    }
    CopyPasteUtil.copyNodesAndTextToClipboard(nodes, stringBuilder.toString());
  }

  public static void copyNodeToClipboard(SNode node) {
    List<SNode> list = new ArrayList<SNode>();
    list.add(node);
    CopyPasteUtil.copyNodesToClipboard(list);
  }

  public static List<SNode> getNodesFromClipboard(SModel model) {
    return CopyPasteUtil.getPasteNodeDataFromClipboard(model).getNodes();
  }

  public static PasteNodeData getPasteNodeDataFromClipboard(SModel model) {
    IModule module = model.getModelDescriptor().getModule();
    Transferable content = null;
    for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
      if (trf != null && trf.isDataFlavorSupported(SModelDataFlavor.sNode)) {
        content = trf;
      }
      break;
    }
    if (content == null) {
      return PasteNodeData.emptyPasteNodeData(module, model);
    }
    if (content.isDataFlavorSupported(SModelDataFlavor.sNode)) {
      SNodeTransferable nodeTransferable;
      try {
        nodeTransferable = (SNodeTransferable) content.getTransferData(SModelDataFlavor.sNode);
        return nodeTransferable.createNodeData(model);
      } catch (UnsupportedFlavorException e) {
        if (log.isErrorEnabled()) {
          log.error("Exception", e);
        }
      } catch (IOException e) {
        if (log.isErrorEnabled()) {
          log.error("Exception", e);
        }
      }
    }
    return PasteNodeData.emptyPasteNodeData(module, model);
  }

  public static SNode getNodeFromClipboard(SModel model) {
    return CopyPasteUtil.getNodesFromClipboard(model).get(0);
  }

  @CodeOrchestraPatch
  public static boolean addImportsWithDialog(final IModule sourceModule, final SModel targetModel, final Set<ModuleReference> necessaryLanguages, final Set<SModelReference> necessaryImports, final IOperationContext context) {
    if (targetModel.getModelDescriptor().getModule() == null) {
      return true;
    }
    final List<ModuleReference> additionalLanguages = new ArrayList<ModuleReference>();
    final List<SModelReference> additionalModels = new ArrayList<SModelReference>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        List<SModelReference> allImportedModels = new ArrayList<SModelReference>();
        for (SModelDescriptor sm : SModelOperations.allImportedModels(targetModel, context.getScope())) {
          allImportedModels.add(sm.getSModelReference());
        }
        for (SModelReference modelReference : necessaryImports) {
          if (modelReference != null && !((allImportedModels.contains(modelReference))) && !((targetModel.getSModelReference().equals(modelReference)))) {
            additionalModels.add(modelReference);
          }
        }
        necessaryImports.retainAll(additionalModels);

        // RE-3160
        Set<ModuleReference> importedLanguages = new ArrayListSet<ModuleReference>();
        for (ModuleReference moduleReference : necessaryLanguages) {
          if (ModuleReferenceUtils.checkContainsByFQName(importedLanguages, moduleReference)) {
            additionalLanguages.add(moduleReference);
          }

          /*
          if (!(SModelOperations.hasLanguage(targetModel, moduleReference))) {
            additionalLanguages.add(moduleReference);
          }
          */
        }
        necessaryLanguages.retainAll(additionalLanguages);
      }
    });
    if ((!(necessaryImports.isEmpty())) || (!(necessaryLanguages.isEmpty()))) {
      // RE-3387 - Check if the only model to add is a default one
      if (necessaryImports.size() == 1 && necessaryLanguages.isEmpty()) {
        final SModelReference onlyModelReference = necessaryImports.iterator().next();
        if (onlyModelReference.getLongName().equals("")) {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              targetModel.addModelImport(onlyModelReference, true);
            }
          });

          return true;
        }
      }

      AddRequiredModelImportsDialog dialog = ModelAccess.instance().runReadAction(new Computable<AddRequiredModelImportsDialog>() {
        public AddRequiredModelImportsDialog compute() {
          return new AddRequiredModelImportsDialog(context, sourceModule, targetModel, necessaryImports, necessaryLanguages);
        }
      });
      dialog.setModal(true);
      dialog.showDialog();
      return !(dialog.isCancelled());
    }
    return true;
  }

  public static boolean doesClipboardContainNode() {
    Transferable content = null;
    for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
      if (trf != null && trf.isDataFlavorSupported(SModelDataFlavor.sNode)) {
        return true;
      }
      break;
    }
    return false;
  }

  public static synchronized void setDataConverter(CopyPasteUtil.IDataConverter dataConverter) {
    myDataConverter = dataConverter;
  }

  public static synchronized boolean isConversionAvailable(SModel model, SNode anchor) {
    return myDataConverter != null && myDataConverter.canPasteAsNodes(model, anchor);
  }

  public static synchronized PasteNodeData getConvertedFromClipboard(SModel model) {
    return (myDataConverter == null ?
      null :
      myDataConverter.getPasteNodeData(model)
    );
  }

  public static boolean canPasteNodes(SModel model, SNode anchor) {
    List<SNode> nodes = getNodesFromClipboard(model);
    return ListSequence.fromList(nodes).isNotEmpty() || isConversionAvailable(model, anchor);
  }

  public static synchronized void pasteNodes(SModel model, SNode anchor) {
    if (myDataConverter != null) {
      myDataConverter.pasteAsNodes(model, anchor);
    }
  }

  public static interface IDataConverter {
    public boolean canPasteAsNodes(SModel model, SNode anchor);
    public void pasteAsNodes(SModel model, SNode anchor);
    public PasteNodeData getPasteNodeData(SModel model);
  }
}
