package jetbrains.mps.ide.actions;

/*Generated by MPS */

import jetbrains.mps.ide.dialogs.BaseDialog;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.ide.ui.MPSTree;
import jetbrains.mps.ide.ui.MPSTreeNode;
import java.awt.Frame;
import java.awt.HeadlessException;
import javax.swing.InputMap;
import javax.swing.KeyStroke;
import java.awt.event.KeyEvent;
import javax.swing.AbstractAction;
import java.awt.event.ActionEvent;
import javax.swing.JComponent;
import java.util.List;
import com.intellij.openapi.actionSystem.AnAction;
import java.util.ArrayList;
import com.intellij.ui.treeStructure.actions.CollapseAllAction;
import com.intellij.ui.treeStructure.actions.ExpandAllAction;
import jetbrains.mps.smodel.SNode;
import com.intellij.util.containers.MultiMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.ide.ui.TextTreeNode;
import java.util.Comparator;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.ide.dialogs.DialogDimensionsSettings;
import javax.swing.JScrollPane;
import com.intellij.ui.ScrollPaneFactory;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import jetbrains.mps.smodel.ModelAccess;
import javax.swing.tree.TreePath;
import java.util.Arrays;
import java.util.Collections;
import jetbrains.mps.ide.icons.IconManager;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public abstract class BaseAddMethodDialog extends BaseDialog {
  private EditorContext myContext;
  private MPSTree myTree = new MPSTree() {
    protected MPSTreeNode rebuild() {
      return rebuildOurTree();
    }
  };

  public BaseAddMethodDialog(EditorContext context, Frame mainFrame, String title) throws HeadlessException {
    super(mainFrame, title);
    myContext = context;
    InputMap inputMap = myTree.getInputMap();
    for (KeyStroke ks : inputMap.allKeys()) {
      if (ks.getKeyCode() == KeyEvent.VK_ENTER) {
        inputMap.put(ks, new Object());
      }
    }
    myTree.registerKeyboardAction(new AbstractAction() {
      public void actionPerformed(ActionEvent e) {
        onOk();
      }
    }, KeyStroke.getKeyStroke("ENTER"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  }

  protected List<AnAction> getToolbarActions() {
    List<AnAction> result = new ArrayList<AnAction>();
    result.add(new CollapseAllAction(myTree));
    result.add(new ExpandAllAction(myTree));
    return result;
  }

  protected void refreshTree() {
    myTree.rebuildLater();
  }

  protected abstract List<SNode> collectImplementableMethods();

  protected abstract int compareMethods(SNode m1, SNode m2);

  protected abstract List<SNode> doAddMethods(List<BaseAddMethodDialog.MethodTreeNode> paths);

  protected abstract SNode getContainer(SNode bm);

  protected abstract int compareContainers(SNode c1, SNode c2);

  protected abstract JComponent createAdditionalOptionsComponent();

  private MPSTreeNode rebuildOurTree() {
    MultiMap<SNode, SNode> methodsByContainer = new MultiMap<SNode, SNode>();
    for (SNode method : ListSequence.fromList(collectImplementableMethods())) {
      methodsByContainer.putValue(getContainer(method), method);
    }
    List<SNode> containers = new ArrayList<SNode>();
    ListSequence.fromList(containers).addSequence(SetSequence.fromSet(methodsByContainer.keySet()));
    TextTreeNode root = new TextTreeNode("Methods");
    for (SNode container : ListSequence.fromList(containers).sort(new Comparator<SNode>() {
      public int compare(SNode a, SNode b) {
        return compareContainers(a, b);
      }
    }, true)) {
      List<SNode> methods = new ArrayList<SNode>();
      ListSequence.fromList(methods).addSequence(Sequence.fromIterable(methodsByContainer.get(container)));
      BaseAddMethodDialog.NodeTreeNode node = new BaseAddMethodDialog.NodeTreeNode(container);
      for (SNode method : ListSequence.fromList(methods).sort(new Comparator<SNode>() {
        public int compare(SNode a, SNode b) {
          return compareMethods(a, b);
        }
      }, true)) {
        node.add(new BaseAddMethodDialog.MethodTreeNode(method));
      }
      root.add(node);
    }
    return root;
  }

  public DialogDimensionsSettings.DialogDimensions getDefaultDimensionSettings() {
    return new DialogDimensionsSettings.DialogDimensions(200, 200, 400, 300);
  }

  protected JComponent getMainComponent() {
    myTree.rebuildNow();
    myTree.expandAll();
    myTree.selectFirstLeaf();
    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myTree);
    JComponent optionsComponent = createAdditionalOptionsComponent();
    if (optionsComponent == null) {
      return scrollPane;
    }
    List<AnAction> actions = getToolbarActions();
    DefaultActionGroup group = new DefaultActionGroup(actions.toArray(new AnAction[actions.size()]));
    JComponent toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true).getComponent();
    JPanel mainPanel = new JPanel(new BorderLayout());
    mainPanel.add(toolbar, BorderLayout.NORTH);
    mainPanel.add(scrollPane, BorderLayout.CENTER);
    mainPanel.add(optionsComponent, BorderLayout.SOUTH);
    return mainPanel;
  }

  @BaseDialog.Button(position = 0, name = "OK", mnemonic = 'O', defaultButton = true)
  public void onOk() {
    dispose();
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        List<TreePath> paths = new ArrayList<TreePath>(Arrays.asList(myTree.getSelectionPaths()));
        List<BaseAddMethodDialog.MethodTreeNode> methodNodes = ListSequence.fromList(new ArrayList<BaseAddMethodDialog.MethodTreeNode>());
        for (TreePath path : paths) {
          if (path.getLastPathComponent() instanceof BaseAddMethodDialog.MethodTreeNode) {
            ListSequence.fromList(methodNodes).addElement((BaseAddMethodDialog.MethodTreeNode) path.getLastPathComponent());
          }
        }
        Collections.sort(methodNodes, new Comparator<BaseAddMethodDialog.MethodTreeNode>() {
          public int compare(BaseAddMethodDialog.MethodTreeNode m1, BaseAddMethodDialog.MethodTreeNode m2) {
            return compareMethods(m1.getMethod(), m2.getMethod());
          }
        });
        List<SNode> methods = doAddMethods(ListSequence.fromList(methodNodes).reversedList());
        if (methods.isEmpty()) {
          return;
        }
        if (methods.size() == 1) {
          SNode node = methods.get(0);
          myContext.selectAfter(node);
        } else {
          SNode first = methods.get(methods.size() - 1);
          SNode last = methods.get(0);
          myContext.select(first);
          myContext.selectRange(first, last);
        }
      }
    });
  }

  @BaseDialog.Button(position = 1, name = "Cancel", mnemonic = 'C')
  public void onCancel() {
    dispose();
  }

  private static class NodeTreeNode extends MPSTreeNode {
    private SNode myNode;

    public NodeTreeNode(SNode node) {
      super(null);
      myNode = node;
      setIcon(IconManager.getIconFor(myNode));
      setNodeIdentifier(myNode.getName());
    }
  }

  public static class MethodTreeNode extends MPSTreeNode {
    private SNode myMethod;

    public MethodTreeNode(SNode method) {
      super(null);
      myMethod = method;
      setIcon(IconManager.getIconFor(myMethod));
      setNodeIdentifier(((String) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(myMethod, "jetbrains.mps.lang.core.structure.BaseConcept"), "virtual_getPresentation_1213877396640", new Class[]{SNode.class})));
    }

    public SNode getMethod() {
      return myMethod;
    }
  }
}
