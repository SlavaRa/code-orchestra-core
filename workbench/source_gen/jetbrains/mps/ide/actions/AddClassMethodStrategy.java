package jetbrains.mps.ide.actions;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.search.ClassifierAndSuperClassifiersScope;

public class AddClassMethodStrategy implements StratergyAddMethodDialog.ContainerStrategy {
  private SNode myClassConcept;
  private SNode myContextMethod;

  public AddClassMethodStrategy(final SNode contextNode) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        myClassConcept = SNodeOperations.getAncestor(contextNode, "jetbrains.mps.baseLanguage.structure.ClassConcept", true, false);
        myContextMethod = SNodeOperations.getAncestor(contextNode, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration", true, false);
      }
    });
  }

  public List<StratergyAddMethodDialog.ContainerStrategy.MethodAddition> doAddMethods(List<SNode> baseMethods) {
    boolean insertion = myContextMethod != null && SNodeOperations.getParent(myContextMethod) == myClassConcept;
    List<StratergyAddMethodDialog.ContainerStrategy.MethodAddition> methods = new ArrayList<StratergyAddMethodDialog.ContainerStrategy.MethodAddition>();
    for (SNode m : baseMethods) {
      SNode methodNode = SNodeOperations.cast(m, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration");
      SNode method = ((SNode) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(methodNode, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "call_getMethodToImplement_69709522611978987", new Class[]{SNode.class, SNode.class}, myClassConcept));
      methods.add(new StratergyAddMethodDialog.ContainerStrategy.MethodAddition(methodNode, method));
      SPropertyOperations.set(method, "isAbstract", "" + false);
      SLinkOperations.setTarget(method, "body", SNodeFactoryOperations.createNewNode(SNodeOperations.getModel(myClassConcept), "jetbrains.mps.baseLanguage.structure.StatementList", null), true);
      if (insertion) {
        ListSequence.fromList(SLinkOperations.getTargets(myClassConcept, "method", true)).insertElement(ListSequence.fromList(SLinkOperations.getTargets(myClassConcept, "method", true)).indexOf(myContextMethod) + 1, method);
      } else {
        ListSequence.fromList(SLinkOperations.getTargets(myClassConcept, "method", true)).addElement(method);
      }
    }
    return methods;
  }

  private Integer getSuperclassesCount(SNode node) {
    SNode classifier = SNodeOperations.as(node, "jetbrains.mps.baseLanguage.structure.Classifier");
    if ((classifier == null)) {
      return 0;
    }
    return new ClassifierAndSuperClassifiersScope(classifier).getClassifiers().size();
  }

  public int compareContainers(SNode c1, SNode c2) {
    return getSuperclassesCount(c2).compareTo(getSuperclassesCount(c1));
  }

  public SNode getMainContainer() {
    return myClassConcept;
  }

  public SNode getContainer(SNode methodDecl) {
    return SNodeOperations.getAncestor(methodDecl, "jetbrains.mps.baseLanguage.structure.Classifier", true, false);
  }
}
