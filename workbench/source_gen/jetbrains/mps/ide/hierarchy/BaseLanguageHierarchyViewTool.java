package jetbrains.mps.ide.hierarchy;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import java.util.Set;
import jetbrains.mps.smodel.SNode;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.ide.progress.IAdaptiveProgressMonitor;

public class BaseLanguageHierarchyViewTool extends AbstractHierarchyView {
  public BaseLanguageHierarchyViewTool(Project project) {
    super(project, "Class Hierarchy", -1, IconContainer.ICON_d0a0);
  }

  protected AbstractHierarchyTree createHierarchyTree(boolean isParentHierarchy) {
    return new BaseLanguageHierarchyViewTool.BaseLanguageHierarchyTree(this, "jetbrains.mps.baseLanguage.structure.Classifier", isParentHierarchy);
  }

  private static class BaseLanguageHierarchyTree extends AbstractHierarchyTree {
    public BaseLanguageHierarchyTree(AbstractHierarchyView abstractHierarchyView, String aClass, boolean isParentHierarchy) {
      super(abstractHierarchyView, aClass, isParentHierarchy);
    }

    protected Set<SNode> getParents(SNode node, Set<SNode> visited) {
      HashSet<SNode> result = new HashSet<SNode>();
      if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        SNode classConcept = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassConcept");
        SNode classifierType = SLinkOperations.getTarget(classConcept, "superclass", true);
        if (classifierType != null) {
          SNode classifier = SLinkOperations.getTarget(classifierType, "classifier", false);
          if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
            result.add(classifier);
          }
        }
        for (SNode interfaceType : SLinkOperations.getTargets(classConcept, "implementedInterface", true)) {
          SNode interfaceClassifier = SLinkOperations.getTarget(interfaceType, "classifier", false);
          if (SNodeOperations.isInstanceOf(interfaceClassifier, "jetbrains.mps.baseLanguage.structure.Interface")) {
            result.add(interfaceClassifier);
          }
        }
      } else
      if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Interface")) {
        SNode anInterface = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Interface");
        for (SNode interfaceType : SLinkOperations.getTargets(anInterface, "extendedInterface", true)) {
          SNode interfaceClassifier = SLinkOperations.getTarget(interfaceType, "classifier", false);
          if (SNodeOperations.isInstanceOf(interfaceClassifier, "jetbrains.mps.baseLanguage.structure.Interface")) {
            result.add(interfaceClassifier);
          }
        }
      }
      return result;
    }

    protected String noNodeString() {
      return "(no classifier)";
    }

    protected SNode getParent(SNode node) {
      if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        SNode classConcept = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassConcept");
        SNode type = SLinkOperations.getTarget(classConcept, "superclass", true);
        if (type == null) {
          return null;
        }
        SNode classifier = SLinkOperations.getTarget(type, "classifier", false);
        if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
          return classifier;
        }
      } else
      if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Interface")) {
        return null;
      }
      return null;
    }

    protected Set<SNode> getDescendants(SNode node, Set<SNode> visited) {
      Set<SReference> usages = myUsagesManager.findUsages(node, GlobalScope.getInstance(), IAdaptiveProgressMonitor.NULL_PROGRESS_MONITOR);
      Set<SNode> result = new HashSet<SNode>();
      for (SReference usage : usages) {
        SNode sourceNode = usage.getSourceNode();
        if ("classifier".equals(usage.getRole())) {
          if (SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
            SNode classifierType = SNodeOperations.cast(sourceNode, "jetbrains.mps.baseLanguage.structure.ClassifierType");
            if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(classifierType), "jetbrains.mps.baseLanguage.structure.ClassConcept") && "superclass".equals(classifierType.getRole_())) {
              result.add(SNodeOperations.getParent(classifierType));
            }
            if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(classifierType), "jetbrains.mps.baseLanguage.structure.ClassConcept") && "implementedInterface".equals(classifierType.getRole_())) {
              result.add(SNodeOperations.getParent(classifierType));
            }
            if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(classifierType), "jetbrains.mps.baseLanguage.structure.Interface") && "extendedInterface".equals(classifierType.getRole_())) {
              result.add(SNodeOperations.getParent(classifierType));
            }
          }
        }
        if ("classifier".equals(usage.getRole())) {
          if (SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
            SNode anonymousClass = SNodeOperations.cast(sourceNode, "jetbrains.mps.baseLanguage.structure.AnonymousClass");
            result.add(anonymousClass);
          }
        }
      }
      return result;
    }
  }
}
