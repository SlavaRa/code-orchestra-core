package jetbrains.mps.ide.properties;

/*Generated by MPS */

import jetbrains.mps.project.structure.model.ModelRoot;
import jetbrains.mps.project.structure.modules.ClassPathEntry;
import jetbrains.mps.project.structure.modules.Dependency;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.util.annotation.CodeOrchestraPatch;
import jetbrains.mps.workbench.dialogs.project.components.parts.lists.ListsFactory;
import org.apache.commons.lang.ObjectUtils;

import java.util.List;

public class ModuleProperties {
  public static final String NAMESPACE = "namespace";
  public static final String COMPILE_IN_MPS = "compileInMPS";
  public static final String USED_LANGUAGES = "usedLanguages";
  public static final String USED_DEVKITS = "usedDevkits";

  private String myNamespace;
  private boolean myCompileInMPS;
  private List<ModelRoot> myModelRoots;
  private List<Dependency> myDependencies;
  private List<ModuleReference> myUsedLanguages;
  private List<ModuleReference> myUsedDevkits;
  private List<String> mySourcePaths;
  private List<ClassPathEntry> myClassPaths;
  private List<ModelRoot> myStubModels;

  public ModuleProperties() {
    myModelRoots = ListsFactory.create(ListsFactory.MODEL_ROOT_COMPARATOR);
    myDependencies = ListsFactory.create(ListsFactory.DEPENDENCY_COMPARATOR);
    myUsedLanguages = ListsFactory.create(ListsFactory.MODULE_VALID_REF_COMPARATOR);
    myUsedDevkits = ListsFactory.create(ListsFactory.MODULE_VALID_REF_COMPARATOR);
    mySourcePaths = (List) ListsFactory.create(ListsFactory.COMPARABLE_COMPARATOR);
    myClassPaths = ListsFactory.create(ListsFactory.CLASSPATH_ENTRY_COMPARATOR);
    myStubModels = ListsFactory.create(ListsFactory.MODEL_ROOT_COMPARATOR);
  }

  public String getNamespace() {
    return myNamespace;
  }

  public void setNamespace(String namespace) {
    myNamespace = namespace;
  }

  public boolean isCompileInMPS() {
    return myCompileInMPS;
  }

  public void setCompileInMPS(boolean compileInMPS) {
    myCompileInMPS = compileInMPS;
  }

  public List<ModelRoot> getModelRoots() {
    return myModelRoots;
  }

  public void setModelRoots(List<ModelRoot> modelRoots) {
    myModelRoots = modelRoots;
  }

  public List<Dependency> getDependencies() {
    return myDependencies;
  }

  public void setDependencies(List<Dependency> dependencies) {
    myDependencies = dependencies;
  }

  public List<ModuleReference> getUsedLanguages() {
    return myUsedLanguages;
  }

  public void setUsedLanguages(List<ModuleReference> usedLanguages) {
    myUsedLanguages = usedLanguages;
  }

  public List<ModuleReference> getUsedDevkits() {
    return myUsedDevkits;
  }

  public void setUsedDevkits(List<ModuleReference> usedDevkits) {
    myUsedDevkits = usedDevkits;
  }

  public List<String> getSourcePaths() {
    return mySourcePaths;
  }

  public void setSourcePaths(List<String> sourcePaths) {
    mySourcePaths = sourcePaths;
  }

  public List<ClassPathEntry> getClassPaths() {
    return myClassPaths;
  }

  public void setClassPaths(List<ClassPathEntry> classPaths) {
    myClassPaths = classPaths;
  }

  public List<ModelRoot> getStubModels() {
    return myStubModels;
  }

  public void setStubModels(List<ModelRoot> stubModels) {
    myStubModels = stubModels;
  }

  public void loadFrom(ModuleDescriptor descriptor) {
    myNamespace = descriptor.getNamespace();
    myCompileInMPS = descriptor.getCompileInMPS();
    for (ModelRoot root : descriptor.getModelRoots()) {
      myModelRoots.add((root != null ?
        root.getCopy() :
        null
      ));
    }
    for (Dependency dep : descriptor.getDependencies()) {
      myDependencies.add((dep != null ?
        dep.getCopy() :
        null
      ));
    }
    myUsedLanguages.addAll(descriptor.getUsedLanguages());
    myUsedDevkits.addAll(descriptor.getUsedDevkits());
    for (String p : descriptor.getSourcePaths()) {
      mySourcePaths.add(p);
    }
    for (ModelRoot entry : descriptor.getStubModelEntries()) {
      myStubModels.add((entry != null ?
        entry.getCopy() :
        null
      ));
    }
  }

  public void saveTo(ModuleDescriptor descriptor) {
    descriptor.setNamespace(myNamespace);
    descriptor.setCompileInMPS(myCompileInMPS);
    descriptor.getModelRoots().clear();
    descriptor.getModelRoots().addAll(myModelRoots);
    descriptor.getDependencies().clear();
    descriptor.getDependencies().addAll(myDependencies);
    descriptor.getUsedLanguages().clear();
    descriptor.getUsedLanguages().addAll(myUsedLanguages);
    descriptor.getUsedDevkits().clear();
    descriptor.getUsedDevkits().addAll(myUsedDevkits);
    descriptor.getSourcePaths().clear();
    descriptor.getSourcePaths().addAll(mySourcePaths);
    descriptor.getStubModelEntries().clear();
    descriptor.getStubModelEntries().addAll(myStubModels);
  }

  @CodeOrchestraPatch
  public boolean hasMajorChangesFrom(ModuleProperties anotherProps) {
    if (!areListsEqual(myClassPaths, anotherProps.myClassPaths)) return true;
    if (!areListsEqual(myDependencies, anotherProps.myDependencies)) return true;
    if (!areListsEqual(myModelRoots, anotherProps.myModelRoots)) return true;
    if (!areListsEqual(mySourcePaths, anotherProps.mySourcePaths)) return true;
    if (!areListsEqual(myStubModels, anotherProps.myStubModels)) return true;
    if (!areListsEqual(myUsedDevkits, anotherProps.myUsedDevkits)) return true;
    if (!areListsEqual(myUsedLanguages, anotherProps.myUsedLanguages)) return true;
    return false;
  }

  /**
   * I had to do this as there're some weird lists which are equal if their content is equal.
   */
  @CodeOrchestraPatch
  protected static <T> boolean areListsEqual(List<T> firstList, List<T> secondList) {
    if (firstList == secondList) {
      return true;
    }
    if (firstList == null && secondList != null) {
      return false;
    }
    if (firstList != null && secondList == null) {
      return false;
    }

    if (firstList.size() != secondList.size()) {
      return false;
    }

    for (int i = 0; i < firstList.size(); i++) {
      if (!ObjectUtils.equals(firstList.get(i), secondList.get(i))) {
        return false;
      }
    }
    return true;
  }

}
