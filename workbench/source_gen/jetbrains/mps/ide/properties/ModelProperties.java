package jetbrains.mps.ide.properties;

/*Generated by MPS */

import jetbrains.mps.project.IModule;
import jetbrains.mps.project.Solution;
import jetbrains.mps.project.structure.modules.Dependency;
import jetbrains.mps.project.structure.modules.SolutionDescriptor;
import jetbrains.mps.smodel.*;
import jetbrains.mps.uiLanguage.runtime.BaseBean;

import java.util.*;

import javax.swing.JFrame;
import com.intellij.openapi.wm.WindowManager;

import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.util.annotation.CodeOrchestraPatch;
import jetbrains.mps.workbench.choose.models.SModelReferenceByModule;
import jetbrains.mps.workbench.dialogs.project.components.parts.lists.ListsFactory;
import jetbrains.mps.generator.GeneratorManager;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;

import jetbrains.mps.project.DevKit;

import jetbrains.mps.workbench.dialogs.project.components.parts.lists.ListsFactory.ListComparator;
import org.apache.commons.collections.CollectionUtils;

public class ModelProperties extends BaseBean {

  @CodeOrchestraPatch
  private List<SModelReferenceByModule> importsByModules = ListsFactory.create(new ListComparator<SModelReferenceByModule>() {
    public int compare(SModelReferenceByModule o1, SModelReferenceByModule o2) {
      return ListsFactory.MODEL_REF_COMPARATOR.compare(o1.getModelReference(), o2.getModelReference());
    }
  });

  private List<SModelReference> myImportedModels;
  private List<ModuleReference> myUsedLanguages = ListsFactory.create(ListsFactory.MODULE_VALID_REF_COMPARATOR);
  private List<ModuleReference> myUsedDevKits = ListsFactory.create(ListsFactory.MODULE_VALID_REF_COMPARATOR);
  private List<ModuleReference> myLanguagesEngagedOnGeneration = ListsFactory.create(ListsFactory.MODULE_REF_COMPARATOR);
  private SModelDescriptor myModelDescriptor;
  private IOperationContext myContext;
  private boolean myDoNotGenerate;

  @CodeOrchestraPatch
  private boolean isInSolutionContext;

  public ModelProperties(SModelDescriptor modelDescriptor, IOperationContext context) {
    myModelDescriptor = modelDescriptor;
    myImportedModels = ListsFactory.create(ListsFactory.createValidRefComparator(modelDescriptor.getModule().getScope()));
    myContext = context;
    SModel model = myModelDescriptor.getSModel();
    myImportedModels.addAll(SModelOperations.getImportedModelUIDs(model));
    myUsedLanguages.addAll(model.importedLanguages());
    myUsedDevKits.addAll(model.importedDevkits());
    myLanguagesEngagedOnGeneration.addAll(model.engagedOnGenerationLanguages());
    myDoNotGenerate = GeneratorManager.isDoNotGenerate(myModelDescriptor);

    // RE-1979
    if (context.getModule() instanceof Solution) {
      isInSolutionContext = true;
      initImportsByModules();
    }
  }

  @CodeOrchestraPatch
  public Set<ModuleReference> getModelImportsModuleRefs() {
    Set<ModuleReference> moduleReferences = new HashSet<ModuleReference>();
    for (SModelReferenceByModule sModelReferenceByModule : importsByModules) {
      moduleReferences.add(sModelReferenceByModule.getModuleReference());
    }
    return moduleReferences;
  }

  @CodeOrchestraPatch
  public List<SModelReferenceByModule> getImportsByModules() {
    return importsByModules;
  }

  @CodeOrchestraPatch
  public List<SModelReference> getUniqueImportedModelsByModules() {
    List<SModelReference> result = new ArrayList<SModelReference>();

    for (SModelReferenceByModule sModelReferenceByModule : getImportsByModules()) {
      SModelReference modelReference = sModelReferenceByModule.getModelReference();
      if (!result.contains(modelReference)) {
        result.add(modelReference);
      }
    }

    return result;
  }

  @CodeOrchestraPatch
  public void initImportsByModules() {
    importsByModules.clear();

    IModule owner = myContext.getModule();

    Set<ModuleReference> dependencies = new HashSet<ModuleReference>();
    dependencies.add(owner.getModuleReference());
    for (IModule requiredModule : owner.getDependenciesManager().getRequiredModules()) {
      dependencies.add(requiredModule.getModuleReference());
    }

//    Set<ModuleReference> dependencies = new HashSet<ModuleReference>();
//    dependencies.add(owner.getModuleReference());
//    for (IModule module : owner.getScope().getVisibleModules()) {
//      dependencies.add(module.getModuleReference());
//    }

    for (SModelReference importModelReference : myImportedModels) {
      SModelDescriptor importModelDescriptor = SModelRepository.getInstance().getModelDescriptor(importModelReference);
      Set<IModule> importedModelOwners = SModelRepository.getInstance().getModules(importModelDescriptor);

      for (IModule importedModelOwner : importedModelOwners) {
        ModuleReference importedModelOwnerModuleReference = importedModelOwner.getModuleReference();
        if (dependencies.contains(importedModelOwnerModuleReference)) {
          importsByModules.add(new SModelReferenceByModule(importModelReference, importedModelOwnerModuleReference));
        }
      }
    }
  }

  public SModelDescriptor getModelDescriptor() {
    return myModelDescriptor;
  }

  public List<SModelReference> getImportedModels() {
    return myImportedModels;
  }

  public List<ModuleReference> getUsedLanguages() {
    return myUsedLanguages;
  }

  public List<ModuleReference> getUsedDevKits() {
    return myUsedDevKits;
  }

  public List<ModuleReference> getLanguagesEngagedOnGeneration() {
    return myLanguagesEngagedOnGeneration;
  }

  public boolean isDoNotGenerate() {
    return myDoNotGenerate;
  }

  public void setDoNotGenerate(boolean doNotGenerate) {
    myDoNotGenerate = doNotGenerate;
  }

  public void saveChanges() {
    if (!(myModelDescriptor instanceof EditableSModelDescriptor)) {
      return;
    }
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        addNewModels();
        removeUnusedModels();
        addNewLanguages();
        removeUnusedLanguages();
        addNewDevKits();
        removeUnusedDevKits();
        addNewEngagedOnGenerationLanguages();
        removeUnusedEngagedOnGenerationLanguages();
        if (GeneratorManager.isDoNotGenerate(myModelDescriptor) != myDoNotGenerate) {
          GeneratorManager.setDoNotGenerate(myModelDescriptor, myDoNotGenerate);
        }
        ((EditableSModelDescriptor) myModelDescriptor).save();
      }
    });

    // RE-1979
    if (isInSolutionContext) {
      final Solution solution = (Solution) myContext.getModule();
      final SolutionDescriptor sd = solution.getModuleDescriptor();

      Set<ModuleReference> requiredModuleImports = getModelImportsModuleRefs();
      Set<ModuleReference> existingModuleImports = new HashSet<ModuleReference>();

      // Prepare existingModuleImports
      for (Dependency dependency : solution.getDependOn()) {
        existingModuleImports.add(dependency.getModuleRef());
      }

      // Calc modules to import
      Collection<ModuleReference> modulesToImport = CollectionUtils.subtract(requiredModuleImports, existingModuleImports);
      for (ModuleReference moduleToImport : modulesToImport) {
        Dependency dep = new Dependency();
        dep.setModuleRef(moduleToImport);
        sd.getDependencies().add(dep);
      }

      // Save the solution
      if (!modulesToImport.isEmpty()) {
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            solution.setModuleDescriptor(sd, true);
            solution.save();
          }
        });
      }
    } else {
      JFrame frame = WindowManager.getInstance().getFrame(myContext.getProject());
      new MissingDependenciesFixer(frame, myModelDescriptor).fix(true);
    }
  }

  private void addNewDevKits() {
    Set<ModuleReference> devKitsInModel = new HashSet<ModuleReference>(myModelDescriptor.getSModel().importedDevkits());
    Set<ModuleReference> devKitsInProperties = new HashSet<ModuleReference>(getUsedDevKits());
    devKitsInProperties.removeAll(devKitsInModel);
    for (ModuleReference dk : devKitsInProperties) {
      DevKit devKit = MPSModuleRepository.getInstance().getDevKit(dk);
      assert devKit != null;
      SModel model = myModelDescriptor.getSModel();
      model.addDevKit(dk);
    }
  }

  private void removeUnusedDevKits() {
    Set<ModuleReference> propsDevKits = new HashSet<ModuleReference>(getUsedDevKits());
    List<ModuleReference> imported = new ArrayList<ModuleReference>(myModelDescriptor.getSModel().importedDevkits());
    for (ModuleReference dk : imported) {
      if (!(propsDevKits.contains(dk))) {
        myModelDescriptor.getSModel().deleteDevKit(dk);
      }
    }
  }

  protected String getErrorString() {
    return null;
  }

  private void addNewLanguages() {
    Set<ModuleReference> languagesInModel = new HashSet<ModuleReference>(myModelDescriptor.getSModel().importedLanguages());
    Set<ModuleReference> languagesInProps = new HashSet<ModuleReference>(getUsedLanguages());
    languagesInProps.removeAll(languagesInModel);
    for (ModuleReference ref : languagesInProps) {
      Language language = MPSModuleRepository.getInstance().getLanguage(ref);
      if (language == null) {
        continue;
      }
      if (myModelDescriptor.getModule().getScope().getLanguage(language.getModuleReference()) == null) {
        myModelDescriptor.getModule().addUsedLanguage(language.getModuleReference());
      }
      myModelDescriptor.getSModel().addLanguage(language.getModuleReference());
    }
  }

  private void removeUnusedLanguages() {
    Set<ModuleReference> languagesInModel = new HashSet<ModuleReference>(myModelDescriptor.getSModel().importedLanguages());
    Set<ModuleReference> languagesInProps = new HashSet<ModuleReference>(getUsedLanguages());
    languagesInModel.removeAll(languagesInProps);
    for (ModuleReference namespace : languagesInModel) {
      myModelDescriptor.getSModel().deleteLanguage(namespace);
    }
  }

  private void addNewEngagedOnGenerationLanguages() {
    Set<ModuleReference> languagesInModel = new HashSet<ModuleReference>(myModelDescriptor.getSModel().engagedOnGenerationLanguages());
    Set<ModuleReference> languagesInProps = new HashSet<ModuleReference>(getLanguagesEngagedOnGeneration());
    languagesInProps.removeAll(languagesInModel);
    for (ModuleReference namespace : languagesInProps) {
      myModelDescriptor.getSModel().addEngagedOnGenerationLanguage(namespace);
    }
  }

  private void removeUnusedEngagedOnGenerationLanguages() {
    Set<ModuleReference> languagesInModel = new HashSet<ModuleReference>(myModelDescriptor.getSModel().engagedOnGenerationLanguages());
    Set<ModuleReference> languagesInProps = new HashSet<ModuleReference>(getLanguagesEngagedOnGeneration());
    languagesInModel.removeAll(languagesInProps);
    for (ModuleReference ref : languagesInModel) {
      myModelDescriptor.getSModel().removeEngagedOnGenerationLanguage(ref);
    }
  }

  private void addNewModels() {
    Set<SModelReference> modelsInProps = new HashSet<SModelReference>();

    // RE-1979
    if (isInSolutionContext) {
      modelsInProps.addAll(getUniqueImportedModelsByModules());
    } else {
      modelsInProps.addAll(getImportedModels());
    }

    SModel smodel = myModelDescriptor.getSModel();
    modelsInProps.removeAll(SModelOperations.getImportedModelUIDs(smodel));
    for (SModelReference modelReference : modelsInProps) {
      smodel.addModelImport(modelReference, false);
    }
  }

  private void removeUnusedModels() {
    SModel smodel = myModelDescriptor.getSModel();
    Set<SModelReference> modelsInModel = new HashSet<SModelReference>(SModelOperations.getImportedModelUIDs(smodel));

    // RE-1979
    if (isInSolutionContext) {
      modelsInModel.removeAll(getUniqueImportedModelsByModules());
    } else {
      modelsInModel.removeAll(getImportedModels());
    }

    for (SModelReference modelReference : modelsInModel) {
      smodel.deleteModelImport(modelReference);
    }
  }
}
