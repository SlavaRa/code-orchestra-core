package jetbrains.mps.workbench.dialogs.project.components.parts.renderers;

/*Generated by MPS */

import javax.swing.table.TableCellRenderer;
import java.util.Map;
import java.awt.Component;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import javax.swing.JTable;
import jetbrains.mps.ide.ui.MPSTree;
import jetbrains.mps.ide.ui.MPSTreeNode;
import jetbrains.mps.ide.ui.TextMPSTreeNode;
import jetbrains.mps.project.structure.modules.mappingpriorities.*;
import jetbrains.mps.ide.ui.NewMPSTreeCellRenderer;
import javax.swing.JTree;
import java.awt.Color;
import javax.swing.tree.DefaultTreeCellRenderer;
import com.intellij.ui.DottedBorder;
import java.awt.Insets;
import javax.swing.border.EmptyBorder;

import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.openapi.util.Computable;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.util.annotation.CodeOrchestraPatch;

public class RuleOperandRenderer implements TableCellRenderer {
  private Map<Object, Component> myRenderersCache = MapSequence.fromMap(new WeakHashMap<Object, Component>());

  public RuleOperandRenderer() {
  }

  @CodeOrchestraPatch
  public Component getTableCellRendererComponent(final JTable table, final Object value, boolean isSelected, boolean hasFocus, final int row, final int column) {
    if (MapSequence.fromMap(myRenderersCache).containsKey(value)) {
      return MapSequence.fromMap(myRenderersCache).get(value);
    }
    final boolean[] incomplete = new boolean[]{false};
    MPSTree tree = new MPSTree() {
      @Override
      protected MPSTreeNode rebuild() {
        TextMPSTreeNode root = new TextMPSTreeNode("", null);
        incomplete[0] = !(RuleOperandRenderer.this.add(root, (MappingConfig_AbstractRef) value));

        // CO-4941
        if (column == 2) {
          RuleType ruleType = (RuleType) table.getModel().getValueAt(row, 1);
          if (ruleType == RuleType.ABSOLUTE_FIRST) {
            incomplete[0] = false;
          }
        }

        return root;
      }
    };
    tree.setRootVisible(false);
    tree.rebuildNow();
    tree.expandAll();
    if (isSelected && !(hasFocus)) {
      tree.setForeground(table.getSelectionForeground());
      tree.setBackground(table.getSelectionBackground());
      tree.clearSelection();
      tree.setCellRenderer(new NewMPSTreeCellRenderer() {
        @Override
        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
          return super.getTreeCellRendererComponent(tree, value, true, expanded, leaf, row, hasFocus);
        }
      });
    } else {
      tree.setBackground((incomplete[0] ?
        Color.PINK :
        table.getBackground()
      ));
      tree.setForeground(table.getForeground());
      tree.setCellRenderer(new DefaultTreeCellRenderer() {
        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
          setBackgroundNonSelectionColor(tree.getBackground());
          return super.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
        }
      });
      tree.clearSelection();
    }
    tree.setBorder((hasFocus ?
      new DottedBorder(new Insets(1, 1, 1, 1), Color.BLACK) :
      new EmptyBorder(1, 1, 1, 1)
    ));
    MapSequence.fromMap(myRenderersCache).put(value, tree);
    return tree;
  }

  private boolean add(TextMPSTreeNode root, MappingConfig_AbstractRef ref) {
    if (ref == null) {
      return false;
    }
    if (ref instanceof MappingConfig_RefAllLocal) {
      root.add(new TextMPSTreeNode("*", null));
      return true;
    } else
    if (ref instanceof MappingConfig_RefAllGlobal) {
      root.add(new TextMPSTreeNode("*.*", null));
      return true;
    } else
    if (ref instanceof MappingConfig_SimpleRef) {
      MappingConfig_SimpleRef refC = (MappingConfig_SimpleRef) ref;
      SModelReference modelRef = SModelReference.fromString(refC.getModelUID());
      String nodeName;
      if (refC.getNodeID().equals("*")) {
        nodeName = NameUtil.shortNameFromLongName(modelRef.getLongName()) + ".*";
      } else {
        final SNodePointer p = new SNodePointer(refC.getModelUID(), refC.getNodeID());
        nodeName = ModelAccess.instance().runReadAction(new Computable<String>() {
          public String compute() {
            SModelDescriptor model = p.getModel();
            SNode node = p.getNode();
            if (model == null || node == null) {
              return null;
            }
            String modelName = NameUtil.shortNameFromLongName(model.getLongName());
            return modelName + "." + node.getName();
          }
        });
        if (nodeName == null) {
          String nodeString = p.getModelReference().getSModelFqName().toString() + ":" + p.getNodeId().toString();
          root.add(new TextMPSTreeNode("NOT FOUND: " + nodeString, null));
          return false;
        }
      }
      root.add(new TextMPSTreeNode(nodeName, null));
      return true;
    } else
    if (ref instanceof MappingConfig_ExternalRef) {
      MappingConfig_ExternalRef refC = (MappingConfig_ExternalRef) ref;
      ModuleReference generatorReference = refC.getGenerator();
      if (generatorReference == null) {
        root.add(new TextMPSTreeNode("NOT FOUND: <bad generator reference>", null));
        return false;
      }
      ModuleReference moduleRef = generatorReference;
      Generator generator = (Generator) MPSModuleRepository.getInstance().getModule(moduleRef);
      if (generator == null) {
        String genString = generatorReference.getModuleFqName();
        root.add(new TextMPSTreeNode("NOT FOUND: " + genString, null));
        return false;
      }
      TextMPSTreeNode child = new TextMPSTreeNode(generator.getAlias(), null);
      root.add(child);
      return add(child, refC.getMappingConfig());
    } else
    if (ref instanceof MappingConfig_RefSet) {
      boolean complete = true;
      for (MappingConfig_AbstractRef mappingRef : ((MappingConfig_RefSet) ref).getMappingConfigs()) {
        if (!(add(root, mappingRef))) {
          complete = false;
        }
      }
      return complete;
    }
    return false;
  }
}
