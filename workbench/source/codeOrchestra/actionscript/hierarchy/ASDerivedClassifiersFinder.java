package codeOrchestra.actionscript.hierarchy;/*Generated by MPS */

import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.IScope;
import com.intellij.openapi.project.Project;
import java.util.ArrayList;
import com.intellij.openapi.project.DumbService;
import java.util.Set;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import java.util.Queue;
import java.util.LinkedList;
import com.intellij.util.indexing.FileBasedIndex;
import codeOrchestra.actionScript.index.ASClassifierSuccessorsIndexer;
import codeOrchestra.actionScript.index.SNodeId;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.intellij.psi.search.GlobalSearchScope;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.module.Module;

public class ASDerivedClassifiersFinder {
  private static ASDerivedClassifiersFinder instance = new ASDerivedClassifiersFinder();

  private ASDerivedClassifiersFinder() {
  }

  public List<SNode> getDerivedClassifiers(SNode classifier, IScope scope, Project project) {
    List<SNode> result = new ArrayList<SNode>();

    if (DumbService.getInstance(project).isDumb()) {
      return result;
    }

    Set<VirtualFile> notModifiedModelFiles = SetSequence.fromSet(new HashSet<VirtualFile>());
    List<SNode> modifiedClasses = new ArrayList<SNode>();
    List<SNode> modifiedInterfaces = new ArrayList<SNode>();

    for (SModelDescriptor modelDescriptor : scope.getModelDescriptors()) {
      if (!(modelDescriptor instanceof EditableSModelDescriptor)) {
        continue;
      }

      EditableSModelDescriptor emd = (EditableSModelDescriptor) modelDescriptor;
      IFile modelFile = emd.getModelFile();
      if (modelFile == null) {
        continue;
      }

      if (emd.isChanged()) {
        for (SNode sNode : SModelOperations.getNodes(emd.getSModel(), null)) {
          if (SNodeOperations.isInstanceOf(sNode, "codeOrchestra.actionScript.structure.ClassConcept")) {
            ListSequence.fromList(modifiedClasses).addElement(SNodeOperations.cast(sNode, "codeOrchestra.actionScript.structure.ClassConcept"));
          } else if (SNodeOperations.isInstanceOf(sNode, "codeOrchestra.actionScript.structure.Interface")) {
            ListSequence.fromList(modifiedInterfaces).addElement(SNodeOperations.cast(sNode, "codeOrchestra.actionScript.structure.Interface"));
          }
        }
      } else {
        SetSequence.fromSet(notModifiedModelFiles).addElement(VirtualFileUtils.getVirtualFile(modelFile));
      }
    }

    Queue<SNode> classifiersQueue = new LinkedList<SNode>();
    classifiersQueue.add(classifier);

    ASDerivedClassifiersFinder.ValueProcessor valueProcessor = new ASDerivedClassifiersFinder.ValueProcessor(result, classifiersQueue);
    ASDerivedClassifiersFinder.ModifiedSuccessorFinder modifiedSuccessorFinder = new ASDerivedClassifiersFinder.ModifiedSuccessorFinder(modifiedClasses, modifiedInterfaces, result, classifiersQueue);
    ASDerivedClassifiersFinder.SearchScope searchScope = new ASDerivedClassifiersFinder.SearchScope(notModifiedModelFiles);

    SNode nextClassifier;
    while ((nextClassifier = classifiersQueue.poll()) != null) {
      FileBasedIndex.getInstance().processValues(ASClassifierSuccessorsIndexer.NAME, new SNodeId(nextClassifier), null, valueProcessor, searchScope);
      modifiedSuccessorFinder.process(nextClassifier);
    }

    return result;
  }

  public static ASDerivedClassifiersFinder getInstance() {
    return ASDerivedClassifiersFinder.instance;
  }

  public static class ValueProcessor implements FileBasedIndex.ValueProcessor<List<SNodeId>> {
    private List<SNode> myResult;
    private Queue<SNode> myClassifiersQueue;
    private Set<SNodeId> myProcessedNodes = new HashSet();

    public ValueProcessor(List<SNode> result, Queue<SNode> queue) {
      this.myResult = result;
      this.myClassifiersQueue = queue;
    }

    public boolean process(VirtualFile file, List<SNodeId> successors) {
      for (SNodeId sNodeId : successors) {
        if (myProcessedNodes.contains(sNodeId)) {
          continue;
        }
        myProcessedNodes.add(sNodeId);
        SNode node = sNodeId.getNode();
        if (node != null) {
          myResult.add(SNodeOperations.cast(node, "codeOrchestra.actionScript.structure.Classifier"));
          myClassifiersQueue.add(node);
        }
      }
      return true;
    }
  }

  public static class ModifiedSuccessorFinder {
    private List<SNode> myModifiedClasses;
    private List<SNode> myModifiedInterfaces;
    private Queue<SNode> myClassifiersQueue;
    private List<SNode> myResult;
    private Set<SNode> myProcessedNodes = new HashSet<SNode>();
    private Map<SNode, List<SNode>> mySuccessorsMap = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());
    private boolean myInterfacesMapped;
    private boolean myClassesMapped;

    public ModifiedSuccessorFinder(List<SNode> modifiedClasses, List<SNode> modifiedInterfaces, List<SNode> result, Queue<SNode> classifiersQueue) {
      this.myModifiedClasses = modifiedClasses;
      this.myModifiedInterfaces = modifiedInterfaces;
      this.myResult = result;
      this.myClassifiersQueue = classifiersQueue;
    }

    public void process(SNode superClassifier) {
      if (myProcessedNodes.contains(superClassifier)) {
        return;
      }
      myProcessedNodes.add(superClassifier);

      // lazy initialization of mySuccessorsMap 
      if (SNodeOperations.isInstanceOf(superClassifier, "codeOrchestra.actionScript.structure.Interface")) {
        mapInterfaces();
      } else if (SNodeOperations.isInstanceOf(superClassifier, "codeOrchestra.actionScript.structure.ClassConcept")) {
        mapInterfaces();
        mapClasses();
      } else {
        return;
      }

      List<SNode> successors = MapSequence.fromMap(mySuccessorsMap).get(SNodeOperations.cast(superClassifier, "codeOrchestra.actionScript.structure.Classifier"));
      if (successors != null) {
        for (SNode successor : ListSequence.fromList(successors)) {
          myResult.add(successor);
          myClassifiersQueue.add(successor);
        }
      }
    }

    private void mapClasses() {
      if (myClassesMapped) {
        return;
      }
      myClassesMapped = true;

      for (SNode aClass : ListSequence.fromList(myModifiedClasses)) {
        // Superclass 
        SNode superClass = SLinkOperations.getTarget(aClass, "superclass", true);
        if (!(SNodeOperations.isInstanceOf(superClass, "codeOrchestra.actionScript.structure.DynamicClassifierType"))) {
          safeMap(SLinkOperations.getTarget(superClass, "reference", false), aClass);
        }

        // Implemented interfaces 
        for (SNode implementedInterface : ListSequence.fromList(SLinkOperations.getTargets(aClass, "implementedInterface", true))) {
          if (!(SNodeOperations.isInstanceOf(implementedInterface, "codeOrchestra.actionScript.structure.DynamicClassifierType"))) {
            safeMap(SLinkOperations.getTarget(implementedInterface, "reference", false), aClass);
          }
        }
      }
    }

    private void mapInterfaces() {
      if (myInterfacesMapped) {
        return;
      }
      myInterfacesMapped = true;

      for (SNode aInterface : ListSequence.fromList(myModifiedInterfaces)) {
        // Extended interfaces 
        for (SNode extendedInterface : ListSequence.fromList(SLinkOperations.getTargets(aInterface, "extendedInterface", true))) {
          if (!(SNodeOperations.isInstanceOf(extendedInterface, "codeOrchestra.actionScript.structure.DynamicClassifierType"))) {
            safeMap(SLinkOperations.getTarget(extendedInterface, "reference", false), aInterface);
          }
        }
      }
    }

    private void safeMap(SNode predecessor, SNode successor) {
      if ((predecessor == null)) {
        return;
      }

      List<SNode> successors = MapSequence.fromMap(mySuccessorsMap).get(predecessor);
      if (successors == null) {
        successors = new ArrayList<SNode>();
        MapSequence.fromMap(mySuccessorsMap).put(predecessor, successors);
      }
      ListSequence.fromList(successors).addElement(successor);
    }
  }

  public static class SearchScope extends GlobalSearchScope {
    private Set<VirtualFile> myFilesInScope;

    public SearchScope(Set<VirtualFile> notModifiedModelFiles) {
      super(null);
      this.myFilesInScope = notModifiedModelFiles;
    }

    public boolean contains(VirtualFile file) {
      return SetSequence.fromSet(myFilesInScope).contains(file);
    }

    public int compare(VirtualFile file1, VirtualFile file2) {
      return file1.getPath().compareTo(file2.getPath());
    }

    public boolean isSearchInModuleContent(@NotNull Module module) {
      return true;
    }

    public boolean isSearchInLibraries() {
      return false;
    }
  }
}